Directory structure:
└── tyrrrz-youtubeexplode.git/
    ├── Readme.md
    ├── Directory.Build.props
    ├── License.txt
    ├── NuGet.config
    ├── YoutubeExplode.sln
    ├── YoutubeExplode/
    │   ├── FodyWeavers.xml
    │   ├── FodyWeavers.xsd
    │   ├── YoutubeClient.cs
    │   ├── YoutubeExplode.csproj
    │   ├── YoutubeHttpHandler.cs
    │   ├── Bridge/
    │   │   ├── ChannelPage.cs
    │   │   ├── ClosedCaptionTrackResponse.cs
    │   │   ├── DashManifest.cs
    │   │   ├── IPlaylistData.cs
    │   │   ├── IStreamData.cs
    │   │   ├── PlayerResponse.cs
    │   │   ├── PlayerSource.cs
    │   │   ├── PlaylistBrowseResponse.cs
    │   │   ├── PlaylistNextResponse.cs
    │   │   ├── PlaylistVideoData.cs
    │   │   ├── SearchResponse.cs
    │   │   ├── ThumbnailData.cs
    │   │   ├── VideoWatchPage.cs
    │   │   └── Cipher/
    │   │       ├── CipherManifest.cs
    │   │       ├── ICipherOperation.cs
    │   │       ├── ReverseCipherOperation.cs
    │   │       ├── SpliceCipherOperation.cs
    │   │       └── SwapCipherOperation.cs
    │   ├── Channels/
    │   │   ├── Channel.cs
    │   │   ├── ChannelClient.cs
    │   │   ├── ChannelController.cs
    │   │   ├── ChannelHandle.cs
    │   │   ├── ChannelId.cs
    │   │   ├── ChannelSlug.cs
    │   │   ├── IChannel.cs
    │   │   └── UserName.cs
    │   ├── Common/
    │   │   ├── Author.cs
    │   │   ├── Batch.cs
    │   │   ├── IBatchItem.cs
    │   │   ├── Language.cs
    │   │   ├── Resolution.cs
    │   │   └── Thumbnail.cs
    │   ├── Exceptions/
    │   │   ├── PlaylistUnavailableException.cs
    │   │   ├── RequestLimitExceededException.cs
    │   │   ├── VideoRequiresPurchaseException.cs
    │   │   ├── VideoUnavailableException.cs
    │   │   ├── VideoUnplayableException.cs
    │   │   └── YoutubeExplodeException.cs
    │   ├── Playlists/
    │   │   ├── IPlaylist.cs
    │   │   ├── Playlist.cs
    │   │   ├── PlaylistClient.cs
    │   │   ├── PlaylistController.cs
    │   │   ├── PlaylistId.cs
    │   │   └── PlaylistVideo.cs
    │   ├── Search/
    │   │   ├── ChannelSearchResult.cs
    │   │   ├── ISearchResult.cs
    │   │   ├── PlaylistSearchResult.cs
    │   │   ├── SearchClient.cs
    │   │   ├── SearchController.cs
    │   │   ├── SearchFilter.cs
    │   │   └── VideoSearchResult.cs
    │   ├── Utils/
    │   │   ├── ClientDelegatingHandler.cs
    │   │   ├── Hash.cs
    │   │   ├── Html.cs
    │   │   ├── Http.cs
    │   │   ├── Json.cs
    │   │   ├── UrlEx.cs
    │   │   ├── Xml.cs
    │   │   └── Extensions/
    │   │       ├── AsyncCollectionExtensions.cs
    │   │       ├── BinaryExtensions.cs
    │   │       ├── CollectionExtensions.cs
    │   │       ├── GenericExtensions.cs
    │   │       ├── HttpExtensions.cs
    │   │       ├── JsonExtensions.cs
    │   │       ├── StreamExtensions.cs
    │   │       ├── StringExtensions.cs
    │   │       ├── UriExtensions.cs
    │   │       └── XElementExtensions.cs
    │   └── Videos/
    │       ├── Engagement.cs
    │       ├── IVideo.cs
    │       ├── Video.cs
    │       ├── VideoClient.cs
    │       ├── VideoController.cs
    │       ├── VideoId.cs
    │       ├── ClosedCaptions/
    │       │   ├── ClosedCaption.cs
    │       │   ├── ClosedCaptionClient.cs
    │       │   ├── ClosedCaptionController.cs
    │       │   ├── ClosedCaptionManifest.cs
    │       │   ├── ClosedCaptionPart.cs
    │       │   ├── ClosedCaptionTrack.cs
    │       │   └── ClosedCaptionTrackInfo.cs
    │       └── Streams/
    │           ├── AudioOnlyStreamInfo.cs
    │           ├── Bitrate.cs
    │           ├── Container.cs
    │           ├── FileSize.cs
    │           ├── IAudioStreamInfo.cs
    │           ├── IStreamInfo.cs
    │           ├── IVideoStreamInfo.cs
    │           ├── MediaStream.cs
    │           ├── MuxedStreamInfo.cs
    │           ├── StreamClient.cs
    │           ├── StreamController.cs
    │           ├── StreamManifest.cs
    │           ├── VideoOnlyStreamInfo.cs
    │           └── VideoQuality.cs
    ├── YoutubeExplode.Converter/
    │   ├── Readme.md
    │   ├── ConversionExtensions.cs
    │   ├── ConversionFormat.cs
    │   ├── ConversionPreset.cs
    │   ├── ConversionRequest.cs
    │   ├── ConversionRequestBuilder.cs
    │   ├── Converter.cs
    │   ├── FFmpeg.cs
    │   ├── YoutubeExplode.Converter.csproj
    │   └── Utils/
    │       ├── ProgressMuxer.cs
    │       └── Extensions/
    │           ├── AsyncCollectionExtensions.cs
    │           ├── GenericExtensions.cs
    │           ├── LanguageExtensions.cs
    │           └── StringExtensions.cs
    ├── YoutubeExplode.Converter.Tests/
    │   ├── GeneralSpecs.cs
    │   ├── SubtitleSpecs.cs
    │   ├── xunit.runner.json
    │   ├── YoutubeExplode.Converter.Tests.csproj
    │   └── Utils/
    │       ├── FFmpeg.cs
    │       ├── FileEx.cs
    │       ├── MediaFormat.cs
    │       ├── TempDir.cs
    │       ├── TempFile.cs
    │       └── Extensions/
    │           └── HttpExtensions.cs
    ├── YoutubeExplode.Demo.Cli/
    │   ├── Program.cs
    │   ├── YoutubeExplode.Demo.Cli.csproj
    │   └── Utils/
    │       └── ConsoleProgress.cs
    ├── YoutubeExplode.Demo.Gui/
    │   ├── App.axaml
    │   ├── App.axaml.cs
    │   ├── Program.cs
    │   ├── YoutubeExplode.Demo.Gui.csproj
    │   ├── Converters/
    │   │   ├── BoolToYesNoStringConverter.cs
    │   │   └── EnumerableToJoinedStringConverter.cs
    │   ├── Utils/
    │   │   ├── DelegateProgress.cs
    │   │   ├── PathEx.cs
    │   │   └── Extensions/
    │   │       └── AvaloniaExtensions.cs
    │   ├── ViewModels/
    │   │   └── MainViewModel.cs
    │   └── Views/
    │       ├── MainWindow.axaml
    │       └── MainWindow.axaml.cs
    ├── YoutubeExplode.Tests/
    │   ├── ChannelHandleSpecs.cs
    │   ├── ChannelIdSpecs.cs
    │   ├── ChannelSlugSpecs.cs
    │   ├── ChannelSpecs.cs
    │   ├── ClosedCaptionSpecs.cs
    │   ├── PlaylistIdSpecs.cs
    │   ├── PlaylistSpecs.cs
    │   ├── SearchSpecs.cs
    │   ├── StreamSpecs.cs
    │   ├── UserNameSpecs.cs
    │   ├── VideoIdSpecs.cs
    │   ├── VideoSpecs.cs
    │   ├── xunit.runner.json
    │   ├── YoutubeExplode.Tests.csproj
    │   ├── TestData/
    │   │   ├── ChannelHandles.cs
    │   │   ├── ChannelIds.cs
    │   │   ├── ChannelSlugs.cs
    │   │   ├── PlaylistIds.cs
    │   │   ├── UserNames.cs
    │   │   └── VideoIds.cs
    │   └── Utils/
    │       └── TempFile.cs
    └── .github/
        ├── dependabot.yml
        ├── ISSUE_TEMPLATE/
        │   ├── bug-report.yml
        │   └── config.yml
        └── workflows/
            └── main.yml

================================================
FILE: Readme.md
================================================
# YoutubeExplode

[![Status](https://img.shields.io/badge/status-maintenance-ffd700.svg)](https://github.com/Tyrrrz/.github/blob/master/docs/project-status.md)
[![Made in Ukraine](https://img.shields.io/badge/made_in-ukraine-ffd700.svg?labelColor=0057b7)](https://tyrrrz.me/ukraine)
[![Build](https://img.shields.io/github/actions/workflow/status/Tyrrrz/YoutubeExplode/main.yml?branch=master)](https://github.com/Tyrrrz/YoutubeExplode/actions)
[![Coverage](https://img.shields.io/codecov/c/github/Tyrrrz/YoutubeExplode/master)](https://codecov.io/gh/Tyrrrz/YoutubeExplode)
[![Version](https://img.shields.io/nuget/v/YoutubeExplode.svg)](https://nuget.org/packages/YoutubeExplode)
[![Downloads](https://img.shields.io/nuget/dt/YoutubeExplode.svg)](https://nuget.org/packages/YoutubeExplode)
[![Discord](https://img.shields.io/discord/869237470565392384?label=discord)](https://discord.gg/2SUWKFnHSm)
[![Fuck Russia](https://img.shields.io/badge/fuck-russia-e4181c.svg?labelColor=000000)](https://twitter.com/tyrrrz/status/1495972128977571848)

<table>
    <tr>
        <td width="99999" align="center">Development of this project is entirely funded by the community. <b><a href="https://tyrrrz.me/donate">Consider donating to support!</a></b></td>
    </tr>
</table>

<p align="center">
    <img src="favicon.png" alt="Icon" />
</p>

**YoutubeExplode** is a library that provides an interface to query metadata of YouTube videos, playlists and channels, as well as to resolve and download video streams and closed caption tracks.
Behind a layer of abstraction, this library works by scraping raw page data and exploiting reverse-engineered internal endpoints.

> 📝 Interested in the inner workings of this library?
> See the [Reverse-Engineering YouTube](https://tyrrrz.me/blog/reverse-engineering-youtube-revisited) article.

**Extension packages**:

- [YoutubeExplode.Converter](YoutubeExplode.Converter) — provides an interface to download and convert videos using FFmpeg

## Terms of use<sup>[[?]](https://github.com/Tyrrrz/.github/blob/master/docs/why-so-political.md)</sup>

By using this project or its source code, for any purpose and in any shape or form, you grant your **implicit agreement** to all the following statements:

- You **condemn Russia and its military aggression against Ukraine**
- You **recognize that Russia is an occupant that unlawfully invaded a sovereign state**
- You **support Ukraine's territorial integrity, including its claims over temporarily occupied territories of Crimea and Donbas**
- You **reject false narratives perpetuated by Russian state propaganda**

To learn more about the war and how you can help, [click here](https://tyrrrz.me/ukraine). Glory to Ukraine! 🇺🇦

## Install

- 📦 [NuGet](https://nuget.org/packages/YoutubeExplode): `dotnet add package YoutubeExplode`

## Screenshots

![demo](.assets/demo.png)

## Usage

**YoutubeExplode** exposes its functionality through a single entry point — the `YoutubeClient` class.
Create an instance of this class and use the provided operations on `Videos`, `Playlists`, `Channels`, and `Search` properties to send requests.

### Videos

#### Retrieving video metadata

To retrieve the metadata associated with a YouTube video, call `Videos.GetAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

// You can specify either the video URL or its ID
var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";
var video = await youtube.Videos.GetAsync(videoUrl);

var title = video.Title; // "Collections - Blender 2.80 Fundamentals"
var author = video.Author.ChannelTitle; // "Blender"
var duration = video.Duration; // 00:07:20
```

#### Downloading video streams

Every YouTube video has a number of streams available, differing in containers, video quality, bitrate, framerate, and other parameters.
Additionally, the streams are further divided into 3 categories based on their content:

- ~~Muxed streams — contain both video and audio~~ (no longer provided by YouTube)
- Audio-only streams — contain only audio
- Video-only streams — contain only video

> **Warning**:
> Muxed streams contain both audio and video, but these streams are limited in quality (up to 720p30).
> To download the video in the highest available quality, you will need to resolve the best audio-only and video-only streams separately and then mux them together.
> The muxing process can be performed using FFmpeg with the help of the [**YoutubeExplode.Converter**](YoutubeExplode.Converter) package.

> **Warning**:
> Muxed streams are deprecated by YouTube and are not guaranteed to be available for every video.
> If possible, avoid relying on them too much and instead perform muxing manually using the provided audio-only and video-only streams.

You can request the manifest that lists all available streams for a particular video by calling `Videos.Streams.GetManifestAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";
var streamManifest = await youtube.Videos.Streams.GetManifestAsync(videoUrl);
```

Once the manifest is obtained, you can filter through the streams and identify the ones you're interested in:

```csharp
using YoutubeExplode;
using YoutubeExplode.Videos.Streams;

// ...

// Get the highest bitrate audio-only stream
var streamInfo = streamManifest.GetAudioOnlyStreams().GetWithHighestBitrate();

// ...or the highest quality MP4 video-only stream
var streamInfo = streamManifest
    .GetVideoOnlyStreams()
    .Where(s => s.Container == Container.Mp4)
    .GetWithHighestVideoQuality()
```

Finally, you can resolve the actual stream represented by the specified metadata using `Videos.Streams.GetAsync(...)` or download it directly to a file with `Videos.Streams.DownloadAsync(...)`:

```csharp
// ...

// Get the actual stream
var stream = await youtube.Videos.Streams.GetAsync(streamInfo);

// Download the stream to a file
await youtube.Videos.Streams.DownloadAsync(streamInfo, $"video.{streamInfo.Container}");
```

> **Warning**:
> While the `Url` property in the stream metadata can be used to access the underlying content, you need a series of carefully crafted HTTP requests in order to do so.
> It's highly recommended to use `Videos.Streams.GetAsync(...)` or `Videos.Streams.DownloadAsync(...)` instead, as they will perform all the heavy lifting for you.

#### Downloading closed captions

Closed captions can be downloaded in a similar way to media streams.
To get the list of available closed caption tracks, call `Videos.ClosedCaptions.GetManifestAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";
var trackManifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(videoUrl);
```

Then retrieve the metadata for a particular track:

```csharp
// ...

// Find closed caption track in English
var trackInfo = trackManifest.GetByLanguage("en");
```

Finally, use `Videos.ClosedCaptions.GetAsync(...)` to get the actual content of the track:

```csharp
// ...

var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

// Get the caption displayed at 0:35
var caption = track.GetByTime(TimeSpan.FromSeconds(35));
var text = caption.Text; // "collection acts as the parent collection"
```

You can also download the closed caption track in the SRT file format with `Videos.ClosedCaptions.DownloadAsync(...)`:

```csharp
// ...

await youtube.Videos.ClosedCaptions.DownloadAsync(trackInfo, "cc_track.srt");
```

### Playlists

#### Retrieving playlist metadata

You can get the metadata associated with a YouTube playlist by calling the `Playlists.GetAsync(...)` method:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var playlistUrl = "https://youtube.com/playlist?list=PLa1F2ddGya_-UvuAqHAksYnB0qL9yWDO6";
var playlist = await youtube.Playlists.GetAsync(playlistUrl);

var title = playlist.Title; // "First Steps - Blender 2.80 Fundamentals"
var author = playlist.Author.ChannelTitle; // "Blender"
```

#### Retrieving videos included in a playlist

To get the videos included in a playlist, call `Playlists.GetVideosAsync(...)`:

```csharp
using YoutubeExplode;
using YoutubeExplode.Common;

var youtube = new YoutubeClient();
var playlistUrl = "https://youtube.com/playlist?list=PLa1F2ddGya_-UvuAqHAksYnB0qL9yWDO6";

// Get all playlist videos
var videos = await youtube.Playlists.GetVideosAsync(playlistUrl);

// Get only the first 20 playlist videos
var videosSubset = await youtube.Playlists.GetVideosAsync(playlistUrl).CollectAsync(20);
```

You can also enumerate the videos iteratively without waiting for the whole list to load:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();
var playlistUrl = "https://youtube.com/playlist?list=PLa1F2ddGya_-UvuAqHAksYnB0qL9yWDO6";

await foreach (var video in youtube.Playlists.GetVideosAsync(playlistUrl))
{
    var title = video.Title;
    var author = video.Author;
}
```

If you need precise control over how many requests you send to YouTube, use `Playlists.GetVideoBatchesAsync(...)` which returns videos wrapped in batches:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();
var playlistUrl = "https://youtube.com/playlist?list=PLa1F2ddGya_-UvuAqHAksYnB0qL9yWDO6";

// Each batch corresponds to one request
await foreach (var batch in youtube.Playlists.GetVideoBatchesAsync(playlistUrl))
{
    foreach (var video in batch.Items)
    {
        var title = video.Title;
        var author = video.Author;
    }
}
```

> **Note**:
> You can craft playlist IDs to fetch special auto-generated playlists, such as music mixes, popular channel uploads, liked videos, and more.
> See [this reference](https://wiki.archiveteam.org/index.php/YouTube/Technical_details#Playlists) for more information.

### Channels

#### Retrieving channel metadata

You can get the metadata associated with a YouTube channel by calling the `Channels.GetAsync(...)` method:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var channelUrl = "https://youtube.com/channel/UCSMOQeBJ2RAnuFungnQOxLg";
var channel = await youtube.Channels.GetAsync(channelUrl);

var title = channel.Title; // "Blender"
```

You can also get the channel metadata by username or profile URL with `Channels.GetByUserAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var channelUrl = "https://youtube.com/user/BlenderFoundation";
var channel = await youtube.Channels.GetByUserAsync(channelUrl);

var id = channel.Id; // "UCSMOQeBJ2RAnuFungnQOxLg"
```

To get the channel metadata by slug or legacy custom URL, use `Channels.GetBySlugAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var channelUrl = "https://youtube.com/c/BlenderFoundation";
var channel = await youtube.Channels.GetBySlugAsync(channelUrl);

var id = channel.Id; // "UCSMOQeBJ2RAnuFungnQOxLg"
```

To get the channel metadata by handle or custom URL, use `Channels.GetByHandleAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

var channelUrl = "https://youtube.com/@BlenderOfficial";
var channel = await youtube.Channels.GetByHandleAsync(channelUrl);

var id = channel.Id; // "UCSMOQeBJ2RAnuFungnQOxLg"
```

#### Retrieving channel uploads

To get the list of videos uploaded by a channel, call `Channels.GetUploadsAsync(...)`:

```csharp
using YoutubeExplode;
using YoutubeExplode.Common;

var youtube = new YoutubeClient();
var channelUrl = "https://youtube.com/channel/UCSMOQeBJ2RAnuFungnQOxLg";

var videos = await youtube.Channels.GetUploadsAsync(channelUrl);
```

### Search

You can execute a search query by calling the `Search.GetResultsAsync(...)` method.
Each search result may represent either a video, a playlist, or a channel, so you need to apply pattern matching to handle the corresponding cases:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

await foreach (var result in youtube.Search.GetResultsAsync("blender tutorials"))
{
    // Use pattern matching to handle different results (videos, playlists, channels)
    switch (result)
    {
        case VideoSearchResult video:
        {
            var id = video.Id;
            var title = video.Title;
            var duration = video.Duration;
            break;
        }
        case PlaylistSearchResult playlist:
        {
            var id = playlist.Id;
            var title = playlist.Title;
            break;
        }
        case ChannelSearchResult channel:
        {
            var id = channel.Id;
            var title = channel.Title;
            break;
        }
    }
}
```

To limit the results to a specific type, use `Search.GetVideosAsync(...)`, `Search.GetPlaylistsAsync(...)`, or `Search.GetChannelsAsync(...)`:

```csharp
using YoutubeExplode;
using YoutubeExplode.Common;

var youtube = new YoutubeClient();

var videos = await youtube.Search.GetVideosAsync("blender tutorials");
var playlists = await youtube.Search.GetPlaylistsAsync("blender tutorials");
var channels = await youtube.Search.GetChannelsAsync("blender tutorials");
```

Similarly to playlists, you can also enumerate results in batches by calling `Search.GetResultBatchesAsync(...)`:

```csharp
using YoutubeExplode;

var youtube = new YoutubeClient();

// Each batch corresponds to one request
await foreach (var batch in youtube.Search.GetResultBatchesAsync("blender tutorials"))
{
    foreach (var result in batch.Items)
    {
        switch (result)
        {
            case VideoSearchResult videoResult:
            {
                // ...
            }
            case PlaylistSearchResult playlistResult:
            {
                // ...
            }
            case ChannelSearchResult channelResult:
            {
                // ...
            }
        }
    }
}
```

### Authentication

You can access private videos and playlists by providing cookies that correspond to a pre-authenticated YouTube account.
To do that, create an instance of `YoutubeClient` using a constructor that accepts `IReadOnlyList<Cookie>`:

```csharp
using YoutubeExplode;

// Perform authentication and extract cookies
var cookies = ...;

// Cookie collection must be of type IReadOnlyList<System.Net.Cookie>
var youtube = new YoutubeClient(cookies);
```

In order to actually perform the authentication, you can use an embedded browser such as [WebView](https://nuget.org/packages/Microsoft.Web.WebView2) to navigate the user to the [YouTube login page](https://accounts.google.com/ServiceLogin?continue=https%3A%2F%2Fwww.youtube.com), let them log in, and then extract the cookies from the browser.

## Etymology

The "Explode" in **YoutubeExplode** comes from the name of a PHP function that splits up strings, [`explode(...)`](https://php.net/manual/en/function.explode.php). When I was starting the development of this library, most of the reference source code I read was written in PHP, hence the inspiration for the name.



================================================
FILE: Directory.Build.props
================================================
<Project>

  <PropertyGroup>
    <Version>0.0.0-dev</Version>
    <Company>Tyrrrz</Company>
    <Copyright>Copyright (C) Oleksii Holub</Copyright>
    <LangVersion>preview</LangVersion>
    <Nullable>enable</Nullable>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <CheckEolTargetFramework>false</CheckEolTargetFramework>
    <SuppressTfmSupportBuildWarnings>true</SuppressTfmSupportBuildWarnings>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <!-- Disable nullability warnings on frameworks where BCL is not annotated -->
  <PropertyGroup Condition="!$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netstandard2.1'))">
    <Nullable>annotations</Nullable>
  </PropertyGroup>

  <PropertyGroup>
    <Authors>$(Company)</Authors>
    <Description>Abstraction layer over YouTube's internal API. Note: this package has limited availability in Russia and Belarus.</Description>
    <PackageTags>youtube video download playlist user channel closed caption tracks subtitles parse extract metadata info net core standard</PackageTags>
    <PackageProjectUrl>https://github.com/Tyrrrz/YoutubeExplode</PackageProjectUrl>
    <PackageReleaseNotes>https://github.com/Tyrrrz/YoutubeExplode/releases</PackageReleaseNotes>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
  </PropertyGroup>

</Project>


================================================
FILE: License.txt
================================================
MIT License

Copyright (c) 2016-2025 Oleksii Holub

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: NuGet.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
  </packageSources>
  <config>
    <add key="defaultPushSource" value="https://api.nuget.org/v3/index.json" />
  </config>
</configuration>



================================================
FILE: YoutubeExplode.sln
================================================
﻿Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28803.352
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Misc", "Misc", "{2D3632A9-3DE4-4E64-AC3E-94810F2F55D0}"
	ProjectSection(SolutionItems) = preProject
		License.txt = License.txt
		Readme.md = Readme.md
		Directory.Build.props = Directory.Build.props
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "YoutubeExplode.Demo.Cli", "YoutubeExplode.Demo.Cli\YoutubeExplode.Demo.Cli.csproj", "{6983B0A4-44B0-4FAF-81C7-94CC784570F0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "YoutubeExplode.Tests", "YoutubeExplode.Tests\YoutubeExplode.Tests.csproj", "{5E5CDC04-EA05-46CC-8D72-970F0F0E2CD1}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "YoutubeExplode", "YoutubeExplode\YoutubeExplode.csproj", "{2019E360-0E05-4824-9EDE-7723AF45E10C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "YoutubeExplode.Demo.Gui", "YoutubeExplode.Demo.Gui\YoutubeExplode.Demo.Gui.csproj", "{21F838B4-11B6-4C54-957A-9B7EFDE8F19E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "YoutubeExplode.Converter", "YoutubeExplode.Converter\YoutubeExplode.Converter.csproj", "{CF1CA267-32A2-4E91-8207-8FA9C697BC8B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "YoutubeExplode.Converter.Tests", "YoutubeExplode.Converter.Tests\YoutubeExplode.Converter.Tests.csproj", "{DF44A908-CC76-406C-AA7B-9E9C03FE97D2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6983B0A4-44B0-4FAF-81C7-94CC784570F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6983B0A4-44B0-4FAF-81C7-94CC784570F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6983B0A4-44B0-4FAF-81C7-94CC784570F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6983B0A4-44B0-4FAF-81C7-94CC784570F0}.Release|Any CPU.Build.0 = Release|Any CPU
		{5E5CDC04-EA05-46CC-8D72-970F0F0E2CD1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5E5CDC04-EA05-46CC-8D72-970F0F0E2CD1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5E5CDC04-EA05-46CC-8D72-970F0F0E2CD1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5E5CDC04-EA05-46CC-8D72-970F0F0E2CD1}.Release|Any CPU.Build.0 = Release|Any CPU
		{2019E360-0E05-4824-9EDE-7723AF45E10C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2019E360-0E05-4824-9EDE-7723AF45E10C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2019E360-0E05-4824-9EDE-7723AF45E10C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2019E360-0E05-4824-9EDE-7723AF45E10C}.Release|Any CPU.Build.0 = Release|Any CPU
		{21F838B4-11B6-4C54-957A-9B7EFDE8F19E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{21F838B4-11B6-4C54-957A-9B7EFDE8F19E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{21F838B4-11B6-4C54-957A-9B7EFDE8F19E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{21F838B4-11B6-4C54-957A-9B7EFDE8F19E}.Release|Any CPU.Build.0 = Release|Any CPU
		{CF1CA267-32A2-4E91-8207-8FA9C697BC8B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CF1CA267-32A2-4E91-8207-8FA9C697BC8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CF1CA267-32A2-4E91-8207-8FA9C697BC8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CF1CA267-32A2-4E91-8207-8FA9C697BC8B}.Release|Any CPU.Build.0 = Release|Any CPU
		{DF44A908-CC76-406C-AA7B-9E9C03FE97D2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DF44A908-CC76-406C-AA7B-9E9C03FE97D2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DF44A908-CC76-406C-AA7B-9E9C03FE97D2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DF44A908-CC76-406C-AA7B-9E9C03FE97D2}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DEA5BDC6-C56D-4AC1-A8C6-2C64A5A75FDD}
	EndGlobalSection
EndGlobal



================================================
FILE: YoutubeExplode/FodyWeavers.xml
================================================
﻿<Weavers
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="FodyWeavers.xsd"
>
  <Lazy />
</Weavers>



================================================
FILE: YoutubeExplode/FodyWeavers.xsd
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Lazy" minOccurs="0" maxOccurs="1" type="xs:anyType" />
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>


================================================
FILE: YoutubeExplode/YoutubeClient.cs
================================================
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using YoutubeExplode.Channels;
using YoutubeExplode.Playlists;
using YoutubeExplode.Search;
using YoutubeExplode.Utils;
using YoutubeExplode.Videos;

namespace YoutubeExplode;

/// <summary>
/// Client for interacting with YouTube.
/// </summary>
public class YoutubeClient
{
    /// <summary>
    /// Initializes an instance of <see cref="YoutubeClient" />.
    /// </summary>
    public YoutubeClient(HttpClient http, IReadOnlyList<Cookie> initialCookies)
    {
        var youtubeHttp = new HttpClient(new YoutubeHttpHandler(http, initialCookies), true);

        Videos = new VideoClient(youtubeHttp);
        Playlists = new PlaylistClient(youtubeHttp);
        Channels = new ChannelClient(youtubeHttp);
        Search = new SearchClient(youtubeHttp);
    }

    /// <summary>
    /// Initializes an instance of <see cref="YoutubeClient" />.
    /// </summary>
    public YoutubeClient(HttpClient http)
        : this(http, []) { }

    /// <summary>
    /// Initializes an instance of <see cref="YoutubeClient" />.
    /// </summary>
    public YoutubeClient(IReadOnlyList<Cookie> initialCookies)
        : this(Http.Client, initialCookies) { }

    /// <summary>
    /// Initializes an instance of <see cref="YoutubeClient" />.
    /// </summary>
    public YoutubeClient()
        : this(Http.Client) { }

    /// <summary>
    /// Operations related to YouTube videos.
    /// </summary>
    public VideoClient Videos { get; }

    /// <summary>
    /// Operations related to YouTube playlists.
    /// </summary>
    public PlaylistClient Playlists { get; }

    /// <summary>
    /// Operations related to YouTube channels.
    /// </summary>
    public ChannelClient Channels { get; }

    /// <summary>
    /// Operations related to YouTube search.
    /// </summary>
    public SearchClient Search { get; }
}



================================================
FILE: YoutubeExplode/YoutubeExplode.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net9.0</TargetFrameworks>
    <IsPackable>true</IsPackable>
    <IsTrimmable
      Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net6.0'))"
      >true</IsTrimmable
    >
    <IsAotCompatible
      Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net7.0'))"
      >true</IsAotCompatible
    >
  </PropertyGroup>
  <PropertyGroup>
    <PackageIcon>favicon.png</PackageIcon>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>
  <ItemGroup>
    <None Include="../favicon.png" Pack="true" PackagePath="" Visible="false" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="AngleSharp" Version="1.3.0" />
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
    <PackageReference Include="Deorcify" Version="1.1.0" PrivateAssets="all" />
    <PackageReference Include="Lazy.Fody" Version="1.11.0" PrivateAssets="all" />
    <PackageReference
      Include="Microsoft.Bcl.AsyncInterfaces"
      Version="9.0.1"
      Condition="!$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netstandard2.1'))"
    />
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0" PrivateAssets="all" />
    <PackageReference Include="PolyShim" Version="1.15.0" PrivateAssets="all" />
    <PackageReference
      Include="System.Text.Json"
      Version="9.0.1"
      Condition="!$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp3.0'))"
    />
    <PackageReference
      Include="System.Threading.Tasks.Extensions"
      Version="4.6.0"
      Condition="!$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netstandard2.1'))"
    />
  </ItemGroup>
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
    <Reference Include="System.Net.Http" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode/YoutubeHttpHandler.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode;

internal class YoutubeHttpHandler : ClientDelegatingHandler
{
    private readonly CookieContainer _cookieContainer = new();

    public YoutubeHttpHandler(
        HttpClient http,
        IReadOnlyList<Cookie> initialCookies,
        bool disposeClient = false
    )
        : base(http, disposeClient)
    {
        // Pre-fill cookies
        foreach (var cookie in initialCookies)
            _cookieContainer.Add(cookie);

        // Consent to the use of cookies on YouTube.
        // This is required to access some personalized content, such as mix playlists.
        // https://github.com/Tyrrrz/YoutubeExplode/issues/730
        // https://github.com/Tyrrrz/YoutubeExplode/issues/732
        _cookieContainer.Add(
            new Cookie("SOCS", "CAISEwgDEgk2NzM5OTg2ODUaAmVuIAEaBgiA6p23Bg")
            {
                Domain = "youtube.com",
            }
        );
    }

    private string? TryGenerateAuthHeaderValue(Uri uri)
    {
        var cookies = _cookieContainer.GetCookies(uri).Cast<Cookie>().ToArray();

        var sessionId =
            cookies
                .FirstOrDefault(c =>
                    string.Equals(c.Name, "__Secure-3PAPISID", StringComparison.Ordinal)
                )
                ?.Value
            ?? cookies
                .FirstOrDefault(c => string.Equals(c.Name, "SAPISID", StringComparison.Ordinal))
                ?.Value;

        if (string.IsNullOrWhiteSpace(sessionId))
            return null;

        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        var domain = uri.GetDomain();

        var token = $"{timestamp} {sessionId} {domain}";
        var tokenHash = Hash.Compute(SHA1.Create(), Encoding.UTF8.GetBytes(token)).ToHex();

        return $"SAPISIDHASH {timestamp}_{tokenHash}";
    }

    private HttpRequestMessage HandleRequest(HttpRequestMessage request)
    {
        // Shouldn't happen?
        if (request.RequestUri is null)
            return request;

        // Set internal API key
        if (
            request.RequestUri.AbsolutePath.StartsWith("/youtubei/", StringComparison.Ordinal)
            && !UrlEx.ContainsQueryParameter(request.RequestUri.Query, "key")
        )
        {
            request.RequestUri = new Uri(
                UrlEx.SetQueryParameter(
                    request.RequestUri.OriginalString,
                    "key",
                    // This key doesn't appear to change
                    "AIzaSyA8eiZmM1FaDVjRy-df2KTyQ_vz_yYM39w"
                )
            );
        }

        // Set localization language
        if (!UrlEx.ContainsQueryParameter(request.RequestUri.Query, "hl"))
        {
            request.RequestUri = new Uri(
                UrlEx.SetQueryParameter(request.RequestUri.OriginalString, "hl", "en")
            );
        }

        // Set origin
        if (!request.Headers.Contains("Origin"))
        {
            request.Headers.Add("Origin", request.RequestUri.GetDomain());
        }

        // Set user agent
        if (!request.Headers.Contains("User-Agent"))
        {
            request.Headers.Add(
                "User-Agent",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36"
            );
        }

        // Set cookies
        if (!request.Headers.Contains("Cookie") && _cookieContainer.Count > 0)
        {
            var cookieHeaderValue = _cookieContainer.GetCookieHeader(request.RequestUri);
            if (!string.IsNullOrWhiteSpace(cookieHeaderValue))
                request.Headers.Add("Cookie", cookieHeaderValue);
        }

        // Set authorization
        if (
            !request.Headers.Contains("Authorization")
            && TryGenerateAuthHeaderValue(request.RequestUri) is { } authHeaderValue
        )
        {
            request.Headers.Add("Authorization", authHeaderValue);
        }

        return request;
    }

    private HttpResponseMessage HandleResponse(HttpResponseMessage response)
    {
        if (response.RequestMessage?.RequestUri is null)
            return response;

        // Custom exception for rate limit errors
        if ((int)response.StatusCode == 429)
        {
            throw new RequestLimitExceededException(
                "Exceeded request rate limit. "
                    + "Please try again in a few hours. "
                    + "Alternatively, inject cookies corresponding to a pre-authenticated user when initializing an instance of `YoutubeClient`."
            );
        }

        // Set cookies
        if (response.Headers.TryGetValues("Set-Cookie", out var cookieHeaderValues))
        {
            foreach (var cookieHeaderValue in cookieHeaderValues)
            {
                try
                {
                    _cookieContainer.SetCookies(
                        response.RequestMessage.RequestUri,
                        cookieHeaderValue
                    );
                }
                catch (CookieException)
                {
                    // YouTube may send cookies for other domains, ignore them
                    // https://github.com/Tyrrrz/YoutubeExplode/issues/762
                }
            }
        }

        return response;
    }

    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken
    )
    {
        for (var retriesRemaining = 5; ; retriesRemaining--)
        {
            var response = HandleResponse(
                await base.SendAsync(
                    // Request will be cloned by the base handler
                    HandleRequest(request),
                    cancellationToken
                )
            );

            // Retry on 5XX errors
            if ((int)response.StatusCode >= 500 && retriesRemaining > 0)
            {
                response.Dispose();
                continue;
            }

            return response;
        }
    }
}



================================================
FILE: YoutubeExplode/Bridge/ChannelPage.cs
================================================
using System;
using AngleSharp.Html.Dom;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class ChannelPage(IHtmlDocument content)
{
    [Lazy]
    public string? Url =>
        content.QuerySelector("meta[property=\"og:url\"]")?.GetAttribute("content");

    [Lazy]
    public string? Id => Url?.SubstringAfter("channel/", StringComparison.OrdinalIgnoreCase);

    [Lazy]
    public string? Title =>
        content.QuerySelector("meta[property=\"og:title\"]")?.GetAttribute("content");

    [Lazy]
    public string? LogoUrl =>
        content.QuerySelector("meta[property=\"og:image\"]")?.GetAttribute("content");
}

internal partial class ChannelPage
{
    public static ChannelPage? TryParse(string raw)
    {
        var content = Html.Parse(raw);

        if (content.QuerySelector("meta[property=\"og:url\"]") is null)
            return null;

        return new ChannelPage(content);
    }
}



================================================
FILE: YoutubeExplode/Bridge/ClosedCaptionTrackResponse.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class ClosedCaptionTrackResponse(XElement content)
{
    [Lazy]
    public IReadOnlyList<CaptionData> Captions =>
        content.Descendants("p").Select(x => new CaptionData(x)).ToArray();
}

internal partial class ClosedCaptionTrackResponse
{
    public class CaptionData(XElement content)
    {
        [Lazy]
        public string? Text => (string?)content;

        [Lazy]
        public TimeSpan? Offset =>
            ((double?)content.Attribute("t"))?.Pipe(TimeSpan.FromMilliseconds);

        [Lazy]
        public TimeSpan? Duration =>
            ((double?)content.Attribute("d"))?.Pipe(TimeSpan.FromMilliseconds);

        [Lazy]
        public IReadOnlyList<PartData> Parts =>
            content.Elements("s").Select(x => new PartData(x)).ToArray();
    }
}

internal partial class ClosedCaptionTrackResponse
{
    public class PartData(XElement content)
    {
        [Lazy]
        public string? Text => (string?)content;

        [Lazy]
        public TimeSpan? Offset =>
            ((double?)content.Attribute("t"))?.Pipe(TimeSpan.FromMilliseconds)
            ?? ((double?)content.Attribute("ac"))?.Pipe(TimeSpan.FromMilliseconds)
            ?? TimeSpan.Zero;
    }
}

internal partial class ClosedCaptionTrackResponse
{
    public static ClosedCaptionTrackResponse Parse(string raw) => new(Xml.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/DashManifest.cs
================================================
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class DashManifest(XElement content)
{
    [Lazy]
    public IReadOnlyList<IStreamData> Streams =>
        content
            .Descendants("Representation")
            // Skip non-media representations (like "rawcc")
            // https://github.com/Tyrrrz/YoutubeExplode/issues/546
            .Where(x => x.Attribute("id")?.Value.All(char.IsDigit) == true)
            // Skip segmented streams
            // https://github.com/Tyrrrz/YoutubeExplode/issues/159
            .Where(x =>
                x.Descendants("Initialization")
                    .FirstOrDefault()
                    ?.Attribute("sourceURL")
                    ?.Value.Contains("sq/") != true
            )
            // Skip streams without codecs
            .Where(x => !string.IsNullOrWhiteSpace(x.Attribute("codecs")?.Value))
            .Select(x => new StreamData(x))
            .ToArray();
}

internal partial class DashManifest
{
    public class StreamData(XElement content) : IStreamData
    {
        [Lazy]
        public int? Itag => (int?)content.Attribute("id");

        [Lazy]
        public string? Url => (string?)content.Element("BaseURL");

        // DASH streams don't have signatures
        public string? Signature => null;

        // DASH streams don't have signatures
        public string? SignatureParameter => null;

        [Lazy]
        public long? ContentLength =>
            (long?)content.Attribute("contentLength")
            ?? Url?.Pipe(s => Regex.Match(s, @"[/\?]clen[/=](\d+)").Groups[1].Value)
                .NullIfWhiteSpace()
                ?.ParseLongOrNull();

        [Lazy]
        public long? Bitrate => (long?)content.Attribute("bandwidth");

        [Lazy]
        public string? Container =>
            Url
                ?.Pipe(s => Regex.Match(s, @"mime[/=]\w*%2F([\w\d]*)").Groups[1].Value)
                .Pipe(WebUtility.UrlDecode);

        [Lazy]
        private bool IsAudioOnly => content.Element("AudioChannelConfiguration") is not null;

        [Lazy]
        public string? AudioCodec => IsAudioOnly ? (string?)content.Attribute("codecs") : null;

        public string? AudioLanguageCode => null;

        public string? AudioLanguageName => null;

        public bool? IsAudioLanguageDefault => null;

        [Lazy]
        public string? VideoCodec => IsAudioOnly ? null : (string?)content.Attribute("codecs");

        public string? VideoQualityLabel => null;

        [Lazy]
        public int? VideoWidth => (int?)content.Attribute("width");

        [Lazy]
        public int? VideoHeight => (int?)content.Attribute("height");

        [Lazy]
        public int? VideoFramerate => (int?)content.Attribute("frameRate");
    }
}

internal partial class DashManifest
{
    public static DashManifest Parse(string raw) => new(Xml.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/IPlaylistData.cs
================================================
﻿using System.Collections.Generic;

namespace YoutubeExplode.Bridge;

internal interface IPlaylistData
{
    string? Title { get; }

    string? Author { get; }

    string? ChannelId { get; }

    string? Description { get; }

    int? Count { get; }

    IReadOnlyList<ThumbnailData> Thumbnails { get; }
}



================================================
FILE: YoutubeExplode/Bridge/IStreamData.cs
================================================
namespace YoutubeExplode.Bridge;

internal interface IStreamData
{
    int? Itag { get; }

    string? Url { get; }

    string? Signature { get; }

    string? SignatureParameter { get; }

    long? ContentLength { get; }

    long? Bitrate { get; }

    string? Container { get; }

    string? AudioCodec { get; }

    string? AudioLanguageCode { get; }

    string? AudioLanguageName { get; }

    bool? IsAudioLanguageDefault { get; }

    string? VideoCodec { get; }

    string? VideoQualityLabel { get; }

    int? VideoWidth { get; }

    int? VideoHeight { get; }

    int? VideoFramerate { get; }
}



================================================
FILE: YoutubeExplode/Bridge/PlayerResponse.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class PlayerResponse(JsonElement content)
{
    [Lazy]
    private JsonElement? Playability => content.GetPropertyOrNull("playabilityStatus");

    [Lazy]
    private string? PlayabilityStatus =>
        Playability?.GetPropertyOrNull("status")?.GetStringOrNull();

    [Lazy]
    public string? PlayabilityError => Playability?.GetPropertyOrNull("reason")?.GetStringOrNull();

    [Lazy]
    public bool IsAvailable =>
        !string.Equals(PlayabilityStatus, "error", StringComparison.OrdinalIgnoreCase)
        && Details is not null;

    [Lazy]
    public bool IsPlayable =>
        string.Equals(PlayabilityStatus, "ok", StringComparison.OrdinalIgnoreCase);

    [Lazy]
    private JsonElement? Details => content.GetPropertyOrNull("videoDetails");

    [Lazy]
    public string? Title => Details?.GetPropertyOrNull("title")?.GetStringOrNull();

    [Lazy]
    public string? ChannelId => Details?.GetPropertyOrNull("channelId")?.GetStringOrNull();

    [Lazy]
    public string? Author => Details?.GetPropertyOrNull("author")?.GetStringOrNull();

    [Lazy]
    public DateTimeOffset? UploadDate =>
        content
            .GetPropertyOrNull("microformat")
            ?.GetPropertyOrNull("playerMicroformatRenderer")
            ?.GetPropertyOrNull("uploadDate")
            ?.GetDateTimeOffset();

    [Lazy]
    public TimeSpan? Duration =>
        Details
            ?.GetPropertyOrNull("lengthSeconds")
            ?.GetStringOrNull()
            ?.ParseDoubleOrNull()
            ?.Pipe(TimeSpan.FromSeconds);

    [Lazy]
    public IReadOnlyList<ThumbnailData> Thumbnails =>
        Details
            ?.GetPropertyOrNull("thumbnail")
            ?.GetPropertyOrNull("thumbnails")
            ?.EnumerateArrayOrNull()
            ?.Select(j => new ThumbnailData(j))
            .ToArray() ?? [];

    public IReadOnlyList<string> Keywords =>
        Details
            ?.GetPropertyOrNull("keywords")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetStringOrNull())
            .WhereNotNull()
            .ToArray() ?? [];

    [Lazy]
    public string? Description => Details?.GetPropertyOrNull("shortDescription")?.GetStringOrNull();

    [Lazy]
    public long? ViewCount =>
        Details?.GetPropertyOrNull("viewCount")?.GetStringOrNull()?.ParseLongOrNull();

    [Lazy]
    public string? PreviewVideoId =>
        Playability
            ?.GetPropertyOrNull("errorScreen")
            ?.GetPropertyOrNull("playerLegacyDesktopYpcTrailerRenderer")
            ?.GetPropertyOrNull("trailerVideoId")
            ?.GetStringOrNull()
        ?? Playability
            ?.GetPropertyOrNull("errorScreen")
            ?.GetPropertyOrNull("ypcTrailerRenderer")
            ?.GetPropertyOrNull("playerVars")
            ?.GetStringOrNull()
            ?.Pipe(UrlEx.GetQueryParameters)
            .GetValueOrDefault("video_id")
        ?? Playability
            ?.GetPropertyOrNull("errorScreen")
            ?.GetPropertyOrNull("ypcTrailerRenderer")
            ?.GetPropertyOrNull("playerResponse")
            ?.GetStringOrNull()
            ?
            // YouTube uses weird base64-like encoding here that I don't know how to deal with.
            // It's supposed to have JSON inside, but if extracted as is, it contains garbage.
            // Luckily, some of the text gets decoded correctly, which is enough for us to
            // extract the preview video ID using regex.
            .Replace('-', '+')
            .Replace('_', '/')
            .Pipe(Convert.FromBase64String)
            .Pipe(Encoding.UTF8.GetString)
            .Pipe(s => Regex.Match(s, @"video_id=(.{11})").Groups[1].Value)
            .NullIfWhiteSpace();

    [Lazy]
    private JsonElement? StreamingData => content.GetPropertyOrNull("streamingData");

    [Lazy]
    public string? DashManifestUrl =>
        StreamingData?.GetPropertyOrNull("dashManifestUrl")?.GetStringOrNull();

    [Lazy]
    public string? HlsManifestUrl =>
        StreamingData?.GetPropertyOrNull("hlsManifestUrl")?.GetStringOrNull();

    [Lazy]
    public IReadOnlyList<IStreamData> Streams
    {
        get
        {
            var result = new List<IStreamData>();

            var muxedStreams = StreamingData
                ?.GetPropertyOrNull("formats")
                ?.EnumerateArrayOrNull()
                ?.Select(j => new StreamData(j));

            if (muxedStreams is not null)
                result.AddRange(muxedStreams);

            var adaptiveStreams = StreamingData
                ?.GetPropertyOrNull("adaptiveFormats")
                ?.EnumerateArrayOrNull()
                ?.Select(j => new StreamData(j));

            if (adaptiveStreams is not null)
                result.AddRange(adaptiveStreams);

            return result;
        }
    }

    [Lazy]
    public IReadOnlyList<ClosedCaptionTrackData> ClosedCaptionTracks =>
        content
            .GetPropertyOrNull("captions")
            ?.GetPropertyOrNull("playerCaptionsTracklistRenderer")
            ?.GetPropertyOrNull("captionTracks")
            ?.EnumerateArrayOrNull()
            ?.Select(j => new ClosedCaptionTrackData(j))
            .ToArray() ?? [];
}

internal partial class PlayerResponse
{
    public class ClosedCaptionTrackData(JsonElement content)
    {
        [Lazy]
        public string? Url => content.GetPropertyOrNull("baseUrl")?.GetStringOrNull();

        [Lazy]
        public string? LanguageCode => content.GetPropertyOrNull("languageCode")?.GetStringOrNull();

        [Lazy]
        public string? LanguageName =>
            content.GetPropertyOrNull("name")?.GetPropertyOrNull("simpleText")?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("name")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
                .WhereNotNull()
                .ConcatToString();

        [Lazy]
        public bool IsAutoGenerated =>
            content
                .GetPropertyOrNull("vssId")
                ?.GetStringOrNull()
                ?.StartsWith("a.", StringComparison.OrdinalIgnoreCase) ?? false;
    }
}

internal partial class PlayerResponse
{
    public class StreamData(JsonElement content) : IStreamData
    {
        [Lazy]
        public int? Itag => content.GetPropertyOrNull("itag")?.GetInt32OrNull();

        [Lazy]
        private IReadOnlyDictionary<string, string>? CipherData =>
            content.GetPropertyOrNull("cipher")?.GetStringOrNull()?.Pipe(UrlEx.GetQueryParameters)
            ?? content
                .GetPropertyOrNull("signatureCipher")
                ?.GetStringOrNull()
                ?.Pipe(UrlEx.GetQueryParameters);

        [Lazy]
        public string? Url =>
            content.GetPropertyOrNull("url")?.GetStringOrNull()
            ?? CipherData?.GetValueOrDefault("url");

        [Lazy]
        public string? Signature => CipherData?.GetValueOrDefault("s");

        [Lazy]
        public string? SignatureParameter => CipherData?.GetValueOrDefault("sp");

        [Lazy]
        public long? ContentLength =>
            content.GetPropertyOrNull("contentLength")?.GetStringOrNull()?.ParseLongOrNull()
            ?? Url?.Pipe(s => UrlEx.TryGetQueryParameterValue(s, "clen"))
                ?.NullIfWhiteSpace()
                ?.ParseLongOrNull();

        [Lazy]
        public long? Bitrate => content.GetPropertyOrNull("bitrate")?.GetInt64OrNull();

        [Lazy]
        private string? MimeType => content.GetPropertyOrNull("mimeType")?.GetStringOrNull();

        [Lazy]
        public string? Container => MimeType?.SubstringUntil(";").SubstringAfter("/");

        [Lazy]
        private bool IsAudioOnly =>
            MimeType?.StartsWith("audio/", StringComparison.OrdinalIgnoreCase) ?? false;

        [Lazy]
        public string? Codecs => MimeType?.SubstringAfter("codecs=\"").SubstringUntil("\"");

        [Lazy]
        public string? AudioCodec =>
            IsAudioOnly ? Codecs : Codecs?.SubstringAfter(", ").NullIfWhiteSpace();

        [Lazy]
        public string? AudioLanguageCode =>
            content
                .GetPropertyOrNull("audioTrack")
                ?.GetPropertyOrNull("id")
                ?.GetStringOrNull()
                ?.SubstringUntil(".");

        [Lazy]
        public string? AudioLanguageName =>
            content
                .GetPropertyOrNull("audioTrack")
                ?.GetPropertyOrNull("displayName")
                ?.GetStringOrNull();

        [Lazy]
        public bool? IsAudioLanguageDefault =>
            content
                .GetPropertyOrNull("audioTrack")
                ?.GetPropertyOrNull("audioIsDefault")
                ?.GetBooleanOrNull();

        [Lazy]
        public string? VideoCodec
        {
            get
            {
                var codec = IsAudioOnly ? null : Codecs?.SubstringUntil(", ").NullIfWhiteSpace();

                // "unknown" value indicates av01 codec
                if (string.Equals(codec, "unknown", StringComparison.OrdinalIgnoreCase))
                    return "av01.0.05M.08";

                return codec;
            }
        }

        [Lazy]
        public string? VideoQualityLabel =>
            content.GetPropertyOrNull("qualityLabel")?.GetStringOrNull();

        [Lazy]
        public int? VideoWidth => content.GetPropertyOrNull("width")?.GetInt32OrNull();

        [Lazy]
        public int? VideoHeight => content.GetPropertyOrNull("height")?.GetInt32OrNull();

        [Lazy]
        public int? VideoFramerate => content.GetPropertyOrNull("fps")?.GetInt32OrNull();
    }
}

internal partial class PlayerResponse
{
    public static PlayerResponse Parse(string raw) => new(Json.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/PlayerSource.cs
================================================
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Lazy;
using YoutubeExplode.Bridge.Cipher;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class PlayerSource(string content)
{
    [Lazy]
    public CipherManifest? CipherManifest
    {
        get
        {
            // Extract the signature timestamp
            var signatureTimestamp = Regex
                .Match(content, @"(?:signatureTimestamp|sts):(\d{5})")
                .Groups[1]
                .Value.NullIfWhiteSpace();

            if (string.IsNullOrWhiteSpace(signatureTimestamp))
                return null;

            // Find where the player calls the cipher functions
            var cipherCallsite = Regex
                .Match(
                    content,
                    """
                    [$_\w]+=function\([$_\w]+\){([$_\w]+)=\1\.split\(['"]{2}\);.*?return \1\.join\(['"]{2}\)}
                    """,
                    RegexOptions.Singleline
                )
                .Groups[0]
                .Value.NullIfWhiteSpace();

            if (string.IsNullOrWhiteSpace(cipherCallsite))
                return null;

            // Find the object that defines the cipher functions
            var cipherContainerName = Regex
                .Match(cipherCallsite, @"([$_\w]+)\.[$_\w]+\([$_\w]+,\d+\);")
                .Groups[1]
                .Value;

            if (string.IsNullOrWhiteSpace(cipherContainerName))
                return null;

            // Find the definition of the cipher functions
            var cipherDefinition = Regex
                .Match(
                    content,
                    $$"""
                    var {{Regex.Escape(cipherContainerName)}}={.*?};
                    """,
                    RegexOptions.Singleline
                )
                .Groups[0]
                .Value.NullIfWhiteSpace();

            if (string.IsNullOrWhiteSpace(cipherDefinition))
                return null;

            // Identify the swap cipher function
            var swapFuncName = Regex
                .Match(
                    cipherDefinition,
                    @"([$_\w]+):function\([$_\w]+,[$_\w]+\){+[^}]*?%[^}]*?}",
                    RegexOptions.Singleline
                )
                .Groups[1]
                .Value.NullIfWhiteSpace();

            // Identify the splice cipher function
            var spliceFuncName = Regex
                .Match(
                    cipherDefinition,
                    @"([$_\w]+):function\([$_\w]+,[$_\w]+\){+[^}]*?splice[^}]*?}",
                    RegexOptions.Singleline
                )
                .Groups[1]
                .Value.NullIfWhiteSpace();

            // Identify the reverse cipher function
            var reverseFuncName = Regex
                .Match(
                    cipherDefinition,
                    @"([$_\w]+):function\([$_\w]+\){+[^}]*?reverse[^}]*?}",
                    RegexOptions.Singleline
                )
                .Groups[1]
                .Value.NullIfWhiteSpace();

            var operations = new List<ICipherOperation>();
            foreach (var statement in cipherCallsite.Split(';'))
            {
                var calledFuncName = Regex
                    .Match(statement, @"[$_\w]+\.([$_\w]+)\([$_\w]+,\d+\)")
                    .Groups[1]
                    .Value;

                if (string.IsNullOrWhiteSpace(calledFuncName))
                    continue;

                if (string.Equals(calledFuncName, swapFuncName, StringComparison.Ordinal))
                {
                    var index = Regex
                        .Match(statement, @"\([$_\w]+,(\d+)\)")
                        .Groups[1]
                        .Value.ParseInt();

                    operations.Add(new SwapCipherOperation(index));
                }
                else if (string.Equals(calledFuncName, spliceFuncName, StringComparison.Ordinal))
                {
                    var index = Regex
                        .Match(statement, @"\([$_\w]+,(\d+)\)")
                        .Groups[1]
                        .Value.ParseInt();

                    operations.Add(new SpliceCipherOperation(index));
                }
                else if (string.Equals(calledFuncName, reverseFuncName, StringComparison.Ordinal))
                {
                    operations.Add(new ReverseCipherOperation());
                }
            }

            return new CipherManifest(signatureTimestamp, operations);
        }
    }
}

internal partial class PlayerSource
{
    public static PlayerSource Parse(string raw) => new(raw);
}



================================================
FILE: YoutubeExplode/Bridge/PlaylistBrowseResponse.cs
================================================
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class PlaylistBrowseResponse(JsonElement content) : IPlaylistData
{
    [Lazy]
    private JsonElement? Sidebar =>
        content
            .GetPropertyOrNull("sidebar")
            ?.GetPropertyOrNull("playlistSidebarRenderer")
            ?.GetPropertyOrNull("items");

    [Lazy]
    private JsonElement? SidebarPrimary =>
        Sidebar
            ?.EnumerateArrayOrNull()
            ?.ElementAtOrNull(0)
            ?.GetPropertyOrNull("playlistSidebarPrimaryInfoRenderer");

    [Lazy]
    private JsonElement? SidebarSecondary =>
        Sidebar
            ?.EnumerateArrayOrNull()
            ?.ElementAtOrNull(1)
            ?.GetPropertyOrNull("playlistSidebarSecondaryInfoRenderer");

    [Lazy]
    public bool IsAvailable => Sidebar is not null;

    [Lazy]
    public string? Title =>
        SidebarPrimary
            ?.GetPropertyOrNull("title")
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("title")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
            .WhereNotNull()
            .ConcatToString()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("titleForm")
            ?.GetPropertyOrNull("inlineFormRenderer")
            ?.GetPropertyOrNull("formField")
            ?.GetPropertyOrNull("textInputFormFieldRenderer")
            ?.GetPropertyOrNull("value")
            ?.GetStringOrNull();

    [Lazy]
    private JsonElement? AuthorDetails =>
        SidebarSecondary?.GetPropertyOrNull("videoOwner")?.GetPropertyOrNull("videoOwnerRenderer");

    [Lazy]
    public string? Author =>
        AuthorDetails
            ?.GetPropertyOrNull("title")
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull()
        ?? AuthorDetails
            ?.GetPropertyOrNull("title")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
            .WhereNotNull()
            .ConcatToString();

    [Lazy]
    public string? ChannelId =>
        AuthorDetails
            ?.GetPropertyOrNull("navigationEndpoint")
            ?.GetPropertyOrNull("browseEndpoint")
            ?.GetPropertyOrNull("browseId")
            ?.GetStringOrNull();

    [Lazy]
    public string? Description =>
        SidebarPrimary
            ?.GetPropertyOrNull("description")
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("description")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
            .WhereNotNull()
            .ConcatToString()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("descriptionForm")
            ?.GetPropertyOrNull("inlineFormRenderer")
            ?.GetPropertyOrNull("formField")
            ?.GetPropertyOrNull("textInputFormFieldRenderer")
            ?.GetPropertyOrNull("value")
            ?.GetStringOrNull();

    [Lazy]
    public int? Count =>
        SidebarPrimary
            ?.GetPropertyOrNull("stats")
            ?.EnumerateArrayOrNull()
            ?.FirstOrNull()
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.FirstOrNull()
            ?.GetPropertyOrNull("text")
            ?.GetStringOrNull()
            ?.ParseIntOrNull()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("stats")
            ?.EnumerateArrayOrNull()
            ?.FirstOrNull()
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull()
            ?.Split(' ')
            ?.FirstOrDefault()
            ?.ParseIntOrNull();

    [Lazy]
    public IReadOnlyList<ThumbnailData> Thumbnails =>
        SidebarPrimary
            ?.GetPropertyOrNull("thumbnailRenderer")
            ?.GetPropertyOrNull("playlistVideoThumbnailRenderer")
            ?.GetPropertyOrNull("thumbnail")
            ?.GetPropertyOrNull("thumbnails")
            ?.EnumerateArrayOrNull()
            ?.Select(j => new ThumbnailData(j))
            .ToArray()
        ?? SidebarPrimary
            ?.GetPropertyOrNull("thumbnailRenderer")
            ?.GetPropertyOrNull("playlistCustomThumbnailRenderer")
            ?.GetPropertyOrNull("thumbnail")
            ?.GetPropertyOrNull("thumbnails")
            ?.EnumerateArrayOrNull()
            ?.Select(j => new ThumbnailData(j))
            .ToArray()
        ?? [];
}

internal partial class PlaylistBrowseResponse
{
    public static PlaylistBrowseResponse Parse(string raw) => new(Json.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/PlaylistNextResponse.cs
================================================
﻿using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class PlaylistNextResponse(JsonElement content) : IPlaylistData
{
    [Lazy]
    private JsonElement? ContentRoot =>
        content
            .GetPropertyOrNull("contents")
            ?.GetPropertyOrNull("twoColumnWatchNextResults")
            ?.GetPropertyOrNull("playlist")
            ?.GetPropertyOrNull("playlist");

    [Lazy]
    public bool IsAvailable => ContentRoot is not null;

    [Lazy]
    public string? Title => ContentRoot?.GetPropertyOrNull("title")?.GetStringOrNull();

    [Lazy]
    public string? Author =>
        ContentRoot
            ?.GetPropertyOrNull("ownerName")
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull();

    public string? ChannelId => null;

    public string? Description => null;

    [Lazy]
    public int? Count =>
        ContentRoot
            ?.GetPropertyOrNull("totalVideosText")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.FirstOrNull()
            ?.GetPropertyOrNull("text")
            ?.GetStringOrNull()
            ?.ParseIntOrNull()
        ?? ContentRoot
            ?.GetPropertyOrNull("videoCountText")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.ElementAtOrNull(2)
            ?.GetPropertyOrNull("text")
            ?.GetStringOrNull()
            ?.ParseIntOrNull();

    [Lazy]
    public IReadOnlyList<ThumbnailData> Thumbnails => Videos.FirstOrDefault()?.Thumbnails ?? [];

    [Lazy]
    public IReadOnlyList<PlaylistVideoData> Videos =>
        ContentRoot
            ?.GetPropertyOrNull("contents")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("playlistPanelVideoRenderer"))
            .WhereNotNull()
            .Select(j => new PlaylistVideoData(j))
            .ToArray() ?? [];

    [Lazy]
    public string? VisitorData =>
        content
            .GetPropertyOrNull("responseContext")
            ?.GetPropertyOrNull("visitorData")
            ?.GetStringOrNull();
}

internal partial class PlaylistNextResponse
{
    public static PlaylistNextResponse Parse(string raw) => new(Json.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/PlaylistVideoData.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Lazy;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal class PlaylistVideoData(JsonElement content)
{
    [Lazy]
    public int? Index =>
        content
            .GetPropertyOrNull("navigationEndpoint")
            ?.GetPropertyOrNull("watchEndpoint")
            ?.GetPropertyOrNull("index")
            ?.GetInt32OrNull();

    [Lazy]
    public string? Id => content.GetPropertyOrNull("videoId")?.GetStringOrNull();

    [Lazy]
    public string? Title =>
        content.GetPropertyOrNull("title")?.GetPropertyOrNull("simpleText")?.GetStringOrNull()
        ?? content
            .GetPropertyOrNull("title")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
            .WhereNotNull()
            .ConcatToString();

    [Lazy]
    private JsonElement? AuthorDetails =>
        content
            .GetPropertyOrNull("longBylineText")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.ElementAtOrNull(0)
        ?? content
            .GetPropertyOrNull("shortBylineText")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.ElementAtOrNull(0);

    [Lazy]
    public string? Author => AuthorDetails?.GetPropertyOrNull("text")?.GetStringOrNull();

    [Lazy]
    public string? ChannelId =>
        AuthorDetails
            ?.GetPropertyOrNull("navigationEndpoint")
            ?.GetPropertyOrNull("browseEndpoint")
            ?.GetPropertyOrNull("browseId")
            ?.GetStringOrNull();

    [Lazy]
    public TimeSpan? Duration =>
        content
            .GetPropertyOrNull("lengthSeconds")
            ?.GetStringOrNull()
            ?.ParseDoubleOrNull()
            ?.Pipe(TimeSpan.FromSeconds)
        ?? content
            .GetPropertyOrNull("lengthText")
            ?.GetPropertyOrNull("simpleText")
            ?.GetStringOrNull()
            ?.ParseTimeSpanOrNull([@"m\:ss", @"mm\:ss", @"h\:mm\:ss", @"hh\:mm\:ss"])
        ?? content
            .GetPropertyOrNull("lengthText")
            ?.GetPropertyOrNull("runs")
            ?.EnumerateArrayOrNull()
            ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
            .WhereNotNull()
            .ConcatToString()
            .ParseTimeSpanOrNull([@"m\:ss", @"mm\:ss", @"h\:mm\:ss", @"hh\:mm\:ss"]);

    [Lazy]
    public IReadOnlyList<ThumbnailData> Thumbnails =>
        content
            .GetPropertyOrNull("thumbnail")
            ?.GetPropertyOrNull("thumbnails")
            ?.EnumerateArrayOrNull()
            ?.Select(j => new ThumbnailData(j))
            .ToArray() ?? [];
}



================================================
FILE: YoutubeExplode/Bridge/SearchResponse.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class SearchResponse(JsonElement content)
{
    // Search response is incredibly inconsistent (with at least 5 variations),
    // so we employ descendant searching, which is inefficient but resilient.

    [Lazy]
    private JsonElement? ContentRoot =>
        content.GetPropertyOrNull("contents")
        ?? content.GetPropertyOrNull("onResponseReceivedCommands");

    [Lazy]
    public IReadOnlyList<VideoData> Videos =>
        ContentRoot
            ?.EnumerateDescendantProperties("videoRenderer")
            .Select(j => new VideoData(j))
            .ToArray() ?? [];

    [Lazy]
    public IReadOnlyList<PlaylistData> Playlists =>
        ContentRoot
            ?.EnumerateDescendantProperties("lockupViewModel")
            .Select(j => new PlaylistData(j))
            .ToArray()
        ?? ContentRoot
            ?.EnumerateDescendantProperties("playlistRenderer")
            .Select(j => new PlaylistData(j))
            .ToArray()
        ?? [];

    [Lazy]
    public IReadOnlyList<ChannelData> Channels =>
        ContentRoot
            ?.EnumerateDescendantProperties("channelRenderer")
            .Select(j => new ChannelData(j))
            .ToArray() ?? [];

    [Lazy]
    public string? ContinuationToken =>
        ContentRoot
            ?.EnumerateDescendantProperties("continuationCommand")
            .FirstOrNull()
            ?.GetPropertyOrNull("token")
            ?.GetStringOrNull();
}

internal partial class SearchResponse
{
    internal class VideoData(JsonElement content)
    {
        [Lazy]
        public string? Id => content.GetPropertyOrNull("videoId")?.GetStringOrNull();

        [Lazy]
        public string? Title =>
            content.GetPropertyOrNull("title")?.GetPropertyOrNull("simpleText")?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("title")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
                .WhereNotNull()
                .ConcatToString();

        [Lazy]
        private JsonElement? AuthorDetails =>
            content
                .GetPropertyOrNull("longBylineText")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.ElementAtOrNull(0)
            ?? content
                .GetPropertyOrNull("shortBylineText")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.ElementAtOrNull(0);

        [Lazy]
        public string? Author => AuthorDetails?.GetPropertyOrNull("text")?.GetStringOrNull();

        [Lazy]
        public string? ChannelId =>
            AuthorDetails
                ?.GetPropertyOrNull("navigationEndpoint")
                ?.GetPropertyOrNull("browseEndpoint")
                ?.GetPropertyOrNull("browseId")
                ?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("channelThumbnailSupportedRenderers")
                ?.GetPropertyOrNull("channelThumbnailWithLinkRenderer")
                ?.GetPropertyOrNull("navigationEndpoint")
                ?.GetPropertyOrNull("browseEndpoint")
                ?.GetPropertyOrNull("browseId")
                ?.GetStringOrNull();

        [Lazy]
        public TimeSpan? Duration =>
            content
                .GetPropertyOrNull("lengthText")
                ?.GetPropertyOrNull("simpleText")
                ?.GetStringOrNull()
                ?.ParseTimeSpanOrNull([@"m\:ss", @"mm\:ss", @"h\:mm\:ss", @"hh\:mm\:ss"])
            ?? content
                .GetPropertyOrNull("lengthText")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
                .WhereNotNull()
                .ConcatToString()
                .ParseTimeSpanOrNull([@"m\:ss", @"mm\:ss", @"h\:mm\:ss", @"hh\:mm\:ss"]);

        [Lazy]
        public IReadOnlyList<ThumbnailData> Thumbnails =>
            content
                .GetPropertyOrNull("thumbnail")
                ?.GetPropertyOrNull("thumbnails")
                ?.EnumerateArrayOrNull()
                ?.Select(j => new ThumbnailData(j))
                .ToArray() ?? [];
    }
}

internal partial class SearchResponse
{
    public class PlaylistData(JsonElement content)
    {
        [Lazy]
        public string? Id =>
            content.GetPropertyOrNull("contentId")?.GetStringOrNull()
            ?? content.GetPropertyOrNull("playlistId")?.GetStringOrNull();

        [Lazy]
        private JsonElement? Metadata =>
            content.GetPropertyOrNull("metadata")?.GetPropertyOrNull("lockupMetadataViewModel");

        [Lazy]
        public string? Title =>
            Metadata?.GetPropertyOrNull("title")?.GetPropertyOrNull("content")?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("title")
                ?.GetPropertyOrNull("simpleText")
                ?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("title")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
                .WhereNotNull()
                .ConcatToString();

        [Lazy]
        private JsonElement? AuthorDetails =>
            Metadata
                ?.EnumerateDescendantProperties("metadataParts")
                ?.ElementAtOrNull(0)
                ?.EnumerateArrayOrNull()
                ?.ElementAtOrNull(0)
                ?.GetPropertyOrNull("text")
            ?? content
                .GetPropertyOrNull("longBylineText")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.ElementAtOrNull(0);

        [Lazy]
        public string? Author =>
            AuthorDetails?.GetPropertyOrNull("content")?.GetStringOrNull()
            ?? AuthorDetails?.GetPropertyOrNull("text")?.GetStringOrNull();

        [Lazy]
        public string? ChannelId =>
            AuthorDetails
                ?.GetPropertyOrNull("commandRuns")
                ?.EnumerateArrayOrNull()
                ?.ElementAtOrNull(0)
                ?.GetPropertyOrNull("onTap")
                ?.GetPropertyOrNull("innertubeCommand")
                ?.GetPropertyOrNull("browseEndpoint")
                ?.GetPropertyOrNull("browseId")
                ?.GetStringOrNull()
            ?? AuthorDetails
                ?.GetPropertyOrNull("navigationEndpoint")
                ?.GetPropertyOrNull("browseEndpoint")
                ?.GetPropertyOrNull("browseId")
                ?.GetStringOrNull();

        [Lazy]
        public IReadOnlyList<ThumbnailData> Thumbnails =>
            content
                .GetPropertyOrNull("contentImage")
                ?.GetPropertyOrNull("collectionThumbnailViewModel")
                ?.GetPropertyOrNull("primaryThumbnail")
                ?.GetPropertyOrNull("thumbnailViewModel")
                ?.GetPropertyOrNull("image")
                ?.GetPropertyOrNull("sources")
                ?.EnumerateArrayOrEmpty()
                .Select(j => new ThumbnailData(j))
                .ToArray()
            ?? content
                .GetPropertyOrNull("thumbnails")
                ?.EnumerateDescendantProperties("thumbnails")
                .SelectMany(j => j.EnumerateArrayOrEmpty())
                .Select(j => new ThumbnailData(j))
                .ToArray()
            ?? [];
    }
}

internal partial class SearchResponse
{
    public class ChannelData(JsonElement content)
    {
        [Lazy]
        public string? Id => content.GetPropertyOrNull("channelId")?.GetStringOrNull();

        [Lazy]
        public string? Title =>
            content.GetPropertyOrNull("title")?.GetPropertyOrNull("simpleText")?.GetStringOrNull()
            ?? content
                .GetPropertyOrNull("title")
                ?.GetPropertyOrNull("runs")
                ?.EnumerateArrayOrNull()
                ?.Select(j => j.GetPropertyOrNull("text")?.GetStringOrNull())
                .WhereNotNull()
                .ConcatToString();

        [Lazy]
        public IReadOnlyList<ThumbnailData> Thumbnails =>
            content
                .GetPropertyOrNull("thumbnail")
                ?.GetPropertyOrNull("thumbnails")
                ?.EnumerateArrayOrNull()
                ?.Select(j => new ThumbnailData(j))
                .ToArray() ?? [];
    }
}

internal partial class SearchResponse
{
    public static SearchResponse Parse(string raw) => new(Json.Parse(raw));
}



================================================
FILE: YoutubeExplode/Bridge/ThumbnailData.cs
================================================
﻿using System.Text.Json;
using Lazy;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal class ThumbnailData(JsonElement content)
{
    [Lazy]
    public string? Url => content.GetPropertyOrNull("url")?.GetStringOrNull();

    [Lazy]
    public int? Width => content.GetPropertyOrNull("width")?.GetInt32OrNull();

    [Lazy]
    public int? Height => content.GetPropertyOrNull("height")?.GetInt32OrNull();
}



================================================
FILE: YoutubeExplode/Bridge/VideoWatchPage.cs
================================================
using System;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using Lazy;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge;

internal partial class VideoWatchPage(IHtmlDocument content)
{
    [Lazy]
    public bool IsAvailable => content.QuerySelector("meta[property=\"og:url\"]") is not null;

    [Lazy]
    public DateTimeOffset? UploadDate =>
        content
            .QuerySelector("meta[itemprop=\"uploadDate\"]")
            ?.GetAttribute("content")
            ?.NullIfWhiteSpace()
            ?.ParseDateTimeOffsetOrNull()
        ?? content
            .QuerySelector("meta[itemprop=\"datePublished\"]")
            ?.GetAttribute("content")
            ?.NullIfWhiteSpace()
            ?.ParseDateTimeOffsetOrNull();

    [Lazy]
    public long? LikeCount =>
        content
            .Source.Text.Pipe(s =>
                Regex
                    .Match(
                        s,
                        """
                        "\s*:\s*"([\d,\.]+) likes"
                        """
                    )
                    .Groups[1]
                    .Value
            )
            .NullIfWhiteSpace()
            ?.StripNonDigit()
            .ParseLongOrNull()
        ?? content
            .Source.Text.Pipe(s =>
                Regex
                    .Match(
                        s,
                        """
                        along with ([\d,\.]+) other people"
                        """
                    )
                    .Groups[1]
                    .Value
            )
            .NullIfWhiteSpace()
            ?.StripNonDigit()
            .ParseLongOrNull();

    [Lazy]
    public long? DislikeCount =>
        content
            .Source.Text.Pipe(s =>
                Regex
                    .Match(
                        s,
                        """
                        "\s*:\s*"([\d,\.]+) dislikes"
                        """
                    )
                    .Groups[1]
                    .Value
            )
            .NullIfWhiteSpace()
            ?.StripNonDigit()
            .ParseLongOrNull();

    [Lazy]
    private JsonElement? PlayerConfig =>
        content
            .GetElementsByTagName("script")
            .Select(e => e.Text())
            .Select(s => Regex.Match(s, @"ytplayer\.config\s*=\s*(\{.*\})").Groups[1].Value)
            .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))
            ?.NullIfWhiteSpace()
            ?.Pipe(Json.Extract)
            .Pipe(Json.TryParse);

    [Lazy]
    public PlayerResponse? PlayerResponse =>
        content
            .GetElementsByTagName("script")
            .Select(e => e.Text())
            .Select(s =>
                Regex.Match(s, @"var\s+ytInitialPlayerResponse\s*=\s*(\{.*\})").Groups[1].Value
            )
            .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))
            ?.NullIfWhiteSpace()
            ?.Pipe(Json.Extract)
            .Pipe(Json.TryParse)
            ?.Pipe(j => new PlayerResponse(j))
        ?? PlayerConfig
            ?.GetPropertyOrNull("args")
            ?.GetPropertyOrNull("player_response")
            ?.GetStringOrNull()
            ?.Pipe(Json.TryParse)
            ?.Pipe(j => new PlayerResponse(j));
}

internal partial class VideoWatchPage
{
    public static VideoWatchPage? TryParse(string raw)
    {
        var content = Html.Parse(raw);

        if (content.Body?.QuerySelector("#player") is null)
            return null;

        return new VideoWatchPage(content);
    }
}



================================================
FILE: YoutubeExplode/Bridge/Cipher/CipherManifest.cs
================================================
﻿using System.Collections.Generic;
using System.Linq;

namespace YoutubeExplode.Bridge.Cipher;

internal class CipherManifest(string signatureTimestamp, IReadOnlyList<ICipherOperation> operations)
{
    public string SignatureTimestamp { get; } = signatureTimestamp;

    public IReadOnlyList<ICipherOperation> Operations { get; } = operations;

    public string Decipher(string input) =>
        Operations.Aggregate(input, (acc, op) => op.Decipher(acc));
}



================================================
FILE: YoutubeExplode/Bridge/Cipher/ICipherOperation.cs
================================================
namespace YoutubeExplode.Bridge.Cipher;

internal interface ICipherOperation
{
    string Decipher(string input);
}



================================================
FILE: YoutubeExplode/Bridge/Cipher/ReverseCipherOperation.cs
================================================
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge.Cipher;

internal class ReverseCipherOperation : ICipherOperation
{
    public string Decipher(string input) => input.Reverse();

    [ExcludeFromCodeCoverage]
    public override string ToString() => "Reverse";
}



================================================
FILE: YoutubeExplode/Bridge/Cipher/SpliceCipherOperation.cs
================================================
using System.Diagnostics.CodeAnalysis;

namespace YoutubeExplode.Bridge.Cipher;

internal class SpliceCipherOperation(int index) : ICipherOperation
{
    public string Decipher(string input) => input[index..];

    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Splice ({index})";
}



================================================
FILE: YoutubeExplode/Bridge/Cipher/SwapCipherOperation.cs
================================================
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Bridge.Cipher;

internal class SwapCipherOperation(int index) : ICipherOperation
{
    public string Decipher(string input) => input.SwapChars(0, index);

    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Swap ({index})";
}



================================================
FILE: YoutubeExplode/Channels/Channel.cs
================================================
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;

namespace YoutubeExplode.Channels;

/// <summary>
/// Metadata associated with a YouTube channel.
/// </summary>
public class Channel(ChannelId id, string title, IReadOnlyList<Thumbnail> thumbnails) : IChannel
{
    /// <inheritdoc />
    public ChannelId Id { get; } = id;

    /// <inheritdoc />
    public string Url => $"https://www.youtube.com/channel/{Id}";

    /// <inheritdoc />
    public string Title { get; } = title;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Channel ({Title})";
}



================================================
FILE: YoutubeExplode/Channels/ChannelClient.cs
================================================
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Playlists;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Channels;

/// <summary>
/// Operations related to YouTube channels.
/// </summary>
public class ChannelClient(HttpClient http)
{
    private readonly ChannelController _controller = new(http);

    private Channel Get(ChannelPage channelPage)
    {
        var channelId =
            channelPage.Id
            ?? throw new YoutubeExplodeException("Failed to extract the channel ID.");

        var title =
            channelPage.Title
            ?? throw new YoutubeExplodeException("Failed to extract the channel title.");

        var logoUrl =
            channelPage.LogoUrl
            ?? throw new YoutubeExplodeException("Failed to extract the channel logo URL.");

        var logoSize =
            Regex
                .Matches(logoUrl, @"\bs(\d+)\b")
                .ToArray()
                .LastOrDefault()
                ?.Groups[1]
                .Value.NullIfWhiteSpace()
                ?.ParseIntOrNull() ?? 100;

        var thumbnails = new[] { new Thumbnail(logoUrl, new Resolution(logoSize, logoSize)) };

        return new Channel(channelId, title, thumbnails);
    }

    /// <summary>
    /// Gets the metadata associated with the specified channel.
    /// </summary>
    public async ValueTask<Channel> GetAsync(
        ChannelId channelId,
        CancellationToken cancellationToken = default
    )
    {
        // Special case for the "Movies & TV" channel, which has a custom page
        if (channelId == "UCuVPpxrm2VAgpH3Ktln4HXg")
        {
            return new Channel(
                "UCuVPpxrm2VAgpH3Ktln4HXg",
                "Movies & TV",
                [
                    new Thumbnail(
                        "https://www.gstatic.com/youtube/img/tvfilm/clapperboard_profile.png",
                        new Resolution(1024, 1024)
                    ),
                ]
            );
        }

        return Get(await _controller.GetChannelPageAsync(channelId, cancellationToken));
    }

    /// <summary>
    /// Gets the metadata associated with the channel of the specified user.
    /// </summary>
    public async ValueTask<Channel> GetByUserAsync(
        UserName userName,
        CancellationToken cancellationToken = default
    ) => Get(await _controller.GetChannelPageAsync(userName, cancellationToken));

    /// <summary>
    /// Gets the metadata associated with the channel identified by the specified slug or legacy custom URL.
    /// </summary>
    public async ValueTask<Channel> GetBySlugAsync(
        ChannelSlug channelSlug,
        CancellationToken cancellationToken = default
    ) => Get(await _controller.GetChannelPageAsync(channelSlug, cancellationToken));

    /// <summary>
    /// Gets the metadata associated with the channel identified by the specified handle or custom URL.
    /// </summary>
    public async ValueTask<Channel> GetByHandleAsync(
        ChannelHandle channelHandle,
        CancellationToken cancellationToken = default
    ) => Get(await _controller.GetChannelPageAsync(channelHandle, cancellationToken));

    /// <summary>
    /// Enumerates videos uploaded by the specified channel.
    /// </summary>
    // TODO: should return <IVideo> sequence instead (breaking change)
    public IAsyncEnumerable<PlaylistVideo> GetUploadsAsync(
        ChannelId channelId,
        CancellationToken cancellationToken = default
    )
    {
        // Replace 'UC' in the channel ID with 'UU'
        var playlistId = "UU" + channelId.Value[2..];
        return new PlaylistClient(http).GetVideosAsync(playlistId, cancellationToken);
    }
}



================================================
FILE: YoutubeExplode/Channels/ChannelController.cs
================================================
﻿using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Exceptions;

namespace YoutubeExplode.Channels;

internal class ChannelController(HttpClient http)
{
    private async ValueTask<ChannelPage> GetChannelPageAsync(
        string channelRoute,
        CancellationToken cancellationToken = default
    )
    {
        for (var retriesRemaining = 5; ; retriesRemaining--)
        {
            var channelPage = ChannelPage.TryParse(
                await http.GetStringAsync(
                    "https://www.youtube.com/" + channelRoute,
                    cancellationToken
                )
            );

            if (channelPage is null)
            {
                if (retriesRemaining > 0)
                    continue;

                throw new YoutubeExplodeException(
                    "Channel page is broken. Please try again in a few minutes."
                );
            }

            return channelPage;
        }
    }

    public async ValueTask<ChannelPage> GetChannelPageAsync(
        ChannelId channelId,
        CancellationToken cancellationToken = default
    ) => await GetChannelPageAsync("channel/" + channelId, cancellationToken);

    public async ValueTask<ChannelPage> GetChannelPageAsync(
        UserName userName,
        CancellationToken cancellationToken = default
    ) => await GetChannelPageAsync("user/" + userName, cancellationToken);

    public async ValueTask<ChannelPage> GetChannelPageAsync(
        ChannelSlug channelSlug,
        CancellationToken cancellationToken = default
    ) => await GetChannelPageAsync("c/" + channelSlug, cancellationToken);

    public async ValueTask<ChannelPage> GetChannelPageAsync(
        ChannelHandle channelHandle,
        CancellationToken cancellationToken = default
    ) => await GetChannelPageAsync("@" + channelHandle, cancellationToken);
}



================================================
FILE: YoutubeExplode/Channels/ChannelHandle.cs
================================================
﻿using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Channels;

/// <summary>
/// Represents a syntactically valid YouTube channel handle.
/// </summary>
public readonly partial struct ChannelHandle(string value)
{
    /// <summary>
    /// Raw handle value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public readonly partial struct ChannelHandle
{
    private static bool IsValid(string channelHandle) =>
        channelHandle.All(c => char.IsLetterOrDigit(c) || c is '_' or '-' or '.');

    private static string? TryNormalize(string? channelHandleOrUrl)
    {
        if (string.IsNullOrWhiteSpace(channelHandleOrUrl))
            return null;

        // Check if already passed a handle
        // Tyrrrz
        if (IsValid(channelHandleOrUrl))
            return channelHandleOrUrl;

        // Try to extract the handle from the URL
        // https://www.youtube.com/@Tyrrrz
        var handle = Regex
            .Match(channelHandleOrUrl, @"youtube\..+?/@(.*?)(?:\?|&|/|$)")
            .Groups[1]
            .Value.Pipe(WebUtility.UrlDecode);

        if (!string.IsNullOrWhiteSpace(handle) && IsValid(handle))
            return handle;

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a YouTube channel handle or custom URL.
    /// Returns null in case of failure.
    /// </summary>
    public static ChannelHandle? TryParse(string? channelHandleOrUrl) =>
        TryNormalize(channelHandleOrUrl)?.Pipe(handle => new ChannelHandle(handle));

    /// <summary>
    /// Parses the specified string as a YouTube channel handle or custom URL.
    /// </summary>
    public static ChannelHandle Parse(string channelHandleOrUrl) =>
        TryParse(channelHandleOrUrl)
        ?? throw new ArgumentException(
            $"Invalid YouTube channel handle or custom URL '{channelHandleOrUrl}'."
        );

    /// <summary>
    /// Converts string to channel handle.
    /// </summary>
    public static implicit operator ChannelHandle(string channelHandleOrUrl) =>
        Parse(channelHandleOrUrl);

    /// <summary>
    /// Converts channel handle to string.
    /// </summary>
    public static implicit operator string(ChannelHandle channelHandle) => channelHandle.ToString();
}



================================================
FILE: YoutubeExplode/Channels/ChannelId.cs
================================================
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Channels;

/// <summary>
/// Represents a syntactically valid YouTube channel ID.
/// </summary>
public readonly partial struct ChannelId(string value)
{
    /// <summary>
    /// Raw ID value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public partial struct ChannelId
{
    private static bool IsValid(string channelId) =>
        channelId.StartsWith("UC", StringComparison.Ordinal)
        && channelId.Length == 24
        && channelId.All(c => char.IsLetterOrDigit(c) || c is '_' or '-');

    private static string? TryNormalize(string? channelIdOrUrl)
    {
        if (string.IsNullOrWhiteSpace(channelIdOrUrl))
            return null;

        // Check if already passed an ID
        // UC3xnGqlcL3y-GXz5N3wiTJQ
        if (IsValid(channelIdOrUrl))
            return channelIdOrUrl;

        // Try to extract the ID from the URL
        // https://www.youtube.com/channel/UC3xnGqlcL3y-GXz5N3wiTJQ
        var id = Regex
            .Match(channelIdOrUrl, @"youtube\..+?/channel/(.*?)(?:\?|&|/|$)")
            .Groups[1]
            .Value.Pipe(WebUtility.UrlDecode);

        if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
            return id;

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a YouTube channel ID or URL.
    /// Returns null in case of failure.
    /// </summary>
    public static ChannelId? TryParse(string? channelIdOrUrl) =>
        TryNormalize(channelIdOrUrl)?.Pipe(id => new ChannelId(id));

    /// <summary>
    /// Parses the specified string as a YouTube channel ID or URL.
    /// </summary>
    public static ChannelId Parse(string channelIdOrUrl) =>
        TryParse(channelIdOrUrl)
        ?? throw new ArgumentException($"Invalid YouTube channel ID or URL '{channelIdOrUrl}'.");

    /// <summary>
    /// Converts string to ID.
    /// </summary>
    public static implicit operator ChannelId(string channelIdOrUrl) => Parse(channelIdOrUrl);

    /// <summary>
    /// Converts ID to string.
    /// </summary>
    public static implicit operator string(ChannelId channelId) => channelId.ToString();
}

public partial struct ChannelId : IEquatable<ChannelId>
{
    /// <inheritdoc />
    public bool Equals(ChannelId other) => StringComparer.Ordinal.Equals(Value, other.Value);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is ChannelId other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.Ordinal.GetHashCode(Value);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(ChannelId left, ChannelId right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(ChannelId left, ChannelId right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Channels/ChannelSlug.cs
================================================
﻿using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Channels;

/// <summary>
/// Represents a syntactically valid YouTube channel slug.
/// </summary>
public readonly partial struct ChannelSlug(string value)
{
    /// <summary>
    /// Raw slug value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public readonly partial struct ChannelSlug
{
    private static bool IsValid(string channelSlug) => channelSlug.All(char.IsLetterOrDigit);

    private static string? TryNormalize(string? channelSlugOrUrl)
    {
        if (string.IsNullOrWhiteSpace(channelSlugOrUrl))
            return null;

        // Check if already passed a slug
        // Tyrrrz
        if (IsValid(channelSlugOrUrl))
            return channelSlugOrUrl;

        // Try to extract the slug from the URL
        // https://www.youtube.com/c/Tyrrrz
        var slug = Regex
            .Match(channelSlugOrUrl, @"youtube\..+?/c/(.*?)(?:\?|&|/|$)")
            .Groups[1]
            .Value.Pipe(WebUtility.UrlDecode);

        if (!string.IsNullOrWhiteSpace(slug) && IsValid(slug))
            return slug;

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a YouTube channel slug or legacy custom URL.
    /// Returns null in case of failure.
    /// </summary>
    public static ChannelSlug? TryParse(string? channelSlugOrUrl) =>
        TryNormalize(channelSlugOrUrl)?.Pipe(slug => new ChannelSlug(slug));

    /// <summary>
    /// Parses the specified string as a YouTube channel slug or legacy custom url.
    /// </summary>
    public static ChannelSlug Parse(string channelSlugOrUrl) =>
        TryParse(channelSlugOrUrl)
        ?? throw new ArgumentException(
            $"Invalid YouTube channel slug or legacy custom URL '{channelSlugOrUrl}'."
        );

    /// <summary>
    /// Converts string to channel slug.
    /// </summary>
    public static implicit operator ChannelSlug(string channelSlugOrUrl) => Parse(channelSlugOrUrl);

    /// <summary>
    /// Converts channel slug to string.
    /// </summary>
    public static implicit operator string(ChannelSlug channelSlug) => channelSlug.ToString();
}



================================================
FILE: YoutubeExplode/Channels/IChannel.cs
================================================
﻿using System.Collections.Generic;
using YoutubeExplode.Common;

namespace YoutubeExplode.Channels;

/// <summary>
/// Properties shared by channel metadata resolved from different sources.
/// </summary>
public interface IChannel
{
    /// <summary>
    /// Channel ID.
    /// </summary>
    ChannelId Id { get; }

    /// <summary>
    /// Channel URL.
    /// </summary>
    string Url { get; }

    /// <summary>
    /// Channel title.
    /// </summary>
    string Title { get; }

    /// <summary>
    /// Channel thumbnails.
    /// </summary>
    IReadOnlyList<Thumbnail> Thumbnails { get; }
}



================================================
FILE: YoutubeExplode/Channels/UserName.cs
================================================
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Channels;

/// <summary>
/// Represents a syntactically valid YouTube user name.
/// </summary>
public readonly partial struct UserName(string value)
{
    /// <summary>
    /// Raw user name value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public partial struct UserName
{
    private static bool IsValid(string userName) =>
        userName.Length <= 20 && userName.All(char.IsLetterOrDigit);

    private static string? TryNormalize(string? userNameOrUrl)
    {
        if (string.IsNullOrWhiteSpace(userNameOrUrl))
            return null;

        // Check if already passed a user name
        // TheTyrrr
        if (IsValid(userNameOrUrl))
            return userNameOrUrl;

        // Try to extract the user name from the URL
        // https://www.youtube.com/user/TheTyrrr
        var userName = Regex
            .Match(userNameOrUrl, @"youtube\..+?/user/(.*?)(?:\?|&|/|$)")
            .Groups[1]
            .Value.Pipe(WebUtility.UrlDecode);

        if (!string.IsNullOrWhiteSpace(userName) && IsValid(userName))
            return userName;

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a YouTube user name or profile URL.
    /// Returns null in case of failure.
    /// </summary>
    public static UserName? TryParse(string? userNameOrUrl) =>
        TryNormalize(userNameOrUrl)?.Pipe(name => new UserName(name));

    /// <summary>
    /// Parses the specified string as a YouTube user name or profile URL.
    /// </summary>
    public static UserName Parse(string userNameOrUrl) =>
        TryParse(userNameOrUrl)
        ?? throw new ArgumentException(
            $"Invalid YouTube user name or profile URL '{userNameOrUrl}'."
        );

    /// <summary>
    /// Converts string to user name.
    /// </summary>
    public static implicit operator UserName(string userNameOrUrl) => Parse(userNameOrUrl);

    /// <summary>
    /// Converts user name to string.
    /// </summary>
    public static implicit operator string(UserName userName) => userName.ToString();
}

public partial struct UserName : IEquatable<UserName>
{
    /// <inheritdoc />
    public bool Equals(UserName other) => StringComparer.Ordinal.Equals(Value, other.Value);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is UserName other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.Ordinal.GetHashCode(Value);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(UserName left, UserName right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(UserName left, UserName right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Common/Author.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Channels;

namespace YoutubeExplode.Common;

/// <summary>
/// Reference to a channel that owns a specific YouTube video or playlist.
/// </summary>
public class Author(ChannelId channelId, string channelTitle)
{
    /// <summary>
    /// Channel ID.
    /// </summary>
    public ChannelId ChannelId { get; } = channelId;

    /// <summary>
    /// Channel URL.
    /// </summary>
    public string ChannelUrl => $"https://www.youtube.com/channel/{ChannelId}";

    /// <summary>
    /// Channel title.
    /// </summary>
    public string ChannelTitle { get; } = channelTitle;

    /// <inheritdoc cref="ChannelTitle" />
    [Obsolete("Use ChannelTitle instead."), ExcludeFromCodeCoverage]
    public string Title => ChannelTitle;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => ChannelTitle;
}



================================================
FILE: YoutubeExplode/Common/Batch.cs
================================================
﻿using System.Collections.Generic;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Common;

/// <summary>
/// Generic collection of items returned by a single request.
/// </summary>
public class Batch<T>(IReadOnlyList<T> items)
    where T : IBatchItem
{
    /// <summary>
    /// Items included in the batch.
    /// </summary>
    public IReadOnlyList<T> Items { get; } = items;
}

internal static class Batch
{
    public static Batch<T> Create<T>(IReadOnlyList<T> items)
        where T : IBatchItem => new(items);
}

internal static class BatchExtensions
{
    public static IAsyncEnumerable<T> FlattenAsync<T>(this IAsyncEnumerable<Batch<T>> source)
        where T : IBatchItem => source.SelectManyAsync(b => b.Items);
}



================================================
FILE: YoutubeExplode/Common/IBatchItem.cs
================================================
﻿using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Common;

/// <summary>
/// Represents an item that can be included in <see cref="Batch{T}" />.
/// This interface is used as a marker to enable extension methods.
/// </summary>
public interface IBatchItem { }

/// <summary>
/// Extensions for <see cref="IBatchItem" />.
/// </summary>
public static class BatchItemExtensions
{
    // We want to enable some convenience methods on instances of IAsyncEnumerable<T>
    // exposed by the library.
    // However, we don't want these extensions to apply to other IAsyncEnumerable<T>
    // as that could cause unwanted noise for the user.
    // To that end, we use a marker interface and a generic constraint to limit the
    // set of types that these extension methods can be used on.

    /// <summary>
    /// Enumerates all items in the sequence and buffers them in memory.
    /// </summary>
    public static async ValueTask<IReadOnlyList<T>> CollectAsync<T>(this IAsyncEnumerable<T> source)
        where T : IBatchItem => await source.ToListAsync();

    /// <summary>
    /// Enumerates a subset of items in the sequence and buffers them in memory.
    /// </summary>
    public static async ValueTask<IReadOnlyList<T>> CollectAsync<T>(
        this IAsyncEnumerable<T> source,
        int count
    )
        where T : IBatchItem => await source.TakeAsync(count).ToListAsync();

    /// <inheritdoc cref="CollectAsync{T}(System.Collections.Generic.IAsyncEnumerable{T})" />
    public static ValueTaskAwaiter<IReadOnlyList<T>> GetAwaiter<T>(this IAsyncEnumerable<T> source)
        where T : IBatchItem => source.CollectAsync().GetAwaiter();
}



================================================
FILE: YoutubeExplode/Common/Language.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;

// TODO: breaking change: update the namespace
// ReSharper disable once CheckNamespace
namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Language information.
/// </summary>
public readonly partial struct Language(string code, string name)
{
    /// <summary>
    /// Two-letter or three-letter language code, possibly with a regional identifier
    /// (e.g. 'en' or 'en-US' or 'eng').
    /// </summary>
    public string Code { get; } = code;

    /// <summary>
    /// Full international name of the language.
    /// </summary>
    public string Name { get; } = name;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"{Code} ({Name})";
}

public partial struct Language : IEquatable<Language>
{
    /// <inheritdoc />
    public bool Equals(Language other) => StringComparer.OrdinalIgnoreCase.Equals(Code, other.Code);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is Language other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.OrdinalIgnoreCase.GetHashCode(Code);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(Language left, Language right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(Language left, Language right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Common/Resolution.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;

namespace YoutubeExplode.Common;

/// <summary>
/// Resolution of an image or a video.
/// </summary>
public readonly partial struct Resolution(int width, int height)
{
    /// <summary>
    /// Viewport width, measured in pixels.
    /// </summary>
    public int Width { get; } = width;

    /// <summary>
    /// Viewport height, measured in pixels.
    /// </summary>
    public int Height { get; } = height;

    /// <summary>
    /// Viewport area (i.e. width multiplied by height).
    /// </summary>
    public int Area => Width * Height;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"{Width}x{Height}";
}

public partial struct Resolution : IEquatable<Resolution>
{
    /// <inheritdoc />
    public bool Equals(Resolution other) => Width == other.Width && Height == other.Height;

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is Resolution other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => HashCode.Combine(Width, Height);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(Resolution left, Resolution right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(Resolution left, Resolution right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Common/Thumbnail.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Common;

/// <summary>
/// Thumbnail image.
/// </summary>
public partial class Thumbnail(string url, Resolution resolution)
{
    /// <summary>
    /// Thumbnail URL.
    /// </summary>
    public string Url { get; } = url;

    /// <summary>
    /// Thumbnail resolution.
    /// </summary>
    public Resolution Resolution { get; } = resolution;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Thumbnail ({Resolution})";
}

public partial class Thumbnail
{
    internal static IReadOnlyList<Thumbnail> GetDefaultSet(VideoId videoId) =>
        [
            new Thumbnail(
                $"https://img.youtube.com/vi/{videoId}/default.jpg",
                new Resolution(120, 90)
            ),
            new Thumbnail(
                $"https://img.youtube.com/vi/{videoId}/mqdefault.jpg",
                new Resolution(320, 180)
            ),
            new Thumbnail(
                $"https://img.youtube.com/vi/{videoId}/hqdefault.jpg",
                new Resolution(480, 360)
            ),
        ];
}

/// <summary>
/// Extensions for <see cref="Thumbnail" />.
/// </summary>
public static class ThumbnailExtensions
{
    /// <summary>
    /// Gets the thumbnail with the highest resolution (by area).
    /// Returns null if the sequence is empty.
    /// </summary>
    public static Thumbnail? TryGetWithHighestResolution(this IEnumerable<Thumbnail> thumbnails) =>
        thumbnails.MaxBy(t => t.Resolution.Area);

    /// <summary>
    /// Gets the thumbnail with the highest resolution (by area).
    /// </summary>
    public static Thumbnail GetWithHighestResolution(this IEnumerable<Thumbnail> thumbnails) =>
        thumbnails.TryGetWithHighestResolution()
        ?? throw new InvalidOperationException("Input thumbnail collection is empty.");
}



================================================
FILE: YoutubeExplode/Exceptions/PlaylistUnavailableException.cs
================================================
namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown when the requested playlist is unavailable.
/// </summary>
public class PlaylistUnavailableException(string message) : YoutubeExplodeException(message);



================================================
FILE: YoutubeExplode/Exceptions/RequestLimitExceededException.cs
================================================
namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown when YouTube denies a request because the client has exceeded rate limit.
/// </summary>
public class RequestLimitExceededException(string message) : YoutubeExplodeException(message);



================================================
FILE: YoutubeExplode/Exceptions/VideoRequiresPurchaseException.cs
================================================
using YoutubeExplode.Videos;

namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown when the requested video requires purchase.
/// </summary>
public class VideoRequiresPurchaseException(string message, VideoId previewVideoId)
    : VideoUnplayableException(message)
{
    /// <summary>
    /// ID of a free preview video which is used as promotion for the original video.
    /// </summary>
    public VideoId PreviewVideoId { get; } = previewVideoId;
}



================================================
FILE: YoutubeExplode/Exceptions/VideoUnavailableException.cs
================================================
namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown when the requested video is unavailable.
/// </summary>
public class VideoUnavailableException(string message) : VideoUnplayableException(message);



================================================
FILE: YoutubeExplode/Exceptions/VideoUnplayableException.cs
================================================
namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown when the requested video is unplayable.
/// </summary>
public class VideoUnplayableException(string message) : YoutubeExplodeException(message);



================================================
FILE: YoutubeExplode/Exceptions/YoutubeExplodeException.cs
================================================
using System;

namespace YoutubeExplode.Exceptions;

/// <summary>
/// Exception thrown within <see cref="YoutubeExplode" />.
/// </summary>
public class YoutubeExplodeException(string message) : Exception(message);



================================================
FILE: YoutubeExplode/Playlists/IPlaylist.cs
================================================
﻿using System.Collections.Generic;
using YoutubeExplode.Common;

namespace YoutubeExplode.Playlists;

/// <summary>
/// Properties shared by playlist metadata resolved from different sources.
/// </summary>
public interface IPlaylist
{
    /// <summary>
    /// Playlist ID.
    /// </summary>
    PlaylistId Id { get; }

    /// <summary>
    /// Playlist URL.
    /// </summary>
    string Url { get; }

    /// <summary>
    /// Playlist title.
    /// </summary>
    string Title { get; }

    /// <summary>
    /// Playlist author.
    /// </summary>
    /// <remarks>
    /// May be null in case of auto-generated playlists (e.g. mixes, topics, etc).
    /// </remarks>
    Author? Author { get; }

    /// <summary>
    /// Playlist thumbnails.
    /// </summary>
    IReadOnlyList<Thumbnail> Thumbnails { get; }
}



================================================
FILE: YoutubeExplode/Playlists/Playlist.cs
================================================
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;

namespace YoutubeExplode.Playlists;

/// <summary>
/// Metadata associated with a YouTube playlist.
/// </summary>
public class Playlist(
    PlaylistId id,
    string title,
    Author? author,
    string description,
    int? count,
    IReadOnlyList<Thumbnail> thumbnails
) : IPlaylist
{
    /// <inheritdoc />
    public PlaylistId Id { get; } = id;

    /// <inheritdoc />
    public string Url => $"https://www.youtube.com/playlist?list={Id}";

    /// <inheritdoc />
    public string Title { get; } = title;

    /// <inheritdoc />
    public Author? Author { get; } = author;

    /// <summary>
    /// Playlist description.
    /// </summary>
    public string Description { get; } = description;

    /// <summary>
    /// Total count of videos included in the playlist.
    /// </summary>
    /// <remarks>
    /// May be null in case of infinite playlists (e.g. auto-generated mixes).
    /// </remarks>
    public int? Count { get; } = count;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Playlist ({Title})";
}



================================================
FILE: YoutubeExplode/Playlists/PlaylistClient.cs
================================================
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Playlists;

/// <summary>
/// Operations related to YouTube playlists.
/// </summary>
public class PlaylistClient(HttpClient http)
{
    private readonly PlaylistController _controller = new(http);

    /// <summary>
    /// Gets the metadata associated with the specified playlist.
    /// </summary>
    public async ValueTask<Playlist> GetAsync(
        PlaylistId playlistId,
        CancellationToken cancellationToken = default
    )
    {
        var response = await _controller.GetPlaylistResponseAsync(playlistId, cancellationToken);

        var title =
            response.Title
            ?? throw new YoutubeExplodeException("Failed to extract the playlist title.");

        // System playlists have no author
        var channelId = response.ChannelId;
        var channelTitle = response.Author;
        var author =
            channelId is not null && channelTitle is not null
                ? new Author(channelId, channelTitle)
                : null;

        // System playlists have no description
        var description = response.Description ?? "";

        var count = response.Count;

        var thumbnails = response
            .Thumbnails.Select(t =>
            {
                var thumbnailUrl =
                    t.Url
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail URL.");

                var thumbnailWidth =
                    t.Width
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail width.");

                var thumbnailHeight =
                    t.Height
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail height.");

                var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                return new Thumbnail(thumbnailUrl, thumbnailResolution);
            })
            .ToArray();

        return new Playlist(playlistId, title, author, description, count, thumbnails);
    }

    /// <summary>
    /// Enumerates batches of videos included in the specified playlist.
    /// </summary>
    public async IAsyncEnumerable<Batch<PlaylistVideo>> GetVideoBatchesAsync(
        PlaylistId playlistId,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        var encounteredIds = new HashSet<VideoId>();
        var lastVideoId = default(VideoId?);
        var lastVideoIndex = 0;
        var visitorData = default(string?);

        do
        {
            var response = await _controller.GetPlaylistNextResponseAsync(
                playlistId,
                lastVideoId,
                lastVideoIndex,
                visitorData,
                cancellationToken
            );

            var videos = new List<PlaylistVideo>();

            foreach (var videoData in response.Videos)
            {
                var videoId =
                    videoData.Id
                    ?? throw new YoutubeExplodeException("Failed to extract the video ID.");

                lastVideoId = videoId;

                lastVideoIndex =
                    videoData.Index
                    ?? throw new YoutubeExplodeException("Failed to extract the video index.");

                // Don't yield the same video twice
                if (!encounteredIds.Add(videoId))
                    continue;

                var videoTitle =
                    videoData.Title
                    // Videos without title are legal
                    // https://github.com/Tyrrrz/YoutubeExplode/issues/700
                    ?? "";

                var videoChannelTitle =
                    videoData.Author
                    ?? throw new YoutubeExplodeException("Failed to extract the video author.");

                var videoChannelId =
                    videoData.ChannelId
                    ?? throw new YoutubeExplodeException("Failed to extract the video channel ID.");

                var videoThumbnails = videoData
                    .Thumbnails.Select(t =>
                    {
                        var thumbnailUrl =
                            t.Url
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the thumbnail URL."
                            );

                        var thumbnailWidth =
                            t.Width
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the thumbnail width."
                            );

                        var thumbnailHeight =
                            t.Height
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the thumbnail height."
                            );

                        var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                        return new Thumbnail(thumbnailUrl, thumbnailResolution);
                    })
                    .Concat(Thumbnail.GetDefaultSet(videoId))
                    .ToArray();

                var video = new PlaylistVideo(
                    playlistId,
                    videoId,
                    videoTitle,
                    new Author(videoChannelId, videoChannelTitle),
                    videoData.Duration,
                    videoThumbnails
                );

                videos.Add(video);
            }

            // Stop extracting if there are no new videos
            if (!videos.Any())
                break;

            yield return Batch.Create(videos);

            visitorData ??= response.VisitorData;
        } while (true);
    }

    /// <summary>
    /// Enumerates videos included in the specified playlist.
    /// </summary>
    public IAsyncEnumerable<PlaylistVideo> GetVideosAsync(
        PlaylistId playlistId,
        CancellationToken cancellationToken = default
    ) => GetVideoBatchesAsync(playlistId, cancellationToken).FlattenAsync();
}



================================================
FILE: YoutubeExplode/Playlists/PlaylistController.cs
================================================
﻿using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Playlists;

internal class PlaylistController(HttpClient http)
{
    // Works only with user-made playlists
    public async ValueTask<PlaylistBrowseResponse> GetPlaylistBrowseResponseAsync(
        PlaylistId playlistId,
        CancellationToken cancellationToken = default
    )
    {
        using var request = new HttpRequestMessage(
            HttpMethod.Post,
            "https://www.youtube.com/youtubei/v1/browse"
        );

        request.Content = new StringContent(
            // lang=json
            $$"""
            {
              "browseId": {{Json.Serialize("VL" + playlistId)}},
              "context": {
                "client": {
                  "clientName": "WEB",
                  "clientVersion": "2.20210408.08.00",
                  "hl": "en",
                  "gl": "US",
                  "utcOffsetMinutes": 0
                }
              }
            }
            """
        );

        using var response = await http.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();

        var playlistResponse = PlaylistBrowseResponse.Parse(
            await response.Content.ReadAsStringAsync(cancellationToken)
        );

        if (!playlistResponse.IsAvailable)
            throw new PlaylistUnavailableException($"Playlist '{playlistId}' is not available.");

        return playlistResponse;
    }

    // Works on all playlists, but contains limited metadata
    public async ValueTask<PlaylistNextResponse> GetPlaylistNextResponseAsync(
        PlaylistId playlistId,
        VideoId? videoId = null,
        int index = 0,
        string? visitorData = null,
        CancellationToken cancellationToken = default
    )
    {
        const int retriesCount = 5;
        for (var retriesRemaining = retriesCount; ; retriesRemaining--)
        {
            using var request = new HttpRequestMessage(
                HttpMethod.Post,
                "https://www.youtube.com/youtubei/v1/next"
            );

            request.Content = new StringContent(
                // lang=json
                $$"""
                {
                  "playlistId": {{Json.Serialize(playlistId)}},
                  "videoId": {{Json.Serialize(videoId)}},
                  "playlistIndex": {{Json.Serialize(index)}},
                  "context": {
                    "client": {
                      "clientName": "WEB",
                      "clientVersion": "2.20210408.08.00",
                      "hl": "en",
                      "gl": "US",
                      "utcOffsetMinutes": 0,
                      "visitorData": {{Json.Serialize(visitorData)}}
                    }
                  }
                }
                """
            );

            using var response = await http.SendAsync(request, cancellationToken);
            response.EnsureSuccessStatusCode();

            var playlistResponse = PlaylistNextResponse.Parse(
                await response.Content.ReadAsStringAsync(cancellationToken)
            );

            if (!playlistResponse.IsAvailable)
            {
                // Retry if this is not the first request, meaning that the previous requests were successful,
                // indicating that it's most likely a transient error.
                if (index > 0 && !string.IsNullOrWhiteSpace(visitorData) && retriesRemaining > 0)
                    continue;

                // Some system playlists are unavailable through this endpoint until their page is opened by
                // at least one user. If this is the first request, and we haven't retried yet, attempt to
                // warm up the playlist by opening its page, and then retry.
                if (
                    index <= 0
                    && string.IsNullOrWhiteSpace(visitorData)
                    && retriesRemaining >= retriesCount
                )
                {
                    using (
                        await http.GetAsync(
                            $"https://youtube.com/playlist?list={playlistId}",
                            cancellationToken
                        )
                    )
                    {
                        // We don't actually care about the outcome of this request
                    }

                    continue;
                }

                throw new PlaylistUnavailableException(
                    $"Playlist '{playlistId}' is not available."
                );
            }

            return playlistResponse;
        }
    }

    public async ValueTask<IPlaylistData> GetPlaylistResponseAsync(
        PlaylistId playlistId,
        CancellationToken cancellationToken = default
    )
    {
        try
        {
            return await GetPlaylistBrowseResponseAsync(playlistId, cancellationToken);
        }
        catch (PlaylistUnavailableException)
        {
            return await GetPlaylistNextResponseAsync(playlistId, null, 0, null, cancellationToken);
        }
    }
}



================================================
FILE: YoutubeExplode/Playlists/PlaylistId.cs
================================================
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Playlists;

/// <summary>
/// Represents a syntactically valid YouTube playlist ID.
/// </summary>
public readonly partial struct PlaylistId(string value)
{
    /// <summary>
    /// Raw ID value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public partial struct PlaylistId
{
    private static bool IsValid(string playlistId) =>
        // Playlist IDs vary greatly in length, but they are at least 2 characters long
        playlistId.Length >= 2
        && playlistId.All(c => char.IsLetterOrDigit(c) || c is '_' or '-');

    private static string? TryNormalize(string? playlistIdOrUrl)
    {
        if (string.IsNullOrWhiteSpace(playlistIdOrUrl))
            return null;

        // Check if already passed an ID
        // PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H
        if (IsValid(playlistIdOrUrl))
            return playlistIdOrUrl;

        // Try to extract the ID from the URL
        // https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H
        {
            var id = Regex
                .Match(playlistIdOrUrl, @"youtube\..+?/playlist.*?list=(.*?)(?:&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (playlist + video)
        // https://www.youtube.com/watch?v=b8m9zhNAgKs&list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr
        {
            var id = Regex
                .Match(playlistIdOrUrl, @"youtube\..+?/watch.*?list=(.*?)(?:&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (playlist + video, shortened)
        // https://youtu.be/b8m9zhNAgKs/?list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr
        {
            var id = Regex
                .Match(playlistIdOrUrl, @"youtu\.be/.*?/.*?list=(.*?)(?:&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (playlist + video, embedded)
        // https://www.youtube.com/embed/b8m9zhNAgKs/?list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr
        {
            var id = Regex
                .Match(playlistIdOrUrl, @"youtube\..+?/embed/.*?/.*?list=(.*?)(?:&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a YouTube playlist ID or URL.
    /// Returns null in case of failure.
    /// </summary>
    public static PlaylistId? TryParse(string? playlistIdOrUrl) =>
        TryNormalize(playlistIdOrUrl)?.Pipe(id => new PlaylistId(id));

    /// <summary>
    /// Parses the specified string as a YouTube playlist ID or URL.
    /// </summary>
    public static PlaylistId Parse(string playlistIdOrUrl) =>
        TryParse(playlistIdOrUrl)
        ?? throw new ArgumentException($"Invalid YouTube playlist ID or URL '{playlistIdOrUrl}'.");

    /// <summary>
    /// Converts string to ID.
    /// </summary>
    public static implicit operator PlaylistId(string playlistIdOrUrl) => Parse(playlistIdOrUrl);

    /// <summary>
    /// Converts ID to string.
    /// </summary>
    public static implicit operator string(PlaylistId playlistId) => playlistId.ToString();
}

public partial struct PlaylistId : IEquatable<PlaylistId>
{
    /// <inheritdoc />
    public bool Equals(PlaylistId other) => StringComparer.Ordinal.Equals(Value, other.Value);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is PlaylistId other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.Ordinal.GetHashCode(Value);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(PlaylistId left, PlaylistId right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(PlaylistId left, PlaylistId right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Playlists/PlaylistVideo.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Playlists;

/// <summary>
/// Metadata associated with a YouTube video included in a playlist.
/// </summary>
public class PlaylistVideo(
    PlaylistId playlistId,
    VideoId id,
    string title,
    Author author,
    TimeSpan? duration,
    IReadOnlyList<Thumbnail> thumbnails
) : IVideo, IBatchItem
{
    /// <summary>
    /// Initializes an instance of <see cref="PlaylistVideo" />.
    /// </summary>
    // Binary backwards compatibility (PlaylistId was added)
    [Obsolete("Use the other constructor instead."), ExcludeFromCodeCoverage]
    public PlaylistVideo(
        VideoId id,
        string title,
        Author author,
        TimeSpan? duration,
        IReadOnlyList<Thumbnail> thumbnails
    )
        : this(default, id, title, author, duration, thumbnails) { }

    /// <summary>
    /// ID of the playlist that contains this video.
    /// </summary>
    public PlaylistId PlaylistId { get; } = playlistId;

    /// <inheritdoc />
    public VideoId Id { get; } = id;

    /// <inheritdoc />
    public string Url => $"https://www.youtube.com/watch?v={Id}&list={PlaylistId}";

    /// <inheritdoc />
    public string Title { get; } = title;

    /// <inheritdoc />
    public Author Author { get; } = author;

    /// <inheritdoc />
    public TimeSpan? Duration { get; } = duration;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Video ({Title})";
}



================================================
FILE: YoutubeExplode/Search/ChannelSearchResult.cs
================================================
﻿using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Channels;
using YoutubeExplode.Common;

namespace YoutubeExplode.Search;

/// <summary>
/// Metadata associated with a YouTube channel returned by a search query.
/// </summary>
public class ChannelSearchResult(ChannelId id, string title, IReadOnlyList<Thumbnail> thumbnails)
    : ISearchResult,
        IChannel
{
    /// <inheritdoc />
    public ChannelId Id { get; } = id;

    /// <inheritdoc cref="IChannel.Url" />
    public string Url => $"https://www.youtube.com/channel/{Id}";

    /// <inheritdoc cref="IChannel.Title" />
    public string Title { get; } = title;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Channel ({Title})";
}



================================================
FILE: YoutubeExplode/Search/ISearchResult.cs
================================================
﻿using YoutubeExplode.Common;

namespace YoutubeExplode.Search;

/// <summary>
/// <p>
///     Abstract result returned by a search query.
///     Use pattern matching to handle specific instances of this type.
/// </p>
/// <p>
///     Can be either one of the following:
///     <list type="bullet">
///         <item><see cref="VideoSearchResult" /></item>
///         <item><see cref="PlaylistSearchResult" /></item>
///         <item><see cref="ChannelSearchResult" /></item>
///     </list>
/// </p>
/// </summary>
public interface ISearchResult : IBatchItem
{
    /// <summary>
    /// Result URL.
    /// </summary>
    string Url { get; }

    /// <summary>
    /// Result title.
    /// </summary>
    string Title { get; }
}



================================================
FILE: YoutubeExplode/Search/PlaylistSearchResult.cs
================================================
﻿using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;
using YoutubeExplode.Playlists;

namespace YoutubeExplode.Search;

/// <summary>
/// Metadata associated with a YouTube playlist returned by a search query.
/// </summary>
public class PlaylistSearchResult(
    PlaylistId id,
    string title,
    Author? author,
    IReadOnlyList<Thumbnail> thumbnails
) : ISearchResult, IPlaylist
{
    /// <inheritdoc />
    public PlaylistId Id { get; } = id;

    /// <inheritdoc cref="IPlaylist.Url" />
    public string Url => $"https://www.youtube.com/playlist?list={Id}";

    /// <inheritdoc cref="IPlaylist.Title" />
    public string Title { get; } = title;

    /// <inheritdoc />
    public Author? Author { get; } = author;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Playlist ({Title})";
}



================================================
FILE: YoutubeExplode/Search/SearchClient.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Search;

/// <summary>
/// Operations related to YouTube search.
/// </summary>
public class SearchClient(HttpClient http)
{
    private readonly SearchController _controller = new(http);

    /// <summary>
    /// Enumerates batches of search results returned by the specified query.
    /// </summary>
    public async IAsyncEnumerable<Batch<ISearchResult>> GetResultBatchesAsync(
        string searchQuery,
        SearchFilter searchFilter,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        var encounteredIds = new HashSet<string>(StringComparer.Ordinal);
        var continuationToken = default(string?);

        do
        {
            var results = new List<ISearchResult>();

            var searchResults = await _controller.GetSearchResponseAsync(
                searchQuery,
                searchFilter,
                continuationToken,
                cancellationToken
            );

            // Video results
            foreach (var videoData in searchResults.Videos)
            {
                if (searchFilter is not SearchFilter.None and not SearchFilter.Video)
                {
                    Debug.Fail("Did not expect videos in search results.");
                    break;
                }

                var videoId =
                    videoData.Id
                    ?? throw new YoutubeExplodeException("Failed to extract the video ID.");

                // Don't yield the same result twice
                if (!encounteredIds.Add(videoId))
                    continue;

                var videoTitle =
                    videoData.Title
                    ?? throw new YoutubeExplodeException("Failed to extract the video title.");

                var videoChannelTitle =
                    videoData.Author
                    ?? throw new YoutubeExplodeException("Failed to extract the video author.");

                var videoChannelId =
                    videoData.ChannelId
                    ?? throw new YoutubeExplodeException("Failed to extract the video channel ID.");

                var videoThumbnails = videoData
                    .Thumbnails.Select(t =>
                    {
                        var thumbnailUrl =
                            t.Url
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the video thumbnail URL."
                            );

                        var thumbnailWidth =
                            t.Width
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the video thumbnail width."
                            );

                        var thumbnailHeight =
                            t.Height
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the video thumbnail height."
                            );

                        var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                        return new Thumbnail(thumbnailUrl, thumbnailResolution);
                    })
                    .Concat(Thumbnail.GetDefaultSet(videoId))
                    .ToArray();

                var video = new VideoSearchResult(
                    videoId,
                    videoTitle,
                    new Author(videoChannelId, videoChannelTitle),
                    videoData.Duration,
                    videoThumbnails
                );

                results.Add(video);
            }

            // Playlist results
            foreach (var playlistData in searchResults.Playlists)
            {
                if (searchFilter is not SearchFilter.None and not SearchFilter.Playlist)
                {
                    Debug.Fail("Did not expect playlists in search results.");
                    break;
                }

                var playlistId =
                    playlistData.Id
                    ?? throw new YoutubeExplodeException("Failed to extract the playlist ID.");

                // Don't yield the same result twice
                if (!encounteredIds.Add(playlistId))
                    continue;

                var playlistTitle =
                    playlistData.Title
                    ?? throw new YoutubeExplodeException("Failed to extract the playlist title.");

                // System playlists have no author
                var playlistAuthor =
                    !string.IsNullOrWhiteSpace(playlistData.ChannelId)
                    && !string.IsNullOrWhiteSpace(playlistData.Author)
                        ? new Author(playlistData.ChannelId, playlistData.Author)
                        : null;

                var playlistThumbnails = playlistData
                    .Thumbnails.Select(t =>
                    {
                        var thumbnailUrl =
                            t.Url
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the playlist thumbnail URL."
                            );

                        var thumbnailWidth =
                            t.Width
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the playlist thumbnail width."
                            );

                        var thumbnailHeight =
                            t.Height
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the playlist thumbnail height."
                            );

                        var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                        return new Thumbnail(thumbnailUrl, thumbnailResolution);
                    })
                    .ToArray();

                var playlist = new PlaylistSearchResult(
                    playlistId,
                    playlistTitle,
                    playlistAuthor,
                    playlistThumbnails
                );

                results.Add(playlist);
            }

            // Channel results
            foreach (var channelData in searchResults.Channels)
            {
                if (searchFilter is not SearchFilter.None and not SearchFilter.Channel)
                {
                    Debug.Fail("Did not expect channels in search results.");
                    break;
                }

                var channelId =
                    channelData.Id
                    ?? throw new YoutubeExplodeException("Failed to extract the channel ID.");

                var channelTitle =
                    channelData.Title
                    ?? throw new YoutubeExplodeException("Failed to extract the channel title.");

                var channelThumbnails = channelData
                    .Thumbnails.Select(t =>
                    {
                        var thumbnailUrl =
                            t.Url
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the channel thumbnail URL."
                            );

                        var thumbnailWidth =
                            t.Width
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the channel thumbnail width."
                            );

                        var thumbnailHeight =
                            t.Height
                            ?? throw new YoutubeExplodeException(
                                "Failed to extract the channel thumbnail height."
                            );

                        var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                        return new Thumbnail(thumbnailUrl, thumbnailResolution);
                    })
                    .ToArray();

                var channel = new ChannelSearchResult(channelId, channelTitle, channelThumbnails);

                results.Add(channel);
            }

            yield return Batch.Create(results);

            continuationToken = searchResults.ContinuationToken;
        } while (!string.IsNullOrWhiteSpace(continuationToken));
    }

    /// <summary>
    /// Enumerates batches of search results returned by the specified query.
    /// </summary>
    public IAsyncEnumerable<Batch<ISearchResult>> GetResultBatchesAsync(
        string searchQuery,
        CancellationToken cancellationToken = default
    ) => GetResultBatchesAsync(searchQuery, SearchFilter.None, cancellationToken);

    /// <summary>
    /// Enumerates search results returned by the specified query.
    /// </summary>
    public IAsyncEnumerable<ISearchResult> GetResultsAsync(
        string searchQuery,
        CancellationToken cancellationToken = default
    ) => GetResultBatchesAsync(searchQuery, cancellationToken).FlattenAsync();

    /// <summary>
    /// Enumerates video search results returned by the specified query.
    /// </summary>
    public IAsyncEnumerable<VideoSearchResult> GetVideosAsync(
        string searchQuery,
        CancellationToken cancellationToken = default
    ) =>
        GetResultBatchesAsync(searchQuery, SearchFilter.Video, cancellationToken)
            .FlattenAsync()
            .OfTypeAsync<VideoSearchResult>();

    /// <summary>
    /// Enumerates playlist search results returned by the specified query.
    /// </summary>
    public IAsyncEnumerable<PlaylistSearchResult> GetPlaylistsAsync(
        string searchQuery,
        CancellationToken cancellationToken = default
    ) =>
        GetResultBatchesAsync(searchQuery, SearchFilter.Playlist, cancellationToken)
            .FlattenAsync()
            .OfTypeAsync<PlaylistSearchResult>();

    /// <summary>
    /// Enumerates channel search results returned by the specified query.
    /// </summary>
    public IAsyncEnumerable<ChannelSearchResult> GetChannelsAsync(
        string searchQuery,
        CancellationToken cancellationToken = default
    ) =>
        GetResultBatchesAsync(searchQuery, SearchFilter.Channel, cancellationToken)
            .FlattenAsync()
            .OfTypeAsync<ChannelSearchResult>();
}



================================================
FILE: YoutubeExplode/Search/SearchController.cs
================================================
﻿using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Utils;

namespace YoutubeExplode.Search;

internal class SearchController(HttpClient http)
{
    public async ValueTask<SearchResponse> GetSearchResponseAsync(
        string searchQuery,
        SearchFilter searchFilter,
        string? continuationToken,
        CancellationToken cancellationToken = default
    )
    {
        using var request = new HttpRequestMessage(
            HttpMethod.Post,
            "https://www.youtube.com/youtubei/v1/search"
        );

        request.Content = new StringContent(
            // lang=json
            $$"""
            {
              "query": {{Json.Serialize(searchQuery)}},
              "params": {{Json.Serialize(searchFilter switch
              {
                  SearchFilter.Video => "EgIQAQ%3D%3D",
                  SearchFilter.Playlist => "EgIQAw%3D%3D",
                  SearchFilter.Channel => "EgIQAg%3D%3D",
                  _ => null
              })}},
              "continuation": {{Json.Serialize(continuationToken)}},
              "context": {
                "client": {
                  "clientName": "WEB",
                  "clientVersion": "2.20210408.08.00",
                  "hl": "en",
                  "gl": "US",
                  "utcOffsetMinutes": 0
                }
              }
            }
            """
        );

        using var response = await http.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();

        return SearchResponse.Parse(await response.Content.ReadAsStringAsync(cancellationToken));
    }
}



================================================
FILE: YoutubeExplode/Search/SearchFilter.cs
================================================
﻿namespace YoutubeExplode.Search;

/// <summary>
/// Filter applied to a YouTube search query.
/// </summary>
public enum SearchFilter
{
    /// <summary>
    /// No filter applied.
    /// </summary>
    None,

    /// <summary>
    /// Only search for videos.
    /// </summary>
    Video,

    /// <summary>
    /// Only search for playlists.
    /// </summary>
    Playlist,

    /// <summary>
    /// Only search for channels.
    /// </summary>
    Channel,
}



================================================
FILE: YoutubeExplode/Search/VideoSearchResult.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Search;

/// <summary>
/// Metadata associated with a YouTube video returned by a search query.
/// </summary>
public class VideoSearchResult(
    VideoId id,
    string title,
    Author author,
    TimeSpan? duration,
    IReadOnlyList<Thumbnail> thumbnails
) : ISearchResult, IVideo
{
    /// <inheritdoc />
    public VideoId Id { get; } = id;

    /// <inheritdoc cref="IVideo.Url" />
    public string Url => $"https://www.youtube.com/watch?v={Id}";

    /// <inheritdoc cref="IVideo.Title" />
    public string Title { get; } = title;

    /// <inheritdoc />
    public Author Author { get; } = author;

    /// <inheritdoc />
    public TimeSpan? Duration { get; } = duration;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Video ({Title})";
}



================================================
FILE: YoutubeExplode/Utils/ClientDelegatingHandler.cs
================================================
﻿using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Utils;

// Like DelegatingHandler, but wraps an HttpClient instead of an HttpMessageHandler.
// Used to extend an externally provided HttpClient with additional behavior.
internal abstract class ClientDelegatingHandler(HttpClient http, bool disposeClient = false)
    : HttpMessageHandler
{
    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken
    )
    {
        // Clone the request to reset its completion status, which is required
        // in order to pass the request from one HttpClient to another.
        using var clonedRequest = request.Clone();

        return await http.SendAsync(
            clonedRequest,
            HttpCompletionOption.ResponseHeadersRead,
            cancellationToken
        );
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing && disposeClient)
            http.Dispose();

        base.Dispose(disposing);
    }
}



================================================
FILE: YoutubeExplode/Utils/Hash.cs
================================================
﻿using System.Security.Cryptography;

namespace YoutubeExplode.Utils;

internal static class Hash
{
    public static byte[] Compute(HashAlgorithm algorithm, byte[] data)
    {
        using (algorithm)
            return algorithm.ComputeHash(data);
    }
}



================================================
FILE: YoutubeExplode/Utils/Html.cs
================================================
using AngleSharp.Html.Dom;
using AngleSharp.Html.Parser;

namespace YoutubeExplode.Utils;

internal static class Html
{
    private static readonly HtmlParser HtmlParser = new();

    public static IHtmlDocument Parse(string source) => HtmlParser.ParseDocument(source);
}



================================================
FILE: YoutubeExplode/Utils/Http.cs
================================================
﻿using System;
using System.Net.Http;

namespace YoutubeExplode.Utils;

internal static class Http
{
    private static readonly Lazy<HttpClient> HttpClientLazy = new(() => new HttpClient());

    public static HttpClient Client => HttpClientLazy.Value;
}



================================================
FILE: YoutubeExplode/Utils/Json.cs
================================================
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace YoutubeExplode.Utils;

internal static class Json
{
    public static string Extract(string source)
    {
        var buffer = new StringBuilder();

        var depth = 0;
        var isInsideString = false;

        // We trust that the source contains valid json, we just need to extract it.
        // To do it, we will be matching curly braces until we even out.
        foreach (var (i, ch) in source.Index())
        {
            var prev = i > 0 ? source[i - 1] : default;

            buffer.Append(ch);

            // Detect if inside a string
            if (ch == '"' && prev != '\\')
                isInsideString = !isInsideString;
            // Opening brace
            else if (ch == '{' && !isInsideString)
                depth++;
            // Closing brace
            else if (ch == '}' && !isInsideString)
                depth--;

            // Break when evened out
            if (depth == 0)
                break;
        }

        return buffer.ToString();
    }

    public static JsonElement Parse(string source)
    {
        using var document = JsonDocument.Parse(source);
        return document.RootElement.Clone();
    }

    public static JsonElement? TryParse(string source)
    {
        try
        {
            return Parse(source);
        }
        catch (JsonException)
        {
            return null;
        }
    }

    public static string Encode(string value)
    {
        var buffer = new StringBuilder(value.Length);

        foreach (var c in value)
        {
            if (c == '\n')
                buffer.Append("\\n");
            else if (c == '\r')
                buffer.Append("\\r");
            else if (c == '\t')
                buffer.Append("\\t");
            else if (c == '\\')
                buffer.Append("\\\\");
            else if (c == '"')
                buffer.Append("\\\"");
            else
                buffer.Append(c);
        }

        return buffer.ToString();
    }

    // AOT-compatible serialization
    public static string Serialize(string? value) =>
        value is not null ? '"' + Encode(value) + '"' : "null";

    // AOT-compatible serialization
    public static string Serialize(int? value) =>
        value is not null ? value.Value.ToString(CultureInfo.InvariantCulture) : "null";
}



================================================
FILE: YoutubeExplode/Utils/UrlEx.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Utils;

internal static class UrlEx
{
    private static IEnumerable<KeyValuePair<string, string>> EnumerateQueryParameters(string url)
    {
        var query = url.Contains('?') ? url.SubstringAfter("?") : url;

        foreach (var parameter in query.Split('&'))
        {
            var key = WebUtility.UrlDecode(parameter.SubstringUntil("="));
            var value = WebUtility.UrlDecode(parameter.SubstringAfter("="));

            if (string.IsNullOrWhiteSpace(key))
                continue;

            yield return new KeyValuePair<string, string>(key, value);
        }
    }

    public static IReadOnlyDictionary<string, string> GetQueryParameters(string url) =>
        EnumerateQueryParameters(url).ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

    private static KeyValuePair<string, string>? TryGetQueryParameter(string url, string key)
    {
        foreach (var parameter in EnumerateQueryParameters(url))
        {
            if (string.Equals(parameter.Key, key, StringComparison.Ordinal))
                return parameter;
        }

        return null;
    }

    public static string? TryGetQueryParameterValue(string url, string key) =>
        TryGetQueryParameter(url, key)?.Value;

    public static bool ContainsQueryParameter(string url, string key) =>
        TryGetQueryParameterValue(url, key) is not null;

    public static string RemoveQueryParameter(string url, string key)
    {
        if (!ContainsQueryParameter(url, key))
            return url;

        var urlBuilder = new UriBuilder(url);
        var queryBuilder = new StringBuilder();

        foreach (var parameter in EnumerateQueryParameters(url))
        {
            if (string.Equals(parameter.Key, key, StringComparison.Ordinal))
                continue;

            queryBuilder.Append(queryBuilder.Length > 0 ? '&' : '?');

            queryBuilder.Append(Uri.EscapeDataString(parameter.Key));
            queryBuilder.Append('=');
            queryBuilder.Append(Uri.EscapeDataString(parameter.Value));
        }

        urlBuilder.Query = queryBuilder.ToString();

        return urlBuilder.ToString();
    }

    public static string SetQueryParameter(string url, string key, string value)
    {
        var urlWithoutParameter = RemoveQueryParameter(url, key);
        var hasOtherParameters = urlWithoutParameter.Contains('?');

        return urlWithoutParameter
            + (hasOtherParameters ? '&' : '?')
            + Uri.EscapeDataString(key)
            + '='
            + Uri.EscapeDataString(value);
    }
}



================================================
FILE: YoutubeExplode/Utils/Xml.cs
================================================
using System.Xml.Linq;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Utils;

internal static class Xml
{
    public static XElement Parse(string source) =>
        XElement.Parse(source, LoadOptions.PreserveWhitespace).StripNamespaces();
}



================================================
FILE: YoutubeExplode/Utils/Extensions/AsyncCollectionExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace YoutubeExplode.Utils.Extensions;

internal static class AsyncCollectionExtensions
{
    public static async IAsyncEnumerable<T> TakeAsync<T>(this IAsyncEnumerable<T> source, int count)
    {
        var currentCount = 0;

        await foreach (var i in source)
        {
            if (currentCount >= count)
                yield break;

            yield return i;
            currentCount++;
        }
    }

    public static async IAsyncEnumerable<T> SelectManyAsync<TSource, T>(
        this IAsyncEnumerable<TSource> source,
        Func<TSource, IEnumerable<T>> transform
    )
    {
        await foreach (var i in source)
        {
            foreach (var j in transform(i))
                yield return j;
        }
    }

    public static async IAsyncEnumerable<T> OfTypeAsync<T>(this IAsyncEnumerable<object> source)
    {
        await foreach (var i in source)
        {
            if (i is T match)
                yield return match;
        }
    }

    public static async ValueTask<List<T>> ToListAsync<T>(this IAsyncEnumerable<T> source)
    {
        var list = new List<T>();

        await foreach (var i in source)
            list.Add(i);

        return list;
    }

    public static ValueTaskAwaiter<List<T>> GetAwaiter<T>(this IAsyncEnumerable<T> source) =>
        source.ToListAsync().GetAwaiter();
}



================================================
FILE: YoutubeExplode/Utils/Extensions/BinaryExtensions.cs
================================================
﻿using System.Globalization;
using System.Text;

namespace YoutubeExplode.Utils.Extensions;

internal static class BinaryExtensions
{
    public static string ToHex(this byte[] data, bool isUpperCase = true)
    {
        var buffer = new StringBuilder(2 * data.Length);

        foreach (var b in data)
        {
            buffer.Append(b.ToString(isUpperCase ? "X2" : "x2", CultureInfo.InvariantCulture));
        }

        return buffer.ToString();
    }
}



================================================
FILE: YoutubeExplode/Utils/Extensions/CollectionExtensions.cs
================================================
﻿using System.Collections.Generic;
using System.Linq;

namespace YoutubeExplode.Utils.Extensions;

internal static class CollectionExtensions
{
    public static IEnumerable<T> WhereNotNull<T>(this IEnumerable<T?> source)
        where T : class
    {
        foreach (var i in source)
        {
            if (i is not null)
                yield return i;
        }
    }

    public static IEnumerable<T> WhereNotNull<T>(this IEnumerable<T?> source)
        where T : struct
    {
        foreach (var i in source)
        {
            if (i is not null)
                yield return i.Value;
        }
    }

    public static T? ElementAtOrNull<T>(this IEnumerable<T> source, int index)
        where T : struct
    {
        var sourceAsList = source as IReadOnlyList<T> ?? source.ToArray();
        return index < sourceAsList.Count ? sourceAsList[index] : null;
    }

    public static T? FirstOrNull<T>(this IEnumerable<T> source)
        where T : struct
    {
        foreach (var i in source)
            return i;

        return null;
    }
}



================================================
FILE: YoutubeExplode/Utils/Extensions/GenericExtensions.cs
================================================
using System;

namespace YoutubeExplode.Utils.Extensions;

internal static class GenericExtensions
{
    public static TOut Pipe<TIn, TOut>(this TIn input, Func<TIn, TOut> transform) =>
        transform(input);
}



================================================
FILE: YoutubeExplode/Utils/Extensions/HttpExtensions.cs
================================================
﻿using System.IO;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace YoutubeExplode.Utils.Extensions;

internal static class HttpExtensions
{
    private class NonDisposableHttpContent(HttpContent content) : HttpContent
    {
        protected override async Task SerializeToStreamAsync(
            Stream stream,
            TransportContext? context
        ) => await content.CopyToAsync(stream);

        protected override bool TryComputeLength(out long length)
        {
            length = default;
            return false;
        }
    }

    public static HttpRequestMessage Clone(this HttpRequestMessage request)
    {
        var clonedRequest = new HttpRequestMessage(request.Method, request.RequestUri)
        {
            Version = request.Version,
            // Don't dispose the original request's content
            Content = request.Content is not null
                ? new NonDisposableHttpContent(request.Content)
                : null,
        };

        foreach (var (key, value) in request.Headers)
            clonedRequest.Headers.TryAddWithoutValidation(key, value);

        if (request.Content is not null && clonedRequest.Content is not null)
        {
            foreach (var (key, value) in request.Content.Headers)
                clonedRequest.Content.Headers.TryAddWithoutValidation(key, value);
        }

        return clonedRequest;
    }

    public static async ValueTask<HttpResponseMessage> HeadAsync(
        this HttpClient http,
        string requestUri,
        CancellationToken cancellationToken = default
    )
    {
        using var request = new HttpRequestMessage(HttpMethod.Head, requestUri);

        return await http.SendAsync(
            request,
            HttpCompletionOption.ResponseHeadersRead,
            cancellationToken
        );
    }
}



================================================
FILE: YoutubeExplode/Utils/Extensions/JsonExtensions.cs
================================================
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;

namespace YoutubeExplode.Utils.Extensions;

internal static class JsonExtensions
{
    public static JsonElement? GetPropertyOrNull(this JsonElement element, string propertyName)
    {
        if (element.ValueKind != JsonValueKind.Object)
        {
            return null;
        }

        if (
            element.TryGetProperty(propertyName, out var result)
            && result.ValueKind != JsonValueKind.Null
            && result.ValueKind != JsonValueKind.Undefined
        )
        {
            return result;
        }

        return null;
    }

    public static bool? GetBooleanOrNull(this JsonElement element) =>
        element.ValueKind switch
        {
            JsonValueKind.True => true,
            JsonValueKind.False => false,
            _ => null,
        };

    public static string? GetStringOrNull(this JsonElement element) =>
        element.ValueKind == JsonValueKind.String ? element.GetString() : null;

    public static int? GetInt32OrNull(this JsonElement element) =>
        element.ValueKind == JsonValueKind.Number && element.TryGetInt32(out var result)
            ? result
            : null;

    public static long? GetInt64OrNull(this JsonElement element) =>
        element.ValueKind == JsonValueKind.Number && element.TryGetInt64(out var result)
            ? result
            : null;

    public static JsonElement.ArrayEnumerator? EnumerateArrayOrNull(this JsonElement element) =>
        element.ValueKind == JsonValueKind.Array ? element.EnumerateArray() : null;

    public static JsonElement.ArrayEnumerator EnumerateArrayOrEmpty(this JsonElement element) =>
        element.EnumerateArrayOrNull() ?? default;

    public static JsonElement.ObjectEnumerator? EnumerateObjectOrNull(this JsonElement element) =>
        element.ValueKind == JsonValueKind.Object ? element.EnumerateObject() : null;

    public static JsonElement.ObjectEnumerator EnumerateObjectOrEmpty(this JsonElement element) =>
        element.EnumerateObjectOrNull() ?? default;

    public static IEnumerable<JsonElement> EnumerateDescendantProperties(
        this JsonElement element,
        string propertyName
    )
    {
        // Check if this property exists on the current object
        var property = element.GetPropertyOrNull(propertyName);
        if (property is not null)
            yield return property.Value;

        // Recursively check on all array children (if current element is an array)
        var deepArrayDescendants = element
            .EnumerateArrayOrEmpty()
            .SelectMany(j => j.EnumerateDescendantProperties(propertyName));

        foreach (var deepDescendant in deepArrayDescendants)
            yield return deepDescendant;

        // Recursively check on all object children (if current element is an object)
        var deepObjectDescendants = element
            .EnumerateObjectOrEmpty()
            .SelectMany(j => j.Value.EnumerateDescendantProperties(propertyName));

        foreach (var deepDescendant in deepObjectDescendants)
            yield return deepDescendant;
    }
}



================================================
FILE: YoutubeExplode/Utils/Extensions/StreamExtensions.cs
================================================
using System;
using System.Buffers;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace YoutubeExplode.Utils.Extensions;

internal static class StreamExtensions
{
    public static async ValueTask CopyToAsync(
        this Stream source,
        Stream destination,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        using var buffer = MemoryPool<byte>.Shared.Rent(81920);

        var totalBytesRead = 0L;
        while (true)
        {
            var bytesRead = await source.ReadAsync(buffer.Memory, cancellationToken);
            if (bytesRead <= 0)
                break;

            await destination.WriteAsync(buffer.Memory[..bytesRead], cancellationToken);

            totalBytesRead += bytesRead;
            progress?.Report(1.0 * totalBytesRead / source.Length);
        }
    }
}



================================================
FILE: YoutubeExplode/Utils/Extensions/StringExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace YoutubeExplode.Utils.Extensions;

internal static class StringExtensions
{
    public static string? NullIfWhiteSpace(this string str) =>
        !string.IsNullOrWhiteSpace(str) ? str : null;

    public static string SubstringUntil(
        this string str,
        string sub,
        StringComparison comparison = StringComparison.Ordinal
    )
    {
        var index = str.IndexOf(sub, comparison);
        return index < 0 ? str : str[..index];
    }

    public static string SubstringAfter(
        this string str,
        string sub,
        StringComparison comparison = StringComparison.Ordinal
    )
    {
        var index = str.IndexOf(sub, comparison);

        return index < 0
            ? string.Empty
            : str.Substring(index + sub.Length, str.Length - index - sub.Length);
    }

    public static string StripNonDigit(this string str)
    {
        var buffer = new StringBuilder();

        foreach (var c in str.Where(char.IsDigit))
            buffer.Append(c);

        return buffer.ToString();
    }

    public static string Reverse(this string str)
    {
        var buffer = new StringBuilder(str.Length);

        for (var i = str.Length - 1; i >= 0; i--)
            buffer.Append(str[i]);

        return buffer.ToString();
    }

    public static string SwapChars(this string str, int firstCharIndex, int secondCharIndex) =>
        new StringBuilder(str)
        {
            [firstCharIndex] = str[secondCharIndex],
            [secondCharIndex] = str[firstCharIndex],
        }.ToString();

    public static int? ParseIntOrNull(this string str) =>
        int.TryParse(str, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out var result)
            ? result
            : null;

    public static int ParseInt(this string str) =>
        ParseIntOrNull(str)
        ?? throw new FormatException($"Cannot parse integer number from string '{str}'.");

    public static long? ParseLongOrNull(this string str) =>
        long.TryParse(str, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out var result)
            ? result
            : null;

    public static double? ParseDoubleOrNull(this string str) =>
        double.TryParse(
            str,
            NumberStyles.Float | NumberStyles.AllowThousands,
            NumberFormatInfo.InvariantInfo,
            out var result
        )
            ? result
            : null;

    public static TimeSpan? ParseTimeSpanOrNull(this string str, string[] formats) =>
        TimeSpan.TryParseExact(str, formats, DateTimeFormatInfo.InvariantInfo, out var result)
            ? result
            : null;

    public static DateTimeOffset? ParseDateTimeOffsetOrNull(this string str) =>
        DateTimeOffset.TryParse(
            str,
            DateTimeFormatInfo.InvariantInfo,
            DateTimeStyles.None,
            out var result
        )
            ? result
            : null;

    public static string ConcatToString<T>(this IEnumerable<T> source) => string.Concat(source);
}



================================================
FILE: YoutubeExplode/Utils/Extensions/UriExtensions.cs
================================================
﻿using System;

namespace YoutubeExplode.Utils.Extensions;

internal static class UriExtensions
{
    public static string GetDomain(this Uri uri) => uri.Scheme + Uri.SchemeDelimiter + uri.Host;
}



================================================
FILE: YoutubeExplode/Utils/Extensions/XElementExtensions.cs
================================================
using System.Linq;
using System.Xml.Linq;

namespace YoutubeExplode.Utils.Extensions;

internal static class XElementExtensions
{
    public static XElement StripNamespaces(this XElement element)
    {
        // Adapted from http://stackoverflow.com/a/1147012

        var result = new XElement(element);

        foreach (var descendantElement in result.DescendantsAndSelf())
        {
            descendantElement.Name = XNamespace.None.GetName(descendantElement.Name.LocalName);

            descendantElement.ReplaceAttributes(
                descendantElement
                    .Attributes()
                    .Where(a => !a.IsNamespaceDeclaration)
                    .Where(a =>
                        a.Name.Namespace != XNamespace.Xml && a.Name.Namespace != XNamespace.Xmlns
                    )
                    .Select(a => new XAttribute(XNamespace.None.GetName(a.Name.LocalName), a.Value))
            );
        }

        return result;
    }
}



================================================
FILE: YoutubeExplode/Videos/Engagement.cs
================================================
using System.Diagnostics.CodeAnalysis;

namespace YoutubeExplode.Videos;

/// <summary>
/// Engagement statistics.
/// </summary>
public class Engagement(long viewCount, long likeCount, long dislikeCount)
{
    /// <summary>
    /// View count.
    /// </summary>
    public long ViewCount { get; } = viewCount;

    /// <summary>
    /// Like count.
    /// </summary>
    public long LikeCount { get; } = likeCount;

    /// <summary>
    /// Dislike count.
    /// </summary>
    /// <remarks>
    /// YouTube no longer shows dislikes, so this value is always 0.
    /// </remarks>
    public long DislikeCount { get; } = dislikeCount;

    /// <summary>
    /// Average rating.
    /// </summary>
    /// <remarks>
    /// YouTube no longer shows dislikes, so this value is always 5.
    /// </remarks>
    public double AverageRating =>
        LikeCount + DislikeCount != 0 ? 1 + 4.0 * LikeCount / (LikeCount + DislikeCount) : 0; // avoid division by 0

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Rating: {AverageRating:N1}";
}



================================================
FILE: YoutubeExplode/Videos/IVideo.cs
================================================
﻿using System;
using System.Collections.Generic;
using YoutubeExplode.Common;

namespace YoutubeExplode.Videos;

/// <summary>
/// Properties shared by video metadata resolved from different sources.
/// </summary>
public interface IVideo
{
    /// <summary>
    /// Video ID.
    /// </summary>
    VideoId Id { get; }

    /// <summary>
    /// Video URL.
    /// </summary>
    string Url { get; }

    /// <summary>
    /// Video title.
    /// </summary>
    string Title { get; }

    /// <summary>
    /// Video author.
    /// </summary>
    Author Author { get; }

    /// <summary>
    /// Video duration.
    /// </summary>
    /// <remarks>
    /// May be null if the video is a currently ongoing live stream.
    /// </remarks>
    TimeSpan? Duration { get; }

    /// <summary>
    /// Video thumbnails.
    /// </summary>
    IReadOnlyList<Thumbnail> Thumbnails { get; }
}



================================================
FILE: YoutubeExplode/Videos/Video.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;

namespace YoutubeExplode.Videos;

/// <summary>
/// Metadata associated with a YouTube video.
/// </summary>
public class Video(
    VideoId id,
    string title,
    Author author,
    DateTimeOffset uploadDate,
    string description,
    TimeSpan? duration,
    IReadOnlyList<Thumbnail> thumbnails,
    IReadOnlyList<string> keywords,
    Engagement engagement
) : IVideo
{
    /// <inheritdoc />
    public VideoId Id { get; } = id;

    /// <inheritdoc />
    public string Url => $"https://www.youtube.com/watch?v={Id}";

    /// <inheritdoc />
    public string Title { get; } = title;

    /// <inheritdoc />
    public Author Author { get; } = author;

    /// <summary>
    /// Video upload date.
    /// </summary>
    public DateTimeOffset UploadDate { get; } = uploadDate;

    /// <summary>
    /// Video description.
    /// </summary>
    public string Description { get; } = description;

    /// <inheritdoc />
    public TimeSpan? Duration { get; } = duration;

    /// <inheritdoc />
    public IReadOnlyList<Thumbnail> Thumbnails { get; } = thumbnails;

    /// <summary>
    /// Available search keywords for the video.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; } = keywords;

    /// <summary>
    /// Engagement statistics for the video.
    /// </summary>
    public Engagement Engagement { get; } = engagement;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Video ({Title})";
}



================================================
FILE: YoutubeExplode/Videos/VideoClient.cs
================================================
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Videos.ClosedCaptions;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Videos;

/// <summary>
/// Operations related to YouTube videos.
/// </summary>
public class VideoClient(HttpClient http)
{
    private readonly VideoController _controller = new(http);

    /// <summary>
    /// Operations related to media streams of YouTube videos.
    /// </summary>
    public StreamClient Streams { get; } = new(http);

    /// <summary>
    /// Operations related to closed captions of YouTube videos.
    /// </summary>
    public ClosedCaptionClient ClosedCaptions { get; } = new(http);

    /// <summary>
    /// Gets the metadata associated with the specified video.
    /// </summary>
    public async ValueTask<Video> GetAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        var watchPage = await _controller.GetVideoWatchPageAsync(videoId, cancellationToken);

        var playerResponse =
            watchPage.PlayerResponse
            ?? await _controller.GetPlayerResponseAsync(videoId, cancellationToken);

        var title =
            playerResponse.Title
            // Videos without title are legal
            // https://github.com/Tyrrrz/YoutubeExplode/issues/700
            ?? "";

        var channelTitle =
            playerResponse.Author
            ?? throw new YoutubeExplodeException("Failed to extract the video author.");

        var channelId =
            playerResponse.ChannelId
            ?? throw new YoutubeExplodeException("Failed to extract the video channel ID.");

        var uploadDate =
            playerResponse.UploadDate
            ?? watchPage.UploadDate
            ?? throw new YoutubeExplodeException("Failed to extract the video upload date.");

        var thumbnails = playerResponse
            .Thumbnails.Select(t =>
            {
                var thumbnailUrl =
                    t.Url
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail URL.");

                var thumbnailWidth =
                    t.Width
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail width.");

                var thumbnailHeight =
                    t.Height
                    ?? throw new YoutubeExplodeException("Failed to extract the thumbnail height.");

                var thumbnailResolution = new Resolution(thumbnailWidth, thumbnailHeight);

                return new Thumbnail(thumbnailUrl, thumbnailResolution);
            })
            .Concat(Thumbnail.GetDefaultSet(videoId))
            .ToArray();

        return new Video(
            videoId,
            title,
            new Author(channelId, channelTitle),
            uploadDate,
            playerResponse.Description ?? "",
            playerResponse.Duration,
            thumbnails,
            playerResponse.Keywords,
            // Engagement statistics may be hidden
            new Engagement(
                playerResponse.ViewCount ?? 0,
                watchPage.LikeCount ?? 0,
                watchPage.DislikeCount ?? 0
            )
        );
    }
}



================================================
FILE: YoutubeExplode/Videos/VideoController.cs
================================================
﻿using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Videos;

internal class VideoController(HttpClient http)
{
    private string? _visitorData;

    protected HttpClient Http { get; } = http;

    private async ValueTask<string> ResolveVisitorDataAsync(
        CancellationToken cancellationToken = default
    )
    {
        if (!string.IsNullOrWhiteSpace(_visitorData))
            return _visitorData;

        using var request = new HttpRequestMessage(
            HttpMethod.Get,
            "https://www.youtube.com/sw.js_data"
        );

        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

        request.Headers.Add(
            "User-Agent",
            "com.google.ios.youtube/19.45.4 (iPhone16,2; U; CPU iOS 18_1_0 like Mac OS X; US)"
        );

        using var response = await Http.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();

        // TODO: move this to a bridge wrapper
        var jsonString = await response.Content.ReadAsStringAsync(cancellationToken);
        if (jsonString.StartsWith(")]}'"))
            jsonString = jsonString[4..];

        var json = Json.Parse(jsonString);

        // This is just an ordered (but unstructured) blob of data
        var value = json[0][2][0][0][13].GetStringOrNull();
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new YoutubeExplodeException("Failed to resolve visitor data.");
        }

        return _visitorData = value;
    }

    public async ValueTask<VideoWatchPage> GetVideoWatchPageAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        for (var retriesRemaining = 5; ; retriesRemaining--)
        {
            var watchPage = VideoWatchPage.TryParse(
                await Http.GetStringAsync(
                    $"https://www.youtube.com/watch?v={videoId}&bpctr=9999999999",
                    cancellationToken
                )
            );

            if (watchPage is null)
            {
                if (retriesRemaining > 0)
                    continue;

                throw new YoutubeExplodeException(
                    "Video watch page is broken. Please try again in a few minutes."
                );
            }

            if (!watchPage.IsAvailable)
                throw new VideoUnavailableException($"Video '{videoId}' is not available.");

            return watchPage;
        }
    }

    public async ValueTask<PlayerResponse> GetPlayerResponseAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        var visitorData = await ResolveVisitorDataAsync(cancellationToken);

        // The most optimal client to impersonate is any mobile client, because they
        // don't require signature deciphering (for both normal and n-parameter signatures).
        // However, we can't use the ANDROID client because it has a limitation, preventing it
        // from downloading multiple streams from the same manifest (or the same stream multiple times).
        // https://github.com/Tyrrrz/YoutubeExplode/issues/705
        // Previously, we were using ANDROID_TESTSUITE as a workaround, which appeared to offer the same
        // functionality, but without the aforementioned limitation. However, YouTube discontinued this
        // client, so now we have to use IOS instead.
        // https://github.com/Tyrrrz/YoutubeExplode/issues/817
        using var request = new HttpRequestMessage(
            HttpMethod.Post,
            "https://www.youtube.com/youtubei/v1/player"
        );

        request.Content = new StringContent(
            // lang=json
            $$"""
            {
              "videoId": {{Json.Serialize(videoId)}},
              "contentCheckOk": true,
              "context": {
                "client": {
                  "clientName": "IOS",
                  "clientVersion": "19.45.4",
                  "deviceMake": "Apple",
                  "deviceModel": "iPhone16,2",
                  "platform": "MOBILE",
                  "osName": "IOS",
                  "osVersion": "18.1.0.22B83",
                  "visitorData": {{Json.Serialize(visitorData)}},
                  "hl": "en",
                  "gl": "US",
                  "utcOffsetMinutes": 0
                }
              }
            }
            """
        );

        // User agent appears to be sometimes required when impersonating Android
        // https://github.com/iv-org/invidious/issues/3230#issuecomment-1226887639
        request.Headers.Add(
            "User-Agent",
            "com.google.ios.youtube/19.45.4 (iPhone16,2; U; CPU iOS 18_1_0 like Mac OS X; US)"
        );

        using var response = await Http.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();

        var playerResponse = PlayerResponse.Parse(
            await response.Content.ReadAsStringAsync(cancellationToken)
        );

        if (!playerResponse.IsAvailable)
            throw new VideoUnavailableException($"Video '{videoId}' is not available.");

        return playerResponse;
    }

    public async ValueTask<PlayerResponse> GetPlayerResponseAsync(
        VideoId videoId,
        string? signatureTimestamp,
        CancellationToken cancellationToken = default
    )
    {
        var visitorData = await ResolveVisitorDataAsync(cancellationToken);

        // The only client that can handle age-restricted videos without authentication is the
        // TVHTML5_SIMPLY_EMBEDDED_PLAYER client.
        // This client does require signature deciphering, so we only use it as a fallback.
        using var request = new HttpRequestMessage(
            HttpMethod.Post,
            "https://www.youtube.com/youtubei/v1/player"
        );

        request.Content = new StringContent(
            // lang=json
            $$"""
            {
              "videoId": {{Json.Serialize(videoId)}},
              "context": {
                "client": {
                  "clientName": "TVHTML5_SIMPLY_EMBEDDED_PLAYER",
                  "clientVersion": "2.0",
                  "visitorData": {{Json.Serialize(visitorData)}},
                  "hl": "en",
                  "gl": "US",
                  "utcOffsetMinutes": 0
                },
                "thirdParty": {
                  "embedUrl": "https://www.youtube.com"
                }
              },
              "playbackContext": {
                "contentPlaybackContext": {
                  "signatureTimestamp": {{Json.Serialize(signatureTimestamp)}}
                }
              }
            }
            """
        );

        using var response = await Http.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();

        var playerResponse = PlayerResponse.Parse(
            await response.Content.ReadAsStringAsync(cancellationToken)
        );

        if (!playerResponse.IsAvailable)
            throw new VideoUnavailableException($"Video '{videoId}' is not available.");

        return playerResponse;
    }
}



================================================
FILE: YoutubeExplode/Videos/VideoId.cs
================================================
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Videos;

/// <summary>
/// Represents a syntactically valid YouTube video ID.
/// </summary>
public readonly partial struct VideoId(string value)
{
    /// <summary>
    /// Raw ID value.
    /// </summary>
    public string Value { get; } = value;

    /// <inheritdoc />
    public override string ToString() => Value;
}

public partial struct VideoId
{
    private static bool IsValid(string videoId) =>
        videoId.Length == 11 && videoId.All(c => char.IsLetterOrDigit(c) || c is '_' or '-');

    private static string? TryNormalize(string? videoIdOrUrl)
    {
        if (string.IsNullOrWhiteSpace(videoIdOrUrl))
            return null;

        // Check if already passed an ID
        // yIVRs6YSbOM
        if (IsValid(videoIdOrUrl))
            return videoIdOrUrl;

        // Try to extract the ID from the URL
        // https://www.youtube.com/watch?v=yIVRs6YSbOM
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtube\..+?/watch.*?v=(.*?)(?:&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (partially shortened)
        // https://youtu.be/watch?v=Fcds0_MrgNU
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtu\.be/watch.*?v=(.*?)(?:\?|&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (shortened)
        // https://youtu.be/yIVRs6YSbOM
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtu\.be/(.*?)(?:\?|&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (embedded)
        // https://www.youtube.com/embed/yIVRs6YSbOM
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtube\..+?/embed/(.*?)(?:\?|&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (shorts clip)
        // https://www.youtube.com/shorts/sKL1vjP0tIo
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtube\..+?/shorts/(.*?)(?:\?|&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Try to extract the ID from the URL (livestream)
        // https://www.youtube.com/live/jfKfPfyJRdk
        {
            var id = Regex
                .Match(videoIdOrUrl, @"youtube\..+?/live/(.*?)(?:\?|&|/|$)")
                .Groups[1]
                .Value.Pipe(WebUtility.UrlDecode);

            if (!string.IsNullOrWhiteSpace(id) && IsValid(id))
                return id;
        }

        // Invalid input
        return null;
    }

    /// <summary>
    /// Attempts to parse the specified string as a video ID or URL.
    /// Returns null in case of failure.
    /// </summary>
    public static VideoId? TryParse(string? videoIdOrUrl) =>
        TryNormalize(videoIdOrUrl)?.Pipe(id => new VideoId(id));

    /// <summary>
    /// Parses the specified string as a YouTube video ID or URL.
    /// Throws an exception in case of failure.
    /// </summary>
    public static VideoId Parse(string videoIdOrUrl) =>
        TryParse(videoIdOrUrl)
        ?? throw new ArgumentException($"Invalid YouTube video ID or URL '{videoIdOrUrl}'.");

    /// <summary>
    /// Converts string to ID.
    /// </summary>
    public static implicit operator VideoId(string videoIdOrUrl) => Parse(videoIdOrUrl);

    /// <summary>
    /// Converts ID to string.
    /// </summary>
    public static implicit operator string(VideoId videoId) => videoId.ToString();
}

public partial struct VideoId : IEquatable<VideoId>
{
    /// <inheritdoc />
    public bool Equals(VideoId other) => StringComparer.Ordinal.Equals(Value, other.Value);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is VideoId other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.Ordinal.GetHashCode(Value);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(VideoId left, VideoId right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(VideoId left, VideoId right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaption.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Individual closed caption contained within a track.
/// </summary>
public class ClosedCaption(
    string text,
    TimeSpan offset,
    TimeSpan duration,
    IReadOnlyList<ClosedCaptionPart> parts
)
{
    /// <summary>
    /// Text displayed by the caption.
    /// </summary>
    public string Text { get; } = text;

    /// <summary>
    /// Time at which the caption starts displaying.
    /// </summary>
    public TimeSpan Offset { get; } = offset;

    /// <summary>
    /// Duration of time for which the caption is displayed.
    /// </summary>
    public TimeSpan Duration { get; } = duration;

    /// <summary>
    /// Caption parts, usually representing individual words.
    /// </summary>
    /// <remarks>
    /// May be empty because not all captions have parts.
    /// </remarks>
    public IReadOnlyList<ClosedCaptionPart> Parts { get; } = parts;

    /// <summary>
    /// Gets the caption part displayed at the specified point in time, relative to the caption's own offset.
    /// Returns null if not found.
    /// </summary>
    public ClosedCaptionPart? TryGetPartByTime(TimeSpan time) =>
        Parts.FirstOrDefault(p => p.Offset >= time);

    /// <summary>
    /// Gets the caption part displayed at the specified point in time, relative to the caption's own offset.
    /// </summary>
    public ClosedCaptionPart GetPartByTime(TimeSpan time) =>
        TryGetPartByTime(time)
        ?? throw new InvalidOperationException($"No closed caption part found at {time}.");

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => Text;
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionClient.cs
================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Operations related to closed captions of YouTube videos.
/// </summary>
public class ClosedCaptionClient(HttpClient http)
{
    private readonly ClosedCaptionController _controller = new(http);

    private async IAsyncEnumerable<ClosedCaptionTrackInfo> GetClosedCaptionTrackInfosAsync(
        VideoId videoId,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        var playerResponse = await _controller.GetPlayerResponseAsync(videoId, cancellationToken);

        foreach (var trackData in playerResponse.ClosedCaptionTracks)
        {
            var url =
                trackData.Url
                ?? throw new YoutubeExplodeException("Failed to extract the track URL.");

            var languageCode =
                trackData.LanguageCode
                ?? throw new YoutubeExplodeException("Failed to extract the track language code.");

            var languageName =
                trackData.LanguageName
                ?? throw new YoutubeExplodeException("Failed to extract the track language name.");

            yield return new ClosedCaptionTrackInfo(
                url,
                new Language(languageCode, languageName),
                trackData.IsAutoGenerated
            );
        }
    }

    /// <summary>
    /// Gets the manifest that lists available closed caption tracks for the specified video.
    /// </summary>
    public async ValueTask<ClosedCaptionManifest> GetManifestAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    ) => new(await GetClosedCaptionTrackInfosAsync(videoId, cancellationToken));

    private async IAsyncEnumerable<ClosedCaption> GetClosedCaptionsAsync(
        ClosedCaptionTrackInfo trackInfo,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        var response = await _controller.GetClosedCaptionTrackResponseAsync(
            trackInfo.Url,
            cancellationToken
        );

        foreach (var captionData in response.Captions)
        {
            var text = captionData.Text;

            // Skip over empty captions, but not captions containing only whitespace
            // https://github.com/Tyrrrz/YoutubeExplode/issues/671
            if (string.IsNullOrEmpty(text))
                continue;

            // Auto-generated captions may be missing offset or duration
            // https://github.com/Tyrrrz/YoutubeExplode/discussions/619
            if (captionData.Offset is not { } offset || captionData.Duration is not { } duration)
            {
                continue;
            }

            var parts = new List<ClosedCaptionPart>();
            foreach (var partData in captionData.Parts)
            {
                var partText = partData.Text;

                // Skip over empty parts, but not parts containing only whitespace
                // https://github.com/Tyrrrz/YoutubeExplode/issues/671
                if (string.IsNullOrEmpty(partText))
                    continue;

                var partOffset =
                    partData.Offset
                    ?? throw new YoutubeExplodeException(
                        "Failed to extract the caption part offset."
                    );

                var part = new ClosedCaptionPart(partText, partOffset);

                parts.Add(part);
            }

            yield return new ClosedCaption(text, offset, duration, parts);
        }
    }

    /// <summary>
    /// Gets the closed caption track identified by the specified metadata.
    /// </summary>
    public async ValueTask<ClosedCaptionTrack> GetAsync(
        ClosedCaptionTrackInfo trackInfo,
        CancellationToken cancellationToken = default
    ) => new(await GetClosedCaptionsAsync(trackInfo, cancellationToken));

    /// <summary>
    /// Writes the closed caption track identified by the specified metadata to the specified writer.
    /// </summary>
    /// <remarks>
    /// Closed captions are written in the SRT file format.
    /// </remarks>
    public async ValueTask WriteToAsync(
        ClosedCaptionTrackInfo trackInfo,
        TextWriter writer,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        static string FormatTimestamp(TimeSpan value) =>
            Math.Floor(value.TotalHours).ToString("00", CultureInfo.InvariantCulture)
            + ':'
            + value.Minutes.ToString("00", CultureInfo.InvariantCulture)
            + ':'
            + value.Seconds.ToString("00", CultureInfo.InvariantCulture)
            + ','
            + value.Milliseconds.ToString("000", CultureInfo.InvariantCulture);

        // Would be better to use GetClosedCaptionsAsync(...) instead for streaming,
        // but we need the total number of captions to report progress.
        var track = await GetAsync(trackInfo, cancellationToken);

        var buffer = new StringBuilder();
        foreach (var (i, caption) in track.Captions.Index())
        {
            cancellationToken.ThrowIfCancellationRequested();

            buffer
                // Line number
                .AppendLine((i + 1).ToString(CultureInfo.InvariantCulture))
                // Time start --> time end
                .Append(FormatTimestamp(caption.Offset))
                .Append(" --> ")
                .Append(FormatTimestamp(caption.Offset + caption.Duration))
                .AppendLine()
                // Content
                .AppendLine(
                    caption.Text
                    // Caption text may contain valid SRT-formatted data in itself.
                    // This can happen, for example, if the subtitles for a YouTube video
                    // were imported from an SRT file, but something went wrong in the
                    // process, resulting in parts of the file being read as captions
                    // rather than control sequences.
                    // SRT file format does not provide any means of escaping special
                    // characters, so as a workaround we just replace the dashes in the
                    // arrow sequence with en-dashes, which look similar enough.
                    // https://github.com/Tyrrrz/YoutubeExplode/issues/755
                    .Replace("-->", "––>", StringComparison.Ordinal)
                );

            await writer.WriteLineAsync(buffer.ToString());
            buffer.Clear();

            progress?.Report((i + 1.0) / track.Captions.Count);
        }
    }

    /// <summary>
    /// Downloads the closed caption track identified by the specified metadata to the specified file.
    /// </summary>
    /// <remarks>
    /// Closed captions are written in the SRT file format.
    /// </remarks>
    public async ValueTask DownloadAsync(
        ClosedCaptionTrackInfo trackInfo,
        string filePath,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        using var writer = File.CreateText(filePath);
        await WriteToAsync(trackInfo, writer, progress, cancellationToken);
    }
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionController.cs
================================================
﻿using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Videos.ClosedCaptions;

internal class ClosedCaptionController(HttpClient http) : VideoController(http)
{
    public async ValueTask<ClosedCaptionTrackResponse> GetClosedCaptionTrackResponseAsync(
        string url,
        CancellationToken cancellationToken = default
    )
    {
        // Enforce known format
        var urlWithFormat = url.Pipe(s => UrlEx.SetQueryParameter(s, "format", "3"))
            .Pipe(s => UrlEx.SetQueryParameter(s, "fmt", "3"));

        return ClosedCaptionTrackResponse.Parse(
            await Http.GetStringAsync(urlWithFormat, cancellationToken)
        );
    }
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionManifest.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Describes closed caption tracks available for a YouTube video.
/// </summary>
public class ClosedCaptionManifest(IReadOnlyList<ClosedCaptionTrackInfo> tracks)
{
    /// <summary>
    /// Available closed caption tracks.
    /// </summary>
    public IReadOnlyList<ClosedCaptionTrackInfo> Tracks { get; } = tracks;

    /// <summary>
    /// Gets the closed caption track in the specified language (identified by ISO-639-1 code or display name).
    /// Returns null if not found.
    /// </summary>
    public ClosedCaptionTrackInfo? TryGetByLanguage(string language) =>
        Tracks.FirstOrDefault(t =>
            string.Equals(t.Language.Code, language, StringComparison.OrdinalIgnoreCase)
            || string.Equals(t.Language.Name, language, StringComparison.OrdinalIgnoreCase)
        );

    /// <summary>
    /// Gets the closed caption track in the specified language (identified by ISO-639-1 code or display name).
    /// </summary>
    public ClosedCaptionTrackInfo GetByLanguage(string language) =>
        TryGetByLanguage(language)
        ?? throw new InvalidOperationException(
            $"No closed caption track available for language '{language}'."
        );
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionPart.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Individual closed caption part contained within a track.
/// </summary>
public class ClosedCaptionPart(string text, TimeSpan offset)
{
    /// <summary>
    /// Text displayed by the caption part.
    /// </summary>
    public string Text { get; } = text;

    /// <summary>
    /// Time at which the caption part starts displaying, relative to the caption's own offset.
    /// </summary>
    public TimeSpan Offset { get; } = offset;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => Text;
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionTrack.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Contains closed captions in a specific language.
/// </summary>
public class ClosedCaptionTrack(IReadOnlyList<ClosedCaption> captions)
{
    /// <summary>
    /// Closed captions included in the track.
    /// </summary>
    public IReadOnlyList<ClosedCaption> Captions { get; } = captions;

    /// <summary>
    /// Gets the caption displayed at the specified point in time.
    /// Returns null if not found.
    /// </summary>
    public ClosedCaption? TryGetByTime(TimeSpan time) =>
        Captions.FirstOrDefault(c => time >= c.Offset && time <= c.Offset + c.Duration);

    /// <summary>
    /// Gets the caption displayed at the specified point in time.
    /// </summary>
    public ClosedCaption GetByTime(TimeSpan time) =>
        TryGetByTime(time)
        ?? throw new InvalidOperationException($"No closed caption found at {time}.");
}



================================================
FILE: YoutubeExplode/Videos/ClosedCaptions/ClosedCaptionTrackInfo.cs
================================================
using System.Diagnostics.CodeAnalysis;

namespace YoutubeExplode.Videos.ClosedCaptions;

/// <summary>
/// Metadata associated with a closed caption track of a YouTube video.
/// </summary>
public class ClosedCaptionTrackInfo(string url, Language language, bool isAutoGenerated)
{
    /// <summary>
    /// Track URL.
    /// </summary>
    public string Url { get; } = url;

    /// <summary>
    /// Track language.
    /// </summary>
    public Language Language { get; } = language;

    /// <summary>
    /// Whether the track was automatically generated.
    /// </summary>
    public bool IsAutoGenerated { get; } = isAutoGenerated;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"CC Track ({Language})";
}



================================================
FILE: YoutubeExplode/Videos/Streams/AudioOnlyStreamInfo.cs
================================================
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with an audio-only YouTube media stream.
/// </summary>
public class AudioOnlyStreamInfo(
    string url,
    Container container,
    FileSize size,
    Bitrate bitrate,
    string audioCodec,
    Language? audioLanguage,
    bool? isAudioLanguageDefault
) : IAudioStreamInfo
{
    /// <inheritdoc />
    public string Url { get; } = url;

    /// <inheritdoc />
    public Container Container { get; } = container;

    /// <inheritdoc />
    public FileSize Size { get; } = size;

    /// <inheritdoc />
    public Bitrate Bitrate { get; } = bitrate;

    /// <inheritdoc />
    public string AudioCodec { get; } = audioCodec;

    /// <inheritdoc />
    public Language? AudioLanguage { get; } = audioLanguage;

    /// <inheritdoc />
    public bool? IsAudioLanguageDefault { get; } = isAudioLanguageDefault;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() =>
        AudioLanguage is not null
            ? $"Audio-only ({Container} | {AudioLanguage})"
            : $"Audio-only ({Container})";
}



================================================
FILE: YoutubeExplode/Videos/Streams/Bitrate.cs
================================================
using System;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Bitrate.
/// </summary>
public readonly partial struct Bitrate(long bitsPerSecond)
{
    /// <summary>
    /// Bitrate in bits per second.
    /// </summary>
    public long BitsPerSecond { get; } = bitsPerSecond;

    /// <summary>
    /// Bitrate in kilobits per second.
    /// </summary>
    public double KiloBitsPerSecond => BitsPerSecond / 1024.0;

    /// <summary>
    /// Bitrate in megabits per second.
    /// </summary>
    public double MegaBitsPerSecond => KiloBitsPerSecond / 1024.0;

    /// <summary>
    /// Bitrate in gigabits per second
    /// </summary>
    public double GigaBitsPerSecond => MegaBitsPerSecond / 1024.0;

    private string GetLargestWholeNumberSymbol()
    {
        if (Math.Abs(GigaBitsPerSecond) >= 1)
            return "Gbit/s";

        if (Math.Abs(MegaBitsPerSecond) >= 1)
            return "Mbit/s";

        if (Math.Abs(KiloBitsPerSecond) >= 1)
            return "Kbit/s";

        return "Bit/s";
    }

    private double GetLargestWholeNumberValue()
    {
        if (Math.Abs(GigaBitsPerSecond) >= 1)
            return GigaBitsPerSecond;

        if (Math.Abs(MegaBitsPerSecond) >= 1)
            return MegaBitsPerSecond;

        if (Math.Abs(KiloBitsPerSecond) >= 1)
            return KiloBitsPerSecond;

        return BitsPerSecond;
    }

    /// <inheritdoc />
    public override string ToString() =>
        $"{GetLargestWholeNumberValue():0.##} {GetLargestWholeNumberSymbol()}";
}

public partial struct Bitrate : IComparable<Bitrate>, IEquatable<Bitrate>
{
    /// <inheritdoc />
    public int CompareTo(Bitrate other) => BitsPerSecond.CompareTo(other.BitsPerSecond);

    /// <inheritdoc />
    public bool Equals(Bitrate other) => CompareTo(other) == 0;

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is Bitrate other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => HashCode.Combine(BitsPerSecond);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(Bitrate left, Bitrate right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(Bitrate left, Bitrate right) => !(left == right);

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator >(Bitrate left, Bitrate right) => left.CompareTo(right) > 0;

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator <(Bitrate left, Bitrate right) => left.CompareTo(right) < 0;
}



================================================
FILE: YoutubeExplode/Videos/Streams/Container.cs
================================================
using System;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Stream container.
/// </summary>
public readonly partial struct Container(string name)
{
    /// <summary>
    /// Container name (e.g. mp4, webm, etc).
    /// Can be used as file extension.
    /// </summary>
    public string Name { get; } = name;

    /// <summary>
    /// Whether this container is a known audio-only container.
    /// </summary>
    /// <remarks>
    /// This property only refers to the container's capabilities and not its actual contents.
    /// If the container IS audio-only, it DOES NOT contain any video streams.
    /// If the container IS NOT audio-only, it MAY contain video streams, but is not required to.
    /// </remarks>
    public bool IsAudioOnly =>
        string.Equals(Name, "mp3", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "m4a", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "wav", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "wma", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "ogg", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "aac", StringComparison.OrdinalIgnoreCase)
        || string.Equals(Name, "opus", StringComparison.OrdinalIgnoreCase);

    /// <inheritdoc />
    public override string ToString() => Name;
}

public partial struct Container
{
    /// <summary>
    /// MPEG-2 Audio Layer III (mp3).
    /// </summary>
    /// <remarks>
    /// YouTube does not natively provide streams in this container.
    /// </remarks>
    public static Container Mp3 { get; } = new("mp3");

    /// <summary>
    /// MPEG-4 Part 14 (mp4).
    /// </summary>
    public static Container Mp4 { get; } = new("mp4");

    /// <summary>
    /// Web Media (webm).
    /// </summary>
    public static Container WebM { get; } = new("webm");

    /// <summary>
    /// 3rd Generation Partnership Project (3gpp).
    /// </summary>
    public static Container Tgpp { get; } = new("3gpp");
}

public partial struct Container : IEquatable<Container>
{
    /// <inheritdoc />
    public bool Equals(Container other) =>
        StringComparer.OrdinalIgnoreCase.Equals(Name, other.Name);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is Container other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.OrdinalIgnoreCase.GetHashCode(Name);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(Container left, Container right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(Container left, Container right) => !(left == right);
}



================================================
FILE: YoutubeExplode/Videos/Streams/FileSize.cs
================================================
using System;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// File size.
/// </summary>
// Loosely based on https://github.com/omar/ByteSize (MIT license)
public readonly partial struct FileSize(long bytes)
{
    /// <summary>
    /// Size in bytes.
    /// </summary>
    public long Bytes { get; } = bytes;

    /// <summary>
    /// Size in kilobytes.
    /// </summary>
    public double KiloBytes => Bytes / 1024.0;

    /// <summary>
    /// Size in megabytes.
    /// </summary>
    public double MegaBytes => KiloBytes / 1024.0;

    /// <summary>
    /// Size in gigabytes.
    /// </summary>
    public double GigaBytes => MegaBytes / 1024.0;

    private string GetLargestWholeNumberSymbol()
    {
        if (Math.Abs(GigaBytes) >= 1)
            return "GB";

        if (Math.Abs(MegaBytes) >= 1)
            return "MB";

        if (Math.Abs(KiloBytes) >= 1)
            return "KB";

        return "B";
    }

    private double GetLargestWholeNumberValue()
    {
        if (Math.Abs(GigaBytes) >= 1)
            return GigaBytes;

        if (Math.Abs(MegaBytes) >= 1)
            return MegaBytes;

        if (Math.Abs(KiloBytes) >= 1)
            return KiloBytes;

        return Bytes;
    }

    /// <inheritdoc />
    public override string ToString() =>
        $"{GetLargestWholeNumberValue():0.##} {GetLargestWholeNumberSymbol()}";
}

public partial struct FileSize : IComparable<FileSize>, IEquatable<FileSize>
{
    /// <inheritdoc />
    public int CompareTo(FileSize other) => Bytes.CompareTo(other.Bytes);

    /// <inheritdoc />
    public bool Equals(FileSize other) => CompareTo(other) == 0;

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is FileSize other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => HashCode.Combine(Bytes);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(FileSize left, FileSize right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(FileSize left, FileSize right) => !(left == right);

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator >(FileSize left, FileSize right) => left.CompareTo(right) > 0;

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator <(FileSize left, FileSize right) => left.CompareTo(right) < 0;
}



================================================
FILE: YoutubeExplode/Videos/Streams/IAudioStreamInfo.cs
================================================
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with a media stream that contains audio.
/// </summary>
public interface IAudioStreamInfo : IStreamInfo
{
    /// <summary>
    /// Audio codec.
    /// </summary>
    string AudioCodec { get; }

    /// <summary>
    /// Audio language.
    /// </summary>
    /// <remarks>
    /// May be null if the audio stream does not contain language information.
    /// </remarks>
    Language? AudioLanguage { get; }

    /// <summary>
    /// Whether the audio stream's language corresponds to the default language of the video.
    /// </summary>
    /// <remarks>
    /// May be null if the audio stream does not contain language information.
    /// </remarks>
    bool? IsAudioLanguageDefault { get; }
}



================================================
FILE: YoutubeExplode/Videos/Streams/IStreamInfo.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using YoutubeExplode.Utils;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with a media stream of a YouTube video.
/// </summary>
public interface IStreamInfo
{
    /// <summary>
    /// Stream URL.
    /// </summary>
    /// <remarks>
    /// While this URL can be used to access the underlying stream, you need a series
    /// of carefully crafted HTTP requests in order to do so.
    /// It's highly recommended to use
    /// <see cref="StreamClient.GetAsync" /> or <see cref="StreamClient.DownloadAsync" />
    /// instead, as they will perform all the heavy lifting for you.
    /// </remarks>
    string Url { get; }

    /// <summary>
    /// Stream container.
    /// </summary>
    Container Container { get; }

    /// <summary>
    /// Stream size.
    /// </summary>
    FileSize Size { get; }

    /// <summary>
    /// Stream bitrate.
    /// </summary>
    Bitrate Bitrate { get; }
}

/// <summary>
/// Extensions for <see cref="IStreamInfo" />.
/// </summary>
public static class StreamInfoExtensions
{
    internal static bool IsThrottled(this IStreamInfo streamInfo) =>
        !string.Equals(
            UrlEx.TryGetQueryParameterValue(streamInfo.Url, "ratebypass"),
            "yes",
            StringComparison.OrdinalIgnoreCase
        );

    /// <summary>
    /// Gets the stream with the highest bitrate.
    /// Returns null if the sequence is empty.
    /// </summary>
    public static IStreamInfo? TryGetWithHighestBitrate(
        this IEnumerable<IStreamInfo> streamInfos
    ) => streamInfos.MaxBy(s => s.Bitrate);

    /// <summary>
    /// Gets the stream with the highest bitrate.
    /// </summary>
    public static IStreamInfo GetWithHighestBitrate(this IEnumerable<IStreamInfo> streamInfos) =>
        streamInfos.TryGetWithHighestBitrate()
        ?? throw new InvalidOperationException("Input stream collection is empty.");
}



================================================
FILE: YoutubeExplode/Videos/Streams/IVideoStreamInfo.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using YoutubeExplode.Common;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with a media stream that contains video.
/// </summary>
public interface IVideoStreamInfo : IStreamInfo
{
    /// <summary>
    /// Video codec.
    /// </summary>
    string VideoCodec { get; }

    /// <summary>
    /// Video quality.
    /// </summary>
    VideoQuality VideoQuality { get; }

    /// <summary>
    /// Video resolution.
    /// </summary>
    Resolution VideoResolution { get; }
}

/// <summary>
/// Extensions for <see cref="IVideoStreamInfo" />.
/// </summary>
public static class VideoStreamInfoExtensions
{
    /// <summary>
    /// Gets the video stream with the highest video quality (including framerate).
    /// Returns null if the sequence is empty.
    /// </summary>
    public static IVideoStreamInfo? TryGetWithHighestVideoQuality(
        this IEnumerable<IVideoStreamInfo> streamInfos
    ) => streamInfos.MaxBy(s => s.VideoQuality);

    /// <summary>
    /// Gets the video stream with the highest video quality (including framerate).
    /// </summary>
    public static IVideoStreamInfo GetWithHighestVideoQuality(
        this IEnumerable<IVideoStreamInfo> streamInfos
    ) =>
        streamInfos.TryGetWithHighestVideoQuality()
        ?? throw new InvalidOperationException("Input stream collection is empty.");
}



================================================
FILE: YoutubeExplode/Videos/Streams/MediaStream.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Utils;

namespace YoutubeExplode.Videos.Streams;

// Works around YouTube's rate throttling, provides seeking support, and some resiliency
internal partial class MediaStream(HttpClient http, IStreamInfo streamInfo) : Stream
{
    // For most streams, YouTube limits transfer speed to match the video playback rate.
    // This helps them avoid unnecessary bandwidth, but for us it's a hindrance because
    // we want to download the stream as fast as possible.
    // To solve this, we divide the logical stream up into multiple segments and download
    // them all separately.

    private readonly long _segmentLength = streamInfo.IsThrottled()
        ? 9_898_989
        : streamInfo.Size.Bytes;

    private Stream? _segmentStream;
    private long _actualPosition;

    [ExcludeFromCodeCoverage]
    public override bool CanRead => true;

    [ExcludeFromCodeCoverage]
    public override bool CanSeek => true;

    [ExcludeFromCodeCoverage]
    public override bool CanWrite => false;

    public override long Length => streamInfo.Size.Bytes;

    public override long Position { get; set; }

    private void ResetSegment()
    {
        _segmentStream?.Dispose();
        _segmentStream = null;
    }

    private async ValueTask<Stream> ResolveSegmentAsync(
        CancellationToken cancellationToken = default
    )
    {
        if (_segmentStream is not null)
            return _segmentStream;

        var url = GetSegmentUrl(streamInfo.Url, Position, Position + _segmentLength - 1);
        var stream = await http.GetStreamAsync(url, cancellationToken);

        return _segmentStream = stream;
    }

    public async ValueTask InitializeAsync(CancellationToken cancellationToken = default) =>
        await ResolveSegmentAsync(cancellationToken);

    private async ValueTask<int> ReadSegmentAsync(
        byte[] buffer,
        int offset,
        int count,
        CancellationToken cancellationToken = default
    )
    {
        for (var retriesRemaining = 5; ; retriesRemaining--)
        {
            try
            {
                var stream = await ResolveSegmentAsync(cancellationToken);
                return await stream.ReadAsync(buffer, offset, count, cancellationToken);
            }
            // Retry on connectivity issues
            catch (Exception ex)
                when (ex is HttpRequestException or IOException && retriesRemaining > 0)
            {
                ResetSegment();
            }
        }
    }

    public override async Task<int> ReadAsync(
        byte[] buffer,
        int offset,
        int count,
        CancellationToken cancellationToken
    )
    {
        while (true)
        {
            var requestedPosition = Position;

            // If the consumer changed position since the last read, reset the segment
            // to get the correct data.
            if (_actualPosition != requestedPosition)
                ResetSegment();

            // Exit if we reached the end of the stream
            if (requestedPosition >= Length)
                return 0;

            var bytesRead = await ReadSegmentAsync(buffer, offset, count, cancellationToken);
            Position = _actualPosition = requestedPosition + bytesRead;

            if (bytesRead > 0)
                return bytesRead;

            // Reached the end of the segment, load the next one and loop around
            ResetSegment();
        }
    }

    [ExcludeFromCodeCoverage]
    public override int Read(byte[] buffer, int offset, int count) =>
        ReadAsync(buffer, offset, count).GetAwaiter().GetResult();

    [ExcludeFromCodeCoverage]
    public override void Write(byte[] buffer, int offset, int count) =>
        throw new NotSupportedException();

    [ExcludeFromCodeCoverage]
    public override void SetLength(long value) => throw new NotSupportedException();

    [ExcludeFromCodeCoverage]
    public override long Seek(long offset, SeekOrigin origin) =>
        Position = origin switch
        {
            SeekOrigin.Begin => offset,
            SeekOrigin.Current => Position + offset,
            SeekOrigin.End => Length + offset,
            _ => throw new ArgumentOutOfRangeException(nameof(origin)),
        };

    [ExcludeFromCodeCoverage]
    public override void Flush() => throw new NotSupportedException();

    protected override void Dispose(bool disposing)
    {
        if (disposing)
            ResetSegment();

        base.Dispose(disposing);
    }
}

internal partial class MediaStream
{
    public static string GetSegmentUrl(string streamUrl, long from, long to) =>
        UrlEx.SetQueryParameter(streamUrl, "range", $"{from}-{to}");
}



================================================
FILE: YoutubeExplode/Videos/Streams/MuxedStreamInfo.cs
================================================
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with a muxed (audio + video combined) media stream.
/// </summary>
public class MuxedStreamInfo(
    string url,
    Container container,
    FileSize size,
    Bitrate bitrate,
    string audioCodec,
    Language? audioLanguage,
    bool? isAudioLanguageDefault,
    string videoCodec,
    VideoQuality videoQuality,
    Resolution videoResolution
) : IAudioStreamInfo, IVideoStreamInfo
{
    /// <inheritdoc />
    public string Url { get; } = url;

    /// <inheritdoc />
    public Container Container { get; } = container;

    /// <inheritdoc />
    public FileSize Size { get; } = size;

    /// <inheritdoc />
    public Bitrate Bitrate { get; } = bitrate;

    /// <inheritdoc />
    public string AudioCodec { get; } = audioCodec;

    /// <inheritdoc />
    public Language? AudioLanguage { get; } = audioLanguage;

    /// <inheritdoc />
    public bool? IsAudioLanguageDefault { get; } = isAudioLanguageDefault;

    /// <inheritdoc />
    public string VideoCodec { get; } = videoCodec;

    /// <inheritdoc />
    public VideoQuality VideoQuality { get; } = videoQuality;

    /// <inheritdoc />
    public Resolution VideoResolution { get; } = videoResolution;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Muxed ({VideoQuality} | {Container})";
}



================================================
FILE: YoutubeExplode/Videos/Streams/StreamClient.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Bridge.Cipher;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Utils;
using YoutubeExplode.Utils.Extensions;
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Operations related to media streams of YouTube videos.
/// </summary>
public class StreamClient(HttpClient http)
{
    private readonly StreamController _controller = new(http);

    // Because we determine the player version ourselves, it's safe to cache the cipher manifest
    // for the entire lifetime of the client.
    private CipherManifest? _cipherManifest;

    private async ValueTask<CipherManifest> ResolveCipherManifestAsync(
        CancellationToken cancellationToken
    )
    {
        if (_cipherManifest is not null)
            return _cipherManifest;

        var playerSource = await _controller.GetPlayerSourceAsync(cancellationToken);

        return _cipherManifest =
            playerSource.CipherManifest
            ?? throw new YoutubeExplodeException("Failed to extract the cipher manifest.");
    }

    private async ValueTask<long?> TryGetContentLengthAsync(
        IStreamData streamData,
        string url,
        CancellationToken cancellationToken = default
    )
    {
        var contentLength = streamData.ContentLength;

        // If content length is not available in the metadata, get it by
        // sending a HEAD request and parsing the Content-Length header.
        if (contentLength is null)
        {
            using var response = await http.HeadAsync(url, cancellationToken);
            contentLength = response.Content.Headers.ContentLength;

            // 404 error indicates that the stream is not available
            if (response.StatusCode == HttpStatusCode.NotFound)
                return null;

            response.EnsureSuccessStatusCode();
        }

        if (contentLength is not null)
        {
            // Streams may have mismatched content length, so ensure that the obtained value is correct
            // https://github.com/Tyrrrz/YoutubeExplode/issues/759
            using var response = await http.GetAsync(
                // Try to access the last byte of the stream
                MediaStream.GetSegmentUrl(url, contentLength.Value - 2, contentLength.Value - 1),
                HttpCompletionOption.ResponseHeadersRead,
                cancellationToken
            );

            // 404 error indicates that the stream has mismatched content length or is not available
            if (response.StatusCode == HttpStatusCode.NotFound)
                return null;

            response.EnsureSuccessStatusCode();
        }

        return contentLength;
    }

    private async IAsyncEnumerable<IStreamInfo> GetStreamInfosAsync(
        IEnumerable<IStreamData> streamDatas,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        foreach (var streamData in streamDatas)
        {
            var itag =
                streamData.Itag
                ?? throw new YoutubeExplodeException("Failed to extract the stream itag.");

            var url =
                streamData.Url
                ?? throw new YoutubeExplodeException("Failed to extract the stream URL.");

            // Handle cipher-protected streams
            if (!string.IsNullOrWhiteSpace(streamData.Signature))
            {
                var cipherManifest = await ResolveCipherManifestAsync(cancellationToken);

                url = UrlEx.SetQueryParameter(
                    url,
                    streamData.SignatureParameter ?? "sig",
                    cipherManifest.Decipher(streamData.Signature)
                );
            }

            var contentLength = await TryGetContentLengthAsync(streamData, url, cancellationToken);
            if (contentLength is null)
                continue;

            var container =
                streamData.Container?.Pipe(s => new Container(s))
                ?? throw new YoutubeExplodeException("Failed to extract the stream container.");

            var bitrate =
                streamData.Bitrate?.Pipe(s => new Bitrate(s))
                ?? throw new YoutubeExplodeException("Failed to extract the stream bitrate.");

            var audioLanguage = !string.IsNullOrWhiteSpace(streamData.AudioLanguageCode)
                ? new Language(
                    streamData.AudioLanguageCode,
                    streamData.AudioLanguageName ?? streamData.AudioLanguageCode
                )
                : (Language?)null;

            // Muxed or video-only stream
            if (!string.IsNullOrWhiteSpace(streamData.VideoCodec))
            {
                var framerate = streamData.VideoFramerate ?? 24;

                var videoQuality = !string.IsNullOrWhiteSpace(streamData.VideoQualityLabel)
                    ? VideoQuality.FromLabel(streamData.VideoQualityLabel, framerate)
                    : VideoQuality.FromItag(itag, framerate);

                var videoResolution =
                    streamData.VideoWidth is not null && streamData.VideoHeight is not null
                        ? new Resolution(streamData.VideoWidth.Value, streamData.VideoHeight.Value)
                        : videoQuality.GetDefaultVideoResolution();

                // Muxed
                if (!string.IsNullOrWhiteSpace(streamData.AudioCodec))
                {
                    var streamInfo = new MuxedStreamInfo(
                        url,
                        container,
                        new FileSize(contentLength.Value),
                        bitrate,
                        streamData.AudioCodec,
                        audioLanguage,
                        streamData.IsAudioLanguageDefault,
                        streamData.VideoCodec,
                        videoQuality,
                        videoResolution
                    );

                    yield return streamInfo;
                }
                // Video-only
                else
                {
                    var streamInfo = new VideoOnlyStreamInfo(
                        url,
                        container,
                        new FileSize(contentLength.Value),
                        bitrate,
                        streamData.VideoCodec,
                        videoQuality,
                        videoResolution
                    );

                    yield return streamInfo;
                }
            }
            // Audio-only
            else if (!string.IsNullOrWhiteSpace(streamData.AudioCodec))
            {
                var streamInfo = new AudioOnlyStreamInfo(
                    url,
                    container,
                    new FileSize(contentLength.Value),
                    bitrate,
                    streamData.AudioCodec,
                    audioLanguage,
                    streamData.IsAudioLanguageDefault
                );

                yield return streamInfo;
            }
            else
            {
                throw new YoutubeExplodeException("Failed to extract the stream codec.");
            }
        }
    }

    private async ValueTask<IReadOnlyList<IStreamInfo>> GetStreamInfosAsync(
        VideoId videoId,
        PlayerResponse playerResponse,
        CancellationToken cancellationToken = default
    )
    {
        var streamInfos = new List<IStreamInfo>();

        // Video is pay-to-play
        if (!string.IsNullOrWhiteSpace(playerResponse.PreviewVideoId))
        {
            throw new VideoRequiresPurchaseException(
                $"Video '{videoId}' requires purchase and cannot be played.",
                playerResponse.PreviewVideoId
            );
        }

        // Video is unplayable
        if (!playerResponse.IsPlayable)
        {
            throw new VideoUnplayableException(
                $"Video '{videoId}' is unplayable. Reason: '{playerResponse.PlayabilityError}'."
            );
        }

        // Extract streams from the player response
        streamInfos.AddRange(await GetStreamInfosAsync(playerResponse.Streams, cancellationToken));

        // Extract streams from the DASH manifest
        if (!string.IsNullOrWhiteSpace(playerResponse.DashManifestUrl))
        {
            try
            {
                var dashManifest = await _controller.GetDashManifestAsync(
                    playerResponse.DashManifestUrl,
                    cancellationToken
                );

                streamInfos.AddRange(
                    await GetStreamInfosAsync(dashManifest.Streams, cancellationToken)
                );
            }
            // Some DASH manifest URLs return 404 for whatever reason
            // https://github.com/Tyrrrz/YoutubeExplode/issues/728
            catch (HttpRequestException) { }
        }

        // Error if no streams were found
        if (!streamInfos.Any())
        {
            throw new VideoUnplayableException(
                $"Video '{videoId}' does not contain any playable streams."
            );
        }

        return streamInfos;
    }

    private async ValueTask<IReadOnlyList<IStreamInfo>> GetStreamInfosAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        try
        {
            // Try to get player response from a cipher-less client
            var playerResponse = await _controller.GetPlayerResponseAsync(
                videoId,
                cancellationToken
            );

            return await GetStreamInfosAsync(videoId, playerResponse, cancellationToken);
        }
        catch (VideoUnplayableException)
        {
            // Try to get player response from a client with cipher
            var cipherManifest = await ResolveCipherManifestAsync(cancellationToken);

            var playerResponse = await _controller.GetPlayerResponseAsync(
                videoId,
                cipherManifest.SignatureTimestamp,
                cancellationToken
            );

            return await GetStreamInfosAsync(videoId, playerResponse, cancellationToken);
        }
    }

    /// <summary>
    /// Gets the manifest that lists available streams for the specified video.
    /// </summary>
    public async ValueTask<StreamManifest> GetManifestAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        for (var retriesRemaining = 5; ; retriesRemaining--)
        {
            try
            {
                return new StreamManifest(await GetStreamInfosAsync(videoId, cancellationToken));
            }
            // Retry on connectivity issues
            catch (Exception ex)
                when (ex is HttpRequestException or IOException && retriesRemaining > 0) { }
        }
    }

    /// <summary>
    /// Gets the HTTP Live Stream (HLS) manifest URL for the specified video (if it is a livestream).
    /// </summary>
    public async ValueTask<string> GetHttpLiveStreamUrlAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default
    )
    {
        var playerResponse = await _controller.GetPlayerResponseAsync(videoId, cancellationToken);
        if (!playerResponse.IsPlayable)
        {
            throw new VideoUnplayableException(
                $"Video '{videoId}' is unplayable. Reason: '{playerResponse.PlayabilityError}'."
            );
        }

        if (string.IsNullOrWhiteSpace(playerResponse.HlsManifestUrl))
        {
            throw new YoutubeExplodeException(
                $"Failed to extract the HTTP Live Stream manifest URL. Video '{videoId}' is likely not a live stream."
            );
        }

        return playerResponse.HlsManifestUrl;
    }

    /// <summary>
    /// Gets the stream identified by the specified metadata.
    /// </summary>
    public async ValueTask<Stream> GetAsync(
        IStreamInfo streamInfo,
        CancellationToken cancellationToken = default
    )
    {
        var stream = new MediaStream(http, streamInfo);
        await stream.InitializeAsync(cancellationToken);

        return stream;
    }

    /// <summary>
    /// Copies the stream identified by the specified metadata to the specified stream.
    /// </summary>
    public async ValueTask CopyToAsync(
        IStreamInfo streamInfo,
        Stream destination,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        using var input = await GetAsync(streamInfo, cancellationToken);
        await input.CopyToAsync(destination, progress, cancellationToken);
    }

    /// <summary>
    /// Downloads the stream identified by the specified metadata to the specified file.
    /// </summary>
    public async ValueTask DownloadAsync(
        IStreamInfo streamInfo,
        string filePath,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        using var destination = File.Create(filePath);
        await CopyToAsync(streamInfo, destination, progress, cancellationToken);
    }
}



================================================
FILE: YoutubeExplode/Videos/Streams/StreamController.cs
================================================
﻿using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Exceptions;

namespace YoutubeExplode.Videos.Streams;

internal class StreamController(HttpClient http) : VideoController(http)
{
    public async ValueTask<PlayerSource> GetPlayerSourceAsync(
        CancellationToken cancellationToken = default
    )
    {
        var iframe = await Http.GetStringAsync(
            "https://www.youtube.com/iframe_api",
            cancellationToken
        );

        var version = Regex.Match(iframe, @"player\\?/([0-9a-fA-F]{8})\\?/").Groups[1].Value;
        if (string.IsNullOrWhiteSpace(version))
            throw new YoutubeExplodeException("Failed to extract the player version.");

        return PlayerSource.Parse(
            await Http.GetStringAsync(
                $"https://www.youtube.com/s/player/{version}/player_ias.vflset/en_US/base.js",
                cancellationToken
            )
        );
    }

    public async ValueTask<DashManifest> GetDashManifestAsync(
        string url,
        CancellationToken cancellationToken = default
    ) => DashManifest.Parse(await Http.GetStringAsync(url, cancellationToken));
}



================================================
FILE: YoutubeExplode/Videos/Streams/StreamManifest.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Describes media streams available for a YouTube video.
/// </summary>
public class StreamManifest(IReadOnlyList<IStreamInfo> streams)
{
    /// <summary>
    /// Available streams.
    /// </summary>
    public IReadOnlyList<IStreamInfo> Streams { get; } = streams;

    /// <summary>
    /// Gets streams that contain audio (i.e. muxed and audio-only streams).
    /// </summary>
    public IEnumerable<IAudioStreamInfo> GetAudioStreams() => Streams.OfType<IAudioStreamInfo>();

    /// <summary>
    /// Gets streams that contain video (i.e. muxed and video-only streams).
    /// </summary>
    public IEnumerable<IVideoStreamInfo> GetVideoStreams() => Streams.OfType<IVideoStreamInfo>();

    /// <summary>
    /// Gets muxed streams (i.e. streams containing both audio and video).
    /// </summary>
    /// <remarks>
    /// These streams are generally deprecated by YouTube and may not be available
    /// for every video. If needed, use the YoutubeExplode.Converter package to
    /// manually mux audio-only and video-only streams into a single container.
    /// </remarks>
    public IEnumerable<MuxedStreamInfo> GetMuxedStreams() => Streams.OfType<MuxedStreamInfo>();

    /// <summary>
    /// Gets audio-only streams.
    /// </summary>
    public IEnumerable<AudioOnlyStreamInfo> GetAudioOnlyStreams() =>
        GetAudioStreams().OfType<AudioOnlyStreamInfo>();

    /// <summary>
    /// Gets video-only streams.
    /// </summary>
    public IEnumerable<VideoOnlyStreamInfo> GetVideoOnlyStreams() =>
        GetVideoStreams().OfType<VideoOnlyStreamInfo>();
}



================================================
FILE: YoutubeExplode/Videos/Streams/VideoOnlyStreamInfo.cs
================================================
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Common;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Metadata associated with a video-only media stream.
/// </summary>
public class VideoOnlyStreamInfo(
    string url,
    Container container,
    FileSize size,
    Bitrate bitrate,
    string videoCodec,
    VideoQuality videoQuality,
    Resolution videoResolution
) : IVideoStreamInfo
{
    /// <inheritdoc />
    public string Url { get; } = url;

    /// <inheritdoc />
    public Container Container { get; } = container;

    /// <inheritdoc />
    public FileSize Size { get; } = size;

    /// <inheritdoc />
    public Bitrate Bitrate { get; } = bitrate;

    /// <inheritdoc />
    public string VideoCodec { get; } = videoCodec;

    /// <inheritdoc />
    public VideoQuality VideoQuality { get; } = videoQuality;

    /// <inheritdoc />
    public Resolution VideoResolution { get; } = videoResolution;

    /// <inheritdoc />
    [ExcludeFromCodeCoverage]
    public override string ToString() => $"Video-only ({VideoQuality} | {Container})";
}



================================================
FILE: YoutubeExplode/Videos/Streams/VideoQuality.cs
================================================
using System;
using System.Text.RegularExpressions;
using YoutubeExplode.Common;
using YoutubeExplode.Utils.Extensions;

namespace YoutubeExplode.Videos.Streams;

/// <summary>
/// Video stream quality.
/// </summary>
public readonly partial struct VideoQuality(string label, int maxHeight, int framerate)
{
    /// <summary>
    /// Initializes an instance of <see cref="VideoQuality" />.
    /// </summary>
    public VideoQuality(int maxHeight, int framerate)
        : this(FormatLabel(maxHeight, framerate), maxHeight, framerate) { }

    /// <summary>
    /// Quality label, as seen on YouTube (e.g. 1080p, 720p60, etc).
    /// </summary>
    public string Label { get; } = label;

    /// <summary>
    /// Maximum video height allowed by this quality (e.g. 1080 for 1080p60).
    /// Actual video height may be lower in some cases.
    /// </summary>
    public int MaxHeight { get; } = maxHeight;

    /// <summary>
    /// Video framerate, measured in frames per second.
    /// </summary>
    public int Framerate { get; } = framerate;

    /// <summary>
    /// Whether this is a high definition video (i.e. 1080p or above).
    /// </summary>
    public bool IsHighDefinition => MaxHeight >= 1080;

    internal Resolution GetDefaultVideoResolution() =>
        MaxHeight switch
        {
            144 => new Resolution(256, 144),
            240 => new Resolution(426, 240),
            360 => new Resolution(640, 360),
            480 => new Resolution(854, 480),
            720 => new Resolution(1280, 720),
            1080 => new Resolution(1920, 1080),
            1440 => new Resolution(2560, 1440),
            2160 => new Resolution(3840, 2160),
            2880 => new Resolution(5120, 2880),
            3072 => new Resolution(4096, 3072),
            4320 => new Resolution(7680, 4320),
            _ => new Resolution(16 * MaxHeight / 9, MaxHeight),
        };

    /// <inheritdoc />
    public override string ToString() => Label;
}

public partial struct VideoQuality
{
    private static string FormatLabel(int maxHeight, int framerate)
    {
        // Framerate appears only if it's above 30
        if (framerate <= 30)
            return $"{maxHeight}p";

        // YouTube rounds framerate to the next nearest decimal
        var framerateRounded = (int)Math.Ceiling(framerate / 10.0) * 10;
        return $"{maxHeight}p{framerateRounded}";
    }

    internal static VideoQuality FromLabel(string label, int framerateFallback)
    {
        // Video quality labels can have the following formats:
        // - 1080p (regular stream, regular fps)
        // - 1080p60 (regular stream, high fps)
        // - 1080s (360° stream, regular fps)
        // - 1080s60 (360° stream, high fps)
        // - 2160p60 HDR (high dynamic range, high fps)

        var match = Regex.Match(label, @"^(\d+)\D(\d+)?");

        var maxHeight = match.Groups[1].Value.ParseInt();
        var framerate = match.Groups[2].Value.NullIfWhiteSpace()?.ParseIntOrNull();

        return new VideoQuality(label, maxHeight, framerate ?? framerateFallback);
    }

    internal static VideoQuality FromItag(int itag, int framerate)
    {
        var maxHeight = itag switch
        {
            5 => 144,
            6 => 240,
            13 => 144,
            17 => 144,
            18 => 360,
            22 => 720,
            34 => 360,
            35 => 480,
            36 => 240,
            37 => 1080,
            38 => 3072,
            43 => 360,
            44 => 480,
            45 => 720,
            46 => 1080,
            59 => 480,
            78 => 480,
            82 => 360,
            83 => 480,
            84 => 720,
            85 => 1080,
            91 => 144,
            92 => 240,
            93 => 360,
            94 => 480,
            95 => 720,
            96 => 1080,
            100 => 360,
            101 => 480,
            102 => 720,
            132 => 240,
            151 => 144,
            133 => 240,
            134 => 360,
            135 => 480,
            136 => 720,
            137 => 1080,
            138 => 4320,
            142 => 240,
            143 => 360,
            144 => 480,
            145 => 720,
            146 => 1080,
            160 => 144,
            161 => 144,
            167 => 360,
            168 => 480,
            169 => 720,
            170 => 1080,
            212 => 480,
            213 => 480,
            214 => 720,
            215 => 720,
            216 => 1080,
            217 => 1080,
            218 => 480,
            219 => 480,
            222 => 480,
            223 => 480,
            224 => 720,
            225 => 720,
            226 => 1080,
            227 => 1080,
            242 => 240,
            243 => 360,
            244 => 480,
            245 => 480,
            246 => 480,
            247 => 720,
            248 => 1080,
            264 => 1440,
            266 => 2160,
            271 => 1440,
            272 => 2160,
            278 => 144,
            298 => 720,
            299 => 1080,
            302 => 720,
            303 => 1080,
            308 => 1440,
            313 => 2160,
            315 => 2160,
            330 => 144,
            331 => 240,
            332 => 360,
            333 => 480,
            334 => 720,
            335 => 1080,
            336 => 1440,
            337 => 2160,
            399 => 1080,
            398 => 720,
            397 => 480,
            396 => 360,
            395 => 240,
            394 => 144,
            _ => throw new ArgumentException($"Unrecognized itag '{itag}'.", nameof(itag)),
        };

        return new VideoQuality(maxHeight, framerate);
    }
}

public partial struct VideoQuality : IComparable<VideoQuality>, IEquatable<VideoQuality>
{
    /// <inheritdoc />
    public int CompareTo(VideoQuality other)
    {
        var maxHeightComparison = MaxHeight.CompareTo(other.MaxHeight);
        if (maxHeightComparison != 0)
            return maxHeightComparison;

        var framerateComparison = Framerate.CompareTo(other.Framerate);
        if (framerateComparison != 0)
            return framerateComparison;

        var labelComparison = StringComparer.OrdinalIgnoreCase.Compare(Label, other.Label);
        return labelComparison;
    }

    /// <inheritdoc />
    public bool Equals(VideoQuality other) =>
        StringComparer.OrdinalIgnoreCase.Equals(Label, other.Label)
        && MaxHeight == other.MaxHeight
        && Framerate == other.Framerate;

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is VideoQuality other && Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() =>
        HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(Label), MaxHeight, Framerate);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator ==(VideoQuality left, VideoQuality right) => left.Equals(right);

    /// <summary>
    /// Equality check.
    /// </summary>
    public static bool operator !=(VideoQuality left, VideoQuality right) => !(left == right);

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator >(VideoQuality left, VideoQuality right) =>
        left.CompareTo(right) > 0;

    /// <summary>
    /// Comparison.
    /// </summary>
    public static bool operator <(VideoQuality left, VideoQuality right) =>
        left.CompareTo(right) < 0;
}



================================================
FILE: YoutubeExplode.Converter/Readme.md
================================================
# YoutubeExplode.Converter

[![Version](https://img.shields.io/nuget/v/YoutubeExplode.Converter.svg)](https://nuget.org/packages/YoutubeExplode.Converter)
[![Downloads](https://img.shields.io/nuget/dt/YoutubeExplode.Converter.svg)](https://nuget.org/packages/YoutubeExplode.Converter)

**YoutubeExplode.Converter** is an extension package for **YoutubeExplode** that provides the capability to download YouTube videos by muxing separate streams into a single file.
This package relies on [FFmpeg](https://ffmpeg.org) under the hood.

## Install

- 📦 [NuGet](https://nuget.org/packages/YoutubeExplode.Converter): `dotnet add package YoutubeExplode.Converter`

> **Important**:
> This package requires the [FFmpeg CLI](https://ffmpeg.org) to work, which can be downloaded [here](https://github.com/Tyrrrz/FFmpegBin/releases).
> Ensure that it's located in your application's probe directory or on the system's `PATH`, or provide a custom location yourself using one of the available method overloads.

## Usage

**YoutubeExplode.Converter** exposes its functionality by enhancing **YoutubeExplode**'s clients with additional extension methods.
To use them, simply add the corresponding namespace and follow the examples below.

### Downloading videos

You can download a video directly to a file through one of the extension methods provided on `VideoClient`.
For example, to download a video in the specified format using the highest quality streams, simply call `DownloadAsync(...)` with the video ID and the destination path:

```csharp
using YoutubeExplode;
using YoutubeExplode.Converter;

var youtube = new YoutubeClient();

var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";
await youtube.Videos.DownloadAsync(videoUrl, "video.mp4");
```

Internally, this resolves the video's media streams, downloads the best candidates based on format, bitrate, framerate, and quality, and muxes them together into a single file.

> **Note**:
> If the specified output format is a known audio-only container (e.g. `mp3` or `ogg`) then only the audio stream is downloaded.

> **Warning**:
> Stream muxing is a resource-intensive process, especially when transcoding is involved.
> To avoid transcoding, consider specifying either `mp4` or `webm` for the output format, as these are the containers that YouTube uses for most of its streams. 

### Customizing the conversion process

To configure various aspects of the conversion process, use the following overload of `DownloadAsync(...)`:

```csharp
using YoutubeExplode;
using YoutubeExplode.Converter;

var youtube = new YoutubeClient();
var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";

await youtube.Videos.DownloadAsync(videoUrl, "video.mp4", o => o
    .SetContainer("webm") // override format
    .SetPreset(ConversionPreset.UltraFast) // change preset
    .SetFFmpegPath("path/to/ffmpeg") // custom FFmpeg location
);
```

### Manually selecting streams

If you need precise control over which streams are used for the muxing process, you can also provide them yourself instead of relying on the automatic resolution:

```csharp
using YoutubeExplode;
using YoutubeExplode.Videos.Streams;
using YoutubeExplode.Converter;

var youtube = new YoutubeClient();

// Get stream manifest
var videoUrl = "https://youtube.com/watch?v=u_yIGGhubZs";
var streamManifest = await youtube.Videos.Streams.GetManifestAsync(videoUrl);

// Select best audio stream (highest bitrate)
var audioStreamInfo = streamManifest
    .GetAudioStreams()
    .Where(s => s.Container == Container.Mp4)
    .GetWithHighestBitrate();

// Select best video stream (1080p60 in this example)
var videoStreamInfo = streamManifest
    .GetVideoStreams()
    .Where(s => s.Container == Container.Mp4)
    .First(s => s.VideoQuality.Label == "1080p60");

// Download and mux streams into a single file
await youtube.Videos.DownloadAsync(
    [audioStreamInfo, videoStreamInfo],
    new ConversionRequestBuilder("video.mp4").Build()
);
```

> **Warning**:
> Stream muxing is a resource-intensive process, especially when transcoding is involved.
> To avoid transcoding, consider prioritizing streams that are already encoded in the desired format (e.g. `mp4` or `webm`).



================================================
FILE: YoutubeExplode.Converter/ConversionExtensions.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Converter.Utils.Extensions;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter;

/// <summary>
/// Extensions for <see cref="VideoClient" /> that provide interface for downloading videos through FFmpeg.
/// </summary>
public static class ConversionExtensions
{
    /// <summary>
    /// Checks whether the container is a known audio-only container.
    /// </summary>
    [Obsolete("Use the Container.IsAudioOnly property instead."), ExcludeFromCodeCoverage]
    public static bool IsAudioOnly(this Container container) => container.IsAudioOnly;

    private static async IAsyncEnumerable<IStreamInfo> GetOptimalStreamInfosAsync(
        this VideoClient videoClient,
        VideoId videoId,
        Container container,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    )
    {
        var streamManifest = await videoClient.Streams.GetManifestAsync(videoId, cancellationToken);

        if (
            streamManifest.GetAudioOnlyStreams().Any() && streamManifest.GetVideoOnlyStreams().Any()
        )
        {
            // Include audio stream
            // Priority: transcoding -> bitrate
            yield return streamManifest
                .GetAudioOnlyStreams()
                .OrderByDescending(s => s.Container == container)
                .ThenByDescending(s => s.Bitrate)
                .First();

            // Include video stream
            if (!container.IsAudioOnly)
            {
                // Priority: video quality -> transcoding
                yield return streamManifest
                    .GetVideoOnlyStreams()
                    .OrderByDescending(s => s.VideoQuality)
                    .ThenByDescending(s => s.Container == container)
                    .First();
            }
        }
        // Use single muxed stream if adaptive streams are not available
        else
        {
            // Priority: video quality -> transcoding
            yield return streamManifest
                .GetMuxedStreams()
                .OrderByDescending(s => s.VideoQuality)
                .ThenByDescending(s => s.Container == container)
                .First();
        }
    }

    /// <summary>
    /// Downloads the specified media streams and closed captions and processes them into a single file.
    /// </summary>
    public static async ValueTask DownloadAsync(
        this VideoClient videoClient,
        IReadOnlyList<IStreamInfo> streamInfos,
        IReadOnlyList<ClosedCaptionTrackInfo> closedCaptionTrackInfos,
        ConversionRequest request,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        var ffmpeg = new FFmpeg(request.FFmpegCliFilePath);
        var converter = new Converter(videoClient, ffmpeg, request.Preset);

        await converter.ProcessAsync(
            request.OutputFilePath,
            request.Container,
            streamInfos,
            closedCaptionTrackInfos,
            progress,
            cancellationToken
        );
    }

    /// <summary>
    /// Downloads the specified media streams and processes them into a single file.
    /// </summary>
    public static async ValueTask DownloadAsync(
        this VideoClient videoClient,
        IReadOnlyList<IStreamInfo> streamInfos,
        ConversionRequest request,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    ) => await videoClient.DownloadAsync(streamInfos, [], request, progress, cancellationToken);

    /// <summary>
    /// Resolves the most optimal media streams for the specified video, downloads them,
    /// and processes into a single file.
    /// </summary>
    public static async ValueTask DownloadAsync(
        this VideoClient videoClient,
        VideoId videoId,
        ConversionRequest request,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    ) =>
        await videoClient.DownloadAsync(
            await videoClient.GetOptimalStreamInfosAsync(
                videoId,
                request.Container,
                cancellationToken
            ),
            request,
            progress,
            cancellationToken
        );

    /// <summary>
    /// Resolves the most optimal media streams for the specified video, downloads them,
    /// and processes into a single file.
    /// </summary>
    /// <remarks>
    /// Output container is inferred from the file extension, unless explicitly specified.
    /// </remarks>
    public static async ValueTask DownloadAsync(
        this VideoClient videoClient,
        VideoId videoId,
        string outputFilePath,
        Action<ConversionRequestBuilder> configure,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        var requestBuilder = new ConversionRequestBuilder(outputFilePath);
        configure(requestBuilder);
        var request = requestBuilder.Build();

        await videoClient.DownloadAsync(videoId, request, progress, cancellationToken);
    }

    /// <summary>
    /// Resolves the most optimal media streams for the specified video,
    /// downloads them, and processes into a single file.
    /// </summary>
    /// <remarks>
    /// Output container is inferred from the file extension.
    /// If none is specified, mp4 is chosen by default.
    /// </remarks>
    public static async ValueTask DownloadAsync(
        this VideoClient videoClient,
        VideoId videoId,
        string outputFilePath,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    ) =>
        await videoClient.DownloadAsync(
            videoId,
            outputFilePath,
            _ => { },
            progress,
            cancellationToken
        );
}



================================================
FILE: YoutubeExplode.Converter/ConversionFormat.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter;

/// <summary>
/// Encapsulates conversion media format.
/// </summary>
[Obsolete("Use YoutubeExplode.Videos.Streams.Container instead"), ExcludeFromCodeCoverage]
public readonly struct ConversionFormat(string name)
{
    /// <summary>
    /// Format name.
    /// </summary>
    public string Name { get; } = name;

    /// <summary>
    /// Whether this format is a known audio-only format.
    /// </summary>
    public bool IsAudioOnly => new Container(Name).IsAudioOnly();

    /// <inheritdoc />
    public override string ToString() => Name;
}



================================================
FILE: YoutubeExplode.Converter/ConversionPreset.cs
================================================
﻿namespace YoutubeExplode.Converter;

/// <summary>
/// Encoder preset.
/// </summary>
public enum ConversionPreset
{
    /// <summary>
    /// Much slower conversion speed and smaller output file size.
    /// </summary>
    VerySlow = -2,

    /// <summary>
    /// Slightly slower conversion speed and smaller output file size.
    /// </summary>
    Slow = -1,

    /// <summary>
    /// Default preset.
    /// Balanced conversion speed and output file size.
    /// </summary>
    Medium = 0,

    /// <summary>
    /// Slightly faster conversion speed and bigger output file size.
    /// </summary>
    Fast = 1,

    /// <summary>
    /// Much faster conversion speed and bigger output file size.
    /// </summary>
    VeryFast = 2,

    /// <summary>
    /// Fastest conversion speed and biggest output file size.
    /// </summary>
    UltraFast = 3,
}



================================================
FILE: YoutubeExplode.Converter/ConversionRequest.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter;

/// <summary>
/// Conversion options.
/// </summary>
public class ConversionRequest(
    string ffmpegCliFilePath,
    string outputFilePath,
    Container container,
    ConversionPreset preset
)
{
    /// <summary>
    /// Initializes an instance of <see cref="ConversionRequest" />.
    /// </summary>
    [Obsolete("Use the other constructor overload"), ExcludeFromCodeCoverage]
    public ConversionRequest(
        string ffmpegCliFilePath,
        string outputFilePath,
        ConversionFormat format,
        ConversionPreset preset
    )
        : this(ffmpegCliFilePath, outputFilePath, new Container(format.Name), preset) { }

    /// <summary>
    /// Path to the FFmpeg CLI.
    /// </summary>
    public string FFmpegCliFilePath { get; } = ffmpegCliFilePath;

    /// <summary>
    /// Output file path.
    /// </summary>
    public string OutputFilePath { get; } = outputFilePath;

    /// <summary>
    /// Output container.
    /// </summary>
    public Container Container { get; } = container;

    /// <summary>
    /// Output format.
    /// </summary>
    [Obsolete("Use the Container property instead."), ExcludeFromCodeCoverage]
    public ConversionFormat Format => new(Container.Name);

    /// <summary>
    /// Encoder preset.
    /// </summary>
    public ConversionPreset Preset { get; } = preset;
}



================================================
FILE: YoutubeExplode.Converter/ConversionRequestBuilder.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using YoutubeExplode.Converter.Utils.Extensions;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter;

/// <summary>
/// Builder for <see cref="ConversionRequest" />.
/// </summary>
public class ConversionRequestBuilder(string outputFilePath)
{
    private string? _ffmpegCliFilePath;
    private Container? _container;
    private ConversionPreset _preset;

    private Container GetDefaultContainer() =>
        new(Path.GetExtension(outputFilePath).TrimStart('.').NullIfWhiteSpace() ?? "mp4");

    /// <summary>
    /// Sets the path to the FFmpeg CLI.
    /// </summary>
    public ConversionRequestBuilder SetFFmpegPath(string path)
    {
        _ffmpegCliFilePath = path;
        return this;
    }

    /// <summary>
    /// Sets the output container.
    /// </summary>
    public ConversionRequestBuilder SetContainer(Container container)
    {
        _container = container;
        return this;
    }

    /// <summary>
    /// Sets the output container.
    /// </summary>
    public ConversionRequestBuilder SetContainer(string container) =>
        SetContainer(new Container(container));

    /// <summary>
    /// Sets the conversion format.
    /// </summary>
    [Obsolete("Use SetContainer instead."), ExcludeFromCodeCoverage]
    public ConversionRequestBuilder SetFormat(ConversionFormat format) =>
        SetContainer(new Container(format.Name));

    /// <summary>
    /// Sets the conversion format.
    /// </summary>
    [Obsolete("Use SetContainer instead."), ExcludeFromCodeCoverage]
    public ConversionRequestBuilder SetFormat(string format) => SetContainer(format);

    /// <summary>
    /// Sets the conversion preset.
    /// </summary>
    public ConversionRequestBuilder SetPreset(ConversionPreset preset)
    {
        _preset = preset;
        return this;
    }

    /// <summary>
    /// Builds the resulting request.
    /// </summary>
    public ConversionRequest Build() =>
        new(
            _ffmpegCliFilePath ?? FFmpeg.GetFilePath(),
            outputFilePath,
            _container ?? GetDefaultContainer(),
            _preset
        );
}



================================================
FILE: YoutubeExplode.Converter/Converter.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CliWrap.Builders;
using YoutubeExplode.Converter.Utils;
using YoutubeExplode.Converter.Utils.Extensions;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter;

internal partial class Converter(VideoClient videoClient, FFmpeg ffmpeg, ConversionPreset preset)
{
    private async ValueTask ProcessAsync(
        string filePath,
        Container container,
        IReadOnlyList<StreamInput> streamInputs,
        IReadOnlyList<SubtitleInput> subtitleInputs,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        var arguments = new ArgumentsBuilder();

        // Stream inputs
        foreach (var streamInput in streamInputs)
        {
            arguments.Add("-i").Add(streamInput.FilePath);
        }

        // Subtitle inputs
        foreach (var subtitleInput in subtitleInputs)
        {
            arguments
                // Fix invalid subtitle durations for each input
                // https://github.com/Tyrrrz/YoutubeExplode/issues/756
                .Add("-fix_sub_duration")
                .Add("-i")
                .Add(subtitleInput.FilePath);
        }

        // Explicitly specify that all inputs should be used, because by default
        // FFmpeg only picks one input per stream type (audio, video, subtitle).
        for (var i = 0; i < streamInputs.Count + subtitleInputs.Count; i++)
        {
            arguments.Add("-map").Add(i);
        }

        // Output format and encoding preset
        arguments.Add("-f").Add(container.Name).Add("-preset").Add(preset);

        // Avoid transcoding inputs that have the same container as the output
        {
            var lastAudioStreamIndex = 0;
            var lastVideoStreamIndex = 0;
            foreach (var streamInput in streamInputs)
            {
                // Note: a muxed stream input will map to two separate audio and video streams

                if (streamInput.Info is IAudioStreamInfo audioStreamInfo)
                {
                    if (audioStreamInfo.Container == container)
                    {
                        arguments.Add($"-c:a:{lastAudioStreamIndex}").Add("copy");
                    }

                    lastAudioStreamIndex++;
                }

                if (streamInput.Info is IVideoStreamInfo videoStreamInfo)
                {
                    if (videoStreamInfo.Container == container)
                    {
                        arguments.Add($"-c:v:{lastVideoStreamIndex}").Add("copy");
                    }

                    lastVideoStreamIndex++;
                }
            }
        }

        // MP4: explicitly specify the codec for subtitles, otherwise they won't get embedded
        if (container == Container.Mp4 && subtitleInputs.Any())
        {
            arguments.Add("-c:s").Add("mov_text");
        }

        // MP3: explicitly specify the bitrate for audio streams, otherwise their metadata
        // might contain invalid total duration.
        // https://superuser.com/a/893044
        if (container == Container.Mp3)
        {
            var lastAudioStreamIndex = 0;
            foreach (var streamInput in streamInputs)
            {
                if (streamInput.Info is IAudioStreamInfo audioStreamInfo)
                {
                    arguments
                        .Add($"-b:a:{lastAudioStreamIndex++}")
                        .Add(Math.Round(audioStreamInfo.Bitrate.KiloBitsPerSecond) + "K");
                }
            }
        }

        // Metadata for stream inputs
        {
            var lastAudioStreamIndex = 0;
            var lastVideoStreamIndex = 0;
            foreach (var streamInput in streamInputs)
            {
                // Note: a muxed stream input will map to two separate audio and video streams

                if (streamInput.Info is IAudioStreamInfo audioStreamInfo)
                {
                    // Contains language information
                    if (audioStreamInfo.AudioLanguage is not null)
                    {
                        // Language codes can be stored in any format, but most players expect
                        // three-letter codes, so we'll try to convert to that first.
                        var languageCode =
                            audioStreamInfo.AudioLanguage.Value.TryGetThreeLetterCode()
                            ?? audioStreamInfo.AudioLanguage.Value.Code;

                        arguments
                            .Add($"-metadata:s:a:{lastAudioStreamIndex}")
                            .Add($"language={languageCode}")
                            .Add($"-metadata:s:a:{lastAudioStreamIndex}")
                            .Add(
                                $"title={audioStreamInfo.AudioLanguage.Value.Name} | {audioStreamInfo.Bitrate}"
                            );
                    }
                    // Does not contain language information
                    else
                    {
                        arguments
                            .Add($"-metadata:s:a:{lastAudioStreamIndex}")
                            .Add($"title={audioStreamInfo.Bitrate}");
                    }

                    lastAudioStreamIndex++;
                }

                if (streamInput.Info is IVideoStreamInfo videoStreamInfo)
                {
                    arguments
                        .Add($"-metadata:s:v:{lastVideoStreamIndex}")
                        .Add(
                            $"title={videoStreamInfo.VideoQuality.Label} | {videoStreamInfo.Bitrate}"
                        );

                    lastVideoStreamIndex++;
                }
            }
        }

        // Metadata for subtitles
        foreach (var (i, subtitleInput) in subtitleInputs.Index())
        {
            // Language codes can be stored in any format, but most players expect
            // three-letter codes, so we'll try to convert to that first.
            var languageCode =
                subtitleInput.Info.Language.TryGetThreeLetterCode()
                ?? subtitleInput.Info.Language.Code;

            arguments
                .Add($"-metadata:s:s:{i}")
                .Add($"language={languageCode}")
                .Add($"-metadata:s:s:{i}")
                .Add($"title={subtitleInput.Info.Language.Name}");
        }

        // Enable progress reporting
        arguments
            // Info log level is required to extract total stream duration
            .Add("-loglevel")
            .Add("info")
            .Add("-stats");

        // Misc settings
        arguments
            .Add("-hide_banner")
            .Add("-threads")
            .Add(Environment.ProcessorCount)
            .Add("-nostdin")
            .Add("-y");

        // Output
        arguments.Add(filePath);

        await ffmpeg.ExecuteAsync(arguments.Build(), progress, cancellationToken);
    }

    private async ValueTask PopulateStreamInputsAsync(
        string baseFilePath,
        IReadOnlyList<IStreamInfo> streamInfos,
        ICollection<StreamInput> streamInputs,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        var progressMuxer = progress?.Pipe(p => new ProgressMuxer(p));
        var progresses = streamInfos
            .Select(s => progressMuxer?.CreateInput(s.Size.MegaBytes))
            .ToArray();

        var lastIndex = 0;

        foreach (var (streamInfo, streamProgress) in streamInfos.Zip(progresses))
        {
            var streamInput = new StreamInput(
                streamInfo,
                $"{baseFilePath}.stream-{lastIndex++}.tmp"
            );

            streamInputs.Add(streamInput);

            await videoClient.Streams.DownloadAsync(
                streamInfo,
                streamInput.FilePath,
                streamProgress,
                cancellationToken
            );
        }

        progress?.Report(1);
    }

    private async ValueTask PopulateSubtitleInputsAsync(
        string baseFilePath,
        IReadOnlyList<ClosedCaptionTrackInfo> closedCaptionTrackInfos,
        ICollection<SubtitleInput> subtitleInputs,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        var progressMuxer = progress?.Pipe(p => new ProgressMuxer(p));
        var progresses = closedCaptionTrackInfos
            .Select(_ => progressMuxer?.CreateInput())
            .ToArray();

        var lastIndex = 0;

        foreach (var (trackInfo, trackProgress) in closedCaptionTrackInfos.Zip(progresses))
        {
            var subtitleInput = new SubtitleInput(
                trackInfo,
                $"{baseFilePath}.subtitles-{lastIndex++}.tmp"
            );

            subtitleInputs.Add(subtitleInput);

            await videoClient.ClosedCaptions.DownloadAsync(
                trackInfo,
                subtitleInput.FilePath,
                trackProgress,
                cancellationToken
            );
        }

        progress?.Report(1);
    }

    public async ValueTask ProcessAsync(
        string filePath,
        Container container,
        IReadOnlyList<IStreamInfo> streamInfos,
        IReadOnlyList<ClosedCaptionTrackInfo> closedCaptionTrackInfos,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default
    )
    {
        if (!streamInfos.Any())
            throw new InvalidOperationException("No streams provided.");

        // Configure progress aggregation
        var progressMuxer = progress?.Pipe(p => new ProgressMuxer(p));
        var streamDownloadProgress = progressMuxer?.CreateInput();
        var subtitleDownloadProgress = progressMuxer?.CreateInput(0.01);
        var conversionProgress = progressMuxer?.CreateInput(
            0.05
                +
                // Increase weight for each stream that needs to be transcoded
                5 * streamInfos.Count(s => s.Container != container)
        );

        // Populate inputs
        var streamInputs = new List<StreamInput>(streamInfos.Count);
        var subtitleInputs = new List<SubtitleInput>(closedCaptionTrackInfos.Count);

        try
        {
            await PopulateStreamInputsAsync(
                filePath,
                streamInfos,
                streamInputs,
                streamDownloadProgress,
                cancellationToken
            );

            await PopulateSubtitleInputsAsync(
                filePath,
                closedCaptionTrackInfos,
                subtitleInputs,
                subtitleDownloadProgress,
                cancellationToken
            );

            await ProcessAsync(
                filePath,
                container,
                streamInputs,
                subtitleInputs,
                conversionProgress,
                cancellationToken
            );
        }
        finally
        {
            foreach (var inputStream in streamInputs)
                inputStream.Dispose();

            foreach (var inputClosedCaptionTrack in subtitleInputs)
                inputClosedCaptionTrack.Dispose();
        }
    }
}

internal partial class Converter
{
    private class StreamInput(IStreamInfo info, string filePath) : IDisposable
    {
        public IStreamInfo Info { get; } = info;

        public string FilePath { get; } = filePath;

        public void Dispose()
        {
            try
            {
                File.Delete(FilePath);
            }
            catch
            {
                // Ignore
            }
        }
    }

    private class SubtitleInput(ClosedCaptionTrackInfo info, string filePath) : IDisposable
    {
        public ClosedCaptionTrackInfo Info { get; } = info;

        public string FilePath { get; } = filePath;

        public void Dispose()
        {
            try
            {
                File.Delete(FilePath);
            }
            catch
            {
                // Ignore
            }
        }
    }
}



================================================
FILE: YoutubeExplode.Converter/FFmpeg.cs
================================================
﻿using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using CliWrap;
using CliWrap.Exceptions;
using YoutubeExplode.Converter.Utils.Extensions;

namespace YoutubeExplode.Converter;

// Ideally this should use named pipes and stream through stdout.
// However, named pipes aren't well supported on non-Windows OS and
// stdout streaming only works with some specific formats.
internal partial class FFmpeg(string filePath)
{
    public async ValueTask ExecuteAsync(
        string arguments,
        IProgress<double>? progress,
        CancellationToken cancellationToken = default
    )
    {
        var stdErrBuffer = new StringBuilder();

        var stdErrPipe = PipeTarget.Merge(
            // Collect error output in case of failure
            PipeTarget.ToStringBuilder(stdErrBuffer),
            // Collect progress output if requested
            progress?.Pipe(CreateProgressRouter) ?? PipeTarget.Null
        );

        try
        {
            await Cli.Wrap(filePath)
                .WithArguments(arguments)
                .WithStandardErrorPipe(stdErrPipe)
                .ExecuteAsync(cancellationToken);
        }
        catch (CommandExecutionException ex)
        {
            throw new InvalidOperationException(
                $"""
                FFmpeg command-line tool failed with an error.

                Standard error:
                {stdErrBuffer}
                """,
                ex
            );
        }
    }
}

internal partial class FFmpeg
{
    public static string GetFilePath() =>
        // Try to find FFmpeg in the probe directory
        Directory
            .EnumerateFiles(AppContext.BaseDirectory ?? Directory.GetCurrentDirectory())
            .FirstOrDefault(f =>
                string.Equals(
                    Path.GetFileNameWithoutExtension(f),
                    "ffmpeg",
                    StringComparison.OrdinalIgnoreCase
                )
            )
        // Otherwise fallback to just "ffmpeg" and hope it's on the PATH
        ?? "ffmpeg";

    private static PipeTarget CreateProgressRouter(IProgress<double> progress)
    {
        var totalDuration = default(TimeSpan?);

        return PipeTarget.ToDelegate(line =>
        {
            // Extract total stream duration
            if (totalDuration is null)
            {
                // Need to extract all components separately because TimeSpan cannot directly
                // parse a time string that is greater than 24 hours.
                var totalDurationMatch = Regex.Match(line, @"Duration:\s(\d+):(\d+):(\d+\.\d+)");
                if (totalDurationMatch.Success)
                {
                    var hours = int.Parse(
                        totalDurationMatch.Groups[1].Value,
                        CultureInfo.InvariantCulture
                    );
                    var minutes = int.Parse(
                        totalDurationMatch.Groups[2].Value,
                        CultureInfo.InvariantCulture
                    );
                    var seconds = double.Parse(
                        totalDurationMatch.Groups[3].Value,
                        CultureInfo.InvariantCulture
                    );

                    totalDuration =
                        TimeSpan.FromHours(hours)
                        + TimeSpan.FromMinutes(minutes)
                        + TimeSpan.FromSeconds(seconds);
                }
            }

            if (totalDuration is null || totalDuration == TimeSpan.Zero)
                return;

            // Extract processed stream duration
            var processedDurationMatch = Regex.Match(line, @"time=(\d+):(\d+):(\d+\.\d+)");
            if (processedDurationMatch.Success)
            {
                var hours = int.Parse(
                    processedDurationMatch.Groups[1].Value,
                    CultureInfo.InvariantCulture
                );
                var minutes = int.Parse(
                    processedDurationMatch.Groups[2].Value,
                    CultureInfo.InvariantCulture
                );
                var seconds = double.Parse(
                    processedDurationMatch.Groups[3].Value,
                    CultureInfo.InvariantCulture
                );

                var processedDuration =
                    TimeSpan.FromHours(hours)
                    + TimeSpan.FromMinutes(minutes)
                    + TimeSpan.FromSeconds(seconds);

                progress.Report(
                    (
                        processedDuration.TotalMilliseconds / totalDuration.Value.TotalMilliseconds
                    ).Clamp(0, 1)
                );
            }
        });
    }
}



================================================
FILE: YoutubeExplode.Converter/YoutubeExplode.Converter.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net9.0</TargetFrameworks>
    <IsPackable>true</IsPackable>
    <IsTrimmable
      Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net6.0'))"
      >true</IsTrimmable
    >
    <IsAotCompatible
      Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net7.0'))"
      >true</IsAotCompatible
    >
  </PropertyGroup>
  <PropertyGroup>
    <Description>Extension for YoutubeExplode that provides an interface to download and convert videos using FFmpeg</Description>
    <PackageProjectUrl>https://github.com/Tyrrrz/YoutubeExplode/tree/master/YoutubeExplode.Converter</PackageProjectUrl>
    <PackageIcon>favicon.png</PackageIcon>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>
  <ItemGroup>
    <None Include="../favicon.png" Pack="true" PackagePath="" Visible="false" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="CliWrap" Version="3.8.2" />
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0" PrivateAssets="all" />
    <PackageReference Include="PolyShim" Version="1.15.0" PrivateAssets="all" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\YoutubeExplode\YoutubeExplode.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode.Converter/Utils/ProgressMuxer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Threading;

namespace YoutubeExplode.Converter.Utils;

internal class ProgressMuxer(IProgress<double> target)
{
    private readonly Lock _lock = new();
    private readonly Dictionary<int, double> _splitWeights = new();
    private readonly Dictionary<int, double> _splitValues = new();

    public IProgress<double> CreateInput(double weight = 1)
    {
        using (_lock.EnterScope())
        {
            var index = _splitWeights.Count;

            _splitWeights[index] = weight;
            _splitValues[index] = 0;

            return new Progress<double>(p =>
            {
                using (_lock.EnterScope())
                {
                    _splitValues[index] = p;

                    var weightedSum = 0.0;
                    var weightedMax = 0.0;

                    for (var i = 0; i < _splitWeights.Count; i++)
                    {
                        weightedSum += _splitWeights[i] * _splitValues[i];
                        weightedMax += _splitWeights[i];
                    }

                    target.Report(weightedSum / weightedMax);
                }
            });
        }
    }
}



================================================
FILE: YoutubeExplode.Converter/Utils/Extensions/AsyncCollectionExtensions.cs
================================================
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace YoutubeExplode.Converter.Utils.Extensions;

internal static class AsyncCollectionExtensions
{
    public static async ValueTask<List<T>> ToListAsync<T>(this IAsyncEnumerable<T> source)
    {
        var list = new List<T>();

        await foreach (var i in source)
            list.Add(i);

        return list;
    }

    public static ValueTaskAwaiter<List<T>> GetAwaiter<T>(this IAsyncEnumerable<T> source) =>
        source.ToListAsync().GetAwaiter();
}



================================================
FILE: YoutubeExplode.Converter/Utils/Extensions/GenericExtensions.cs
================================================
﻿using System;

namespace YoutubeExplode.Converter.Utils.Extensions;

internal static class GenericExtensions
{
    public static TOut Pipe<TIn, TOut>(this TIn input, Func<TIn, TOut> transform) =>
        transform(input);

    public static T Clamp<T>(this T value, T min, T max)
        where T : IComparable<T> =>
        value.CompareTo(min) <= 0 ? min
        : value.CompareTo(max) >= 0 ? max
        : value;
}



================================================
FILE: YoutubeExplode.Converter/Utils/Extensions/LanguageExtensions.cs
================================================
﻿using System;
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeExplode.Converter.Utils.Extensions;

internal static class LanguageExtensions
{
    public static string? TryGetThreeLetterCode(this Language language)
    {
        // YouTube provides either a two-letter or a three-letter language code,
        // which may or may not also contain a region identifier.
        var regionNeutralLanguageCode = language.Code.SubstringUntil(
            "-",
            StringComparison.OrdinalIgnoreCase
        );

        // Already a three-letter code
        if (regionNeutralLanguageCode.Length == 3)
            return regionNeutralLanguageCode;

        return regionNeutralLanguageCode.ToLowerInvariant() switch
        {
            "aa" => "aar",
            "ab" => "abk",
            "ae" => "ave",
            "af" => "afr",
            "ak" => "aka",
            "am" => "amh",
            "an" => "arg",
            "ar" => "ara",
            "as" => "asm",
            "av" => "ava",
            "ay" => "aym",
            "az" => "aze",
            "ba" => "bak",
            "be" => "bel",
            "bg" => "bul",
            "bh" => "bih",
            "bi" => "bis",
            "bm" => "bam",
            "bn" => "ben",
            "bo" => "bod",
            "br" => "bre",
            "bs" => "bos",
            "ca" => "cat",
            "ce" => "che",
            "ch" => "cha",
            "co" => "cos",
            "cr" => "cre",
            "cs" => "cze",
            "cu" => "chu",
            "cv" => "chv",
            "cy" => "cym",
            "da" => "dan",
            "de" => "deu",
            "dv" => "div",
            "dz" => "dzo",
            "ee" => "ewe",
            "el" => "ell",
            "en" => "eng",
            "eo" => "epo",
            "es" => "spa",
            "et" => "est",
            "eu" => "eus",
            "fa" => "fas",
            "ff" => "ful",
            "fi" => "fin",
            "fj" => "fij",
            "fo" => "fao",
            "fr" => "fra",
            "fy" => "fry",
            "ga" => "gle",
            "gd" => "gla",
            "gl" => "glg",
            "gn" => "grn",
            "gu" => "guj",
            "gv" => "glv",
            "ha" => "hau",
            "he" => "heb",
            "hi" => "hin",
            "ho" => "hmo",
            "hr" => "hrv",
            "ht" => "hat",
            "hu" => "hun",
            "hy" => "hye",
            "hz" => "her",
            "ia" => "ina",
            "id" => "ind",
            "ie" => "ile",
            "ig" => "ibo",
            "ii" => "iii",
            "ik" => "ipk",
            "in" => "ind",
            "io" => "ido",
            "is" => "isl",
            "it" => "ita",
            "iu" => "iku",
            "iw" => "heb",
            "ja" => "jpn",
            "ji" => "yid",
            "jv" => "jav",
            "jw" => "jav",
            "ka" => "kat",
            "kg" => "kon",
            "ki" => "kik",
            "kj" => "kua",
            "kk" => "kaz",
            "kl" => "kal",
            "km" => "khm",
            "kn" => "kan",
            "ko" => "kor",
            "kr" => "kau",
            "ks" => "kas",
            "ku" => "kur",
            "kv" => "kom",
            "kw" => "cor",
            "ky" => "kir",
            "la" => "lat",
            "lb" => "ltz",
            "lg" => "lug",
            "li" => "lim",
            "ln" => "lin",
            "lo" => "lao",
            "lt" => "lit",
            "lu" => "lub",
            "lv" => "lav",
            "mg" => "mlg",
            "mh" => "mah",
            "mi" => "mri",
            "mk" => "mkd",
            "ml" => "mal",
            "mn" => "mon",
            "mo" => "ron",
            "mr" => "mar",
            "ms" => "msa",
            "mt" => "mlt",
            "my" => "mya",
            "na" => "nau",
            "nb" => "nob",
            "nd" => "nde",
            "ne" => "nep",
            "ng" => "ndo",
            "nl" => "nld",
            "nn" => "nno",
            "no" => "nor",
            "nr" => "nbl",
            "nv" => "nav",
            "ny" => "nya",
            "oc" => "oci",
            "oj" => "oji",
            "om" => "orm",
            "or" => "ori",
            "os" => "oss",
            "pa" => "pan",
            "pi" => "pli",
            "pl" => "pol",
            "ps" => "pus",
            "pt" => "por",
            "qu" => "que",
            "rm" => "roh",
            "rn" => "run",
            "ro" => "ron",
            "ru" => "rus",
            "rw" => "kin",
            "sa" => "san",
            "sc" => "srd",
            "sd" => "snd",
            "se" => "sme",
            "sg" => "sag",
            "sh" => "hbs",
            "si" => "sin",
            "sk" => "slo",
            "sl" => "slv",
            "sm" => "smo",
            "sn" => "sna",
            "so" => "som",
            "sq" => "sqi",
            "sr" => "srp",
            "ss" => "ssw",
            "st" => "sot",
            "su" => "sun",
            "sv" => "swe",
            "sw" => "swa",
            "ta" => "tam",
            "te" => "tel",
            "tg" => "tgk",
            "th" => "tha",
            "ti" => "tir",
            "tk" => "tuk",
            "tl" => "tgl",
            "tn" => "tsn",
            "to" => "ton",
            "tr" => "tur",
            "ts" => "tso",
            "tt" => "tat",
            "tw" => "twi",
            "ty" => "tah",
            "ug" => "uig",
            "uk" => "ukr",
            "ur" => "urd",
            "uz" => "uzb",
            "ve" => "ven",
            "vi" => "vie",
            "vo" => "vol",
            "wa" => "wln",
            "wo" => "wol",
            "xh" => "xho",
            "yi" => "yid",
            "yo" => "yor",
            "za" => "zha",
            "zh" => "zho",
            "zu" => "zul",
            _ => null,
        };
    }
}



================================================
FILE: YoutubeExplode.Converter/Utils/Extensions/StringExtensions.cs
================================================
﻿using System;

namespace YoutubeExplode.Converter.Utils.Extensions;

internal static class StringExtensions
{
    public static string? NullIfWhiteSpace(this string s) =>
        !string.IsNullOrWhiteSpace(s) ? s : null;

    public static string SubstringUntil(
        this string str,
        string sub,
        StringComparison comparison = StringComparison.Ordinal
    )
    {
        var index = str.IndexOf(sub, comparison);
        return index < 0 ? str : str[..index];
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/GeneralSpecs.cs
================================================
﻿using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FluentAssertions;
using Gress;
using Xunit;
using Xunit.Abstractions;
using YoutubeExplode.Converter.Tests.Utils;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter.Tests;

public class GeneralSpecs(ITestOutputHelper testOutput) : IAsyncLifetime
{
    public async Task InitializeAsync() => await FFmpeg.InitializeAsync();

    public Task DisposeAsync() => Task.CompletedTask;

    [Fact]
    public async Task I_can_download_a_video_as_a_single_mp4_file()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp4");

        // Act
        await youtube.Videos.DownloadAsync("9bZkp7q19f0", filePath);

        // Assert
        MediaFormat.IsMp4File(filePath).Should().BeTrue();
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_webm_file()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.webm");

        // Act
        await youtube.Videos.DownloadAsync("9bZkp7q19f0", filePath);

        // Assert
        MediaFormat.IsWebMFile(filePath).Should().BeTrue();
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_mp3_file()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp3");

        // Act
        await youtube.Videos.DownloadAsync("9bZkp7q19f0", filePath);

        // Assert
        MediaFormat.IsMp3File(filePath).Should().BeTrue();
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_ogg_file()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.ogg");

        // Act
        await youtube.Videos.DownloadAsync("9bZkp7q19f0", filePath);

        // Assert
        MediaFormat.IsOggFile(filePath).Should().BeTrue();
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_mp4_file_with_multiple_streams()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp4");

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync("ngqcjXfggHQ");

        var audioStreamInfos = manifest
            .GetAudioOnlyStreams()
            .Where(s => s.Container == Container.Mp4)
            .OrderBy(s => s.Bitrate)
            .Take(3)
            .ToArray();

        var videoStreamInfos = manifest
            .GetVideoOnlyStreams()
            .Where(s => s.Container == Container.Mp4)
            .OrderBy(s => s.VideoQuality)
            .DistinctBy(s => s.VideoQuality.Label, StringComparer.OrdinalIgnoreCase)
            .Take(3)
            .ToArray();

        await youtube.Videos.DownloadAsync(
            videoStreamInfos.Concat<IStreamInfo>(audioStreamInfos).ToArray(),
            new ConversionRequestBuilder(filePath).Build()
        );

        // Assert
        MediaFormat.IsMp4File(filePath).Should().BeTrue();

        foreach (var streamInfo in audioStreamInfos)
        {
            if (streamInfo.AudioLanguage is not null)
            {
                FileEx
                    .ContainsBytes(
                        filePath,
                        Encoding.ASCII.GetBytes(streamInfo.AudioLanguage.Value.Name)
                    )
                    .Should()
                    .BeTrue();
            }
        }

        foreach (var streamInfo in videoStreamInfos)
        {
            FileEx
                .ContainsBytes(filePath, Encoding.ASCII.GetBytes(streamInfo.VideoQuality.Label))
                .Should()
                .BeTrue();
        }
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_webm_file_with_multiple_streams()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.webm");

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync("ngqcjXfggHQ");

        var audioStreamInfos = manifest
            .GetAudioOnlyStreams()
            .Where(s => s.Container == Container.WebM)
            .OrderBy(s => s.Bitrate)
            .Take(3)
            .ToArray();

        var videoStreamInfos = manifest
            .GetVideoOnlyStreams()
            .Where(s => s.Container == Container.WebM)
            .OrderBy(s => s.VideoQuality)
            .DistinctBy(s => s.VideoQuality.Label, StringComparer.OrdinalIgnoreCase)
            .Take(3)
            .ToArray();

        await youtube.Videos.DownloadAsync(
            videoStreamInfos.Concat<IStreamInfo>(audioStreamInfos).ToArray(),
            new ConversionRequestBuilder(filePath).Build()
        );

        // Assert
        MediaFormat.IsWebMFile(filePath).Should().BeTrue();

        foreach (var streamInfo in audioStreamInfos)
        {
            if (streamInfo.AudioLanguage is not null)
            {
                FileEx
                    .ContainsBytes(
                        filePath,
                        Encoding.ASCII.GetBytes(streamInfo.AudioLanguage.Value.Name)
                    )
                    .Should()
                    .BeTrue();
            }
        }

        foreach (var streamInfo in videoStreamInfos)
        {
            FileEx
                .ContainsBytes(filePath, Encoding.ASCII.GetBytes(streamInfo.VideoQuality.Label))
                .Should()
                .BeTrue();
        }
    }

    [Fact]
    public async Task I_can_download_a_video_using_custom_conversion_settings()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp3");

        // Act
        await youtube.Videos.DownloadAsync(
            "9bZkp7q19f0",
            filePath,
            o =>
                o.SetFFmpegPath(FFmpeg.FilePath)
                    .SetContainer("mp4")
                    .SetPreset(ConversionPreset.UltraFast)
        );

        // Assert
        MediaFormat.IsMp4File(filePath).Should().BeTrue();
    }

    [Fact]
    public async Task I_can_try_to_download_a_video_and_get_an_error_if_the_conversion_settings_are_invalid()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp4");

        // Act & assert
        var ex = await Assert.ThrowsAnyAsync<Exception>(async () =>
            await youtube.Videos.DownloadAsync(
                "9bZkp7q19f0",
                filePath,
                o =>
                    o.SetFFmpegPath(FFmpeg.FilePath)
                        .SetContainer("invalid_format")
                        .SetPreset(ConversionPreset.UltraFast)
            )
        );

        Directory.EnumerateFiles(dir.Path, "*", SearchOption.AllDirectories).Should().BeEmpty();

        testOutput.WriteLine(ex.ToString());
    }

    [Fact]
    public async Task I_can_download_a_video_while_tracking_progress()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp3");

        var progress = new ProgressCollector<double>();

        // Act
        await youtube.Videos.DownloadAsync("9bZkp7q19f0", filePath, progress);

        // Assert
        var progressValues = progress.GetValues();
        progressValues.Should().NotBeEmpty();
        progressValues.Should().Contain(p => p >= 0.99);
        progressValues.Should().NotContain(p => p < 0 || p > 1);

        foreach (var value in progressValues)
            testOutput.WriteLine($"Progress: {value:P2}");
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/SubtitleSpecs.cs
================================================
﻿using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Converter.Tests.Utils;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Converter.Tests;

public class SubtitleSpecs : IAsyncLifetime
{
    public async Task InitializeAsync() => await FFmpeg.InitializeAsync();

    public Task DisposeAsync() => Task.CompletedTask;

    [Fact]
    public async Task I_can_download_a_video_as_a_single_mp4_file_with_subtitles()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.mp4");

        var streamManifest = await youtube.Videos.Streams.GetManifestAsync("NtQkz0aRDe8");
        var streamInfos = streamManifest
            .GetVideoStreams()
            .Where(s => s.Container == Container.Mp4)
            .OrderBy(s => s.Size)
            .Take(1)
            .ToArray();

        var trackManifest = await youtube.Videos.ClosedCaptions.GetManifestAsync("NtQkz0aRDe8");
        var trackInfos = trackManifest.Tracks;

        // Act
        await youtube.Videos.DownloadAsync(
            streamInfos,
            trackInfos,
            new ConversionRequestBuilder(filePath).Build()
        );

        // Assert
        MediaFormat.IsMp4File(filePath).Should().BeTrue();

        foreach (var trackInfo in trackInfos)
        {
            FileEx
                .ContainsBytes(filePath, Encoding.ASCII.GetBytes(trackInfo.Language.Name))
                .Should()
                .BeTrue();
        }
    }

    [Fact]
    public async Task I_can_download_a_video_as_a_single_webm_file_with_subtitles()
    {
        // Arrange
        var youtube = new YoutubeClient();

        using var dir = TempDir.Create();
        var filePath = Path.Combine(dir.Path, "video.webm");

        var streamManifest = await youtube.Videos.Streams.GetManifestAsync("NtQkz0aRDe8");
        var streamInfos = streamManifest
            .GetVideoStreams()
            .Where(s => s.Container == Container.WebM)
            .OrderBy(s => s.Size)
            .Take(1)
            .ToArray();

        var trackManifest = await youtube.Videos.ClosedCaptions.GetManifestAsync("NtQkz0aRDe8");
        var trackInfos = trackManifest.Tracks;

        // Act
        await youtube.Videos.DownloadAsync(
            streamInfos,
            trackInfos,
            new ConversionRequestBuilder(filePath).Build()
        );

        // Assert
        MediaFormat.IsWebMFile(filePath).Should().BeTrue();

        foreach (var trackInfo in trackInfos)
        {
            FileEx
                .ContainsBytes(filePath, Encoding.ASCII.GetBytes(trackInfo.Language.Name))
                .Should()
                .BeTrue();
        }
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/xunit.runner.json
================================================
﻿{
  "$schema": "https://xunit.net/schema/current/xunit.runner.schema.json",
  "methodDisplayOptions": "all",
  "methodDisplay": "method"
}


================================================
FILE: YoutubeExplode.Converter.Tests/YoutubeExplode.Converter.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <Content Include="xunit.runner.json" CopyToOutputDirectory="PreserveNewest" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="coverlet.collector" Version="6.0.4" PrivateAssets="all" />
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
    <PackageReference Include="FluentAssertions" Version="8.3.0" />
    <PackageReference Include="GitHubActionsTestLogger" Version="2.4.1" PrivateAssets="all" />
    <PackageReference Include="Gress" Version="2.1.1" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.0" />
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.0" PrivateAssets="all" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\YoutubeExplode.Converter\YoutubeExplode.Converter.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/FFmpeg.cs
================================================
﻿using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Http;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Converter.Tests.Utils.Extensions;

namespace YoutubeExplode.Converter.Tests.Utils;

public static class FFmpeg
{
    private static readonly SemaphoreSlim Lock = new(1, 1);

    public static Version Version { get; } = new(7, 0);

    private static string FileName { get; } = OperatingSystem.IsWindows() ? "ffmpeg.exe" : "ffmpeg";

    public static string FilePath { get; } =
        Path.Combine(
            Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
                ?? Directory.GetCurrentDirectory(),
            FileName
        );

    private static string GetDownloadUrl()
    {
        static string GetPlatformMoniker()
        {
            if (OperatingSystem.IsWindows())
                return "windows";

            if (OperatingSystem.IsLinux())
                return "linux";

            if (OperatingSystem.IsMacOS())
                return "osx";

            throw new NotSupportedException("Unsupported OS platform.");
        }

        static string GetArchitectureMoniker()
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
                return "x64";

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
                return "x86";

            if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                return "arm64";

            throw new NotSupportedException("Unsupported architecture.");
        }

        var plat = GetPlatformMoniker();
        var arch = GetArchitectureMoniker();

        return $"https://github.com/Tyrrrz/FFmpegBin/releases/download/{Version}/ffmpeg-{plat}-{arch}.zip";
    }

    private static byte[] GetDownloadHash()
    {
        static string GetHashString()
        {
            if (OperatingSystem.IsWindows())
            {
                if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
                    return "96f2d2fae3a298adadf8aaa19c8b79c04ba18afef61f8b8d157032ccd5170992";

                if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
                    return "81b49b5d9cd3ff9ace26f29b0b3cf7cd6358769f27ad32f8079b14a9db0a1e7a";

                if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                    return "58efff14efe66ae666f9d9145ee035e360e80cc0d61b0ebc4162e3528e7aa933";
            }

            if (OperatingSystem.IsLinux())
            {
                if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
                    return "d1e03fb8dbe439b5f626706140973d48e5704bf0b30d529828a0fcb8cf5abed8";
            }

            if (OperatingSystem.IsMacOS())
            {
                if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
                    return "af9ef6994ef259ae3ae6dc215170c80db5d4390ea7cfe53cc30a544dd8f68a9b";

                if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                    return "d799c74e8b17bd40b42cf7a2ad02b6045022085bcd14ecfaea3cd1012d6add30";
            }

            throw new NotSupportedException("Unsupported architecture.");
        }

        var hashString = GetHashString();

        return Enumerable
            .Range(0, hashString.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(hashString.Substring(x, 2), 16))
            .ToArray();
    }

    private static async ValueTask DownloadAsync()
    {
        using var archiveFile = TempFile.Create();
        using var http = new HttpClient();

        // Download the archive
        await http.DownloadAsync(GetDownloadUrl(), archiveFile.Path);

        // Verify the hash
        await using (var archiveStream = File.OpenRead(archiveFile.Path))
        {
            var expectedHash = GetDownloadHash();
            var actualHash = await SHA256.HashDataAsync(archiveStream);

            if (!actualHash.SequenceEqual(expectedHash))
                throw new Exception("Downloaded archive has invalid hash.");
        }

        // Extract the executable
        using (var zip = ZipFile.OpenRead(archiveFile.Path))
        {
            var entry =
                zip.GetEntry(FileName)
                ?? throw new FileNotFoundException(
                    "Downloaded archive doesn't contain the FFmpeg executable."
                );

            entry.ExtractToFile(FilePath, true);
        }

        // Add the execute permission on Unix
        if (!OperatingSystem.IsWindows())
        {
            File.SetUnixFileMode(
                FilePath,
                File.GetUnixFileMode(FilePath) | UnixFileMode.UserExecute
            );
        }
    }

    public static async ValueTask InitializeAsync()
    {
        await Lock.WaitAsync();

        try
        {
            if (!File.Exists(FilePath))
                await DownloadAsync();
        }
        finally
        {
            Lock.Release();
        }
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/FileEx.cs
================================================
﻿using System.IO;

namespace YoutubeExplode.Converter.Tests.Utils;

internal static class FileEx
{
    public static bool ContainsBytes(string filePath, byte[] data)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new BinaryReader(stream);

        var referenceIndex = 0;

        while (stream.Position < stream.Length)
        {
            if (reader.ReadByte() == data[referenceIndex])
            {
                referenceIndex++;
            }
            else
            {
                referenceIndex = 0;
            }

            if (referenceIndex >= data.Length)
                return true;
        }

        return false;
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/MediaFormat.cs
================================================
﻿using System.IO;

namespace YoutubeExplode.Converter.Tests.Utils;

internal static class MediaFormat
{
    public static bool IsMp4File(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new BinaryReader(stream);

        // Skip 4 bytes
        stream.Seek(4, SeekOrigin.Current);

        // Expect: 66 74 79 70

        if (reader.ReadByte() != 0x66)
            return false;

        if (reader.ReadByte() != 0x74)
            return false;

        if (reader.ReadByte() != 0x79)
            return false;

        if (reader.ReadByte() != 0x70)
            return false;

        return true;
    }

    public static bool IsWebMFile(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new BinaryReader(stream);

        // Expect: 1A 45 DF A3

        if (reader.ReadByte() != 0x1A)
            return false;

        if (reader.ReadByte() != 0x45)
            return false;

        if (reader.ReadByte() != 0xDF)
            return false;

        if (reader.ReadByte() != 0xA3)
            return false;

        return true;
    }

    public static bool IsMp3File(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new BinaryReader(stream);

        // Assume ID3 container is present
        // Expect: 49 44 33

        if (reader.ReadByte() != 0x49)
            return false;

        if (reader.ReadByte() != 0x44)
            return false;

        if (reader.ReadByte() != 0x33)
            return false;

        return true;
    }

    public static bool IsOggFile(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new BinaryReader(stream);

        // Expect: 4F 67 67 53

        if (reader.ReadByte() != 0x4F)
            return false;

        if (reader.ReadByte() != 0x67)
            return false;

        if (reader.ReadByte() != 0x67)
            return false;

        if (reader.ReadByte() != 0x53)
            return false;

        return true;
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/TempDir.cs
================================================
﻿using System;
using System.IO;
using System.Reflection;
using PathEx = System.IO.Path;

namespace YoutubeExplode.Converter.Tests.Utils;

internal partial class TempDir(string path) : IDisposable
{
    public string Path { get; } = path;

    public void Dispose()
    {
        try
        {
            Directory.Delete(Path, true);
        }
        catch (DirectoryNotFoundException) { }
    }
}

internal partial class TempDir
{
    public static TempDir Create()
    {
        var dirPath = PathEx.Combine(
            PathEx.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
                ?? Directory.GetCurrentDirectory(),
            "Temp",
            Guid.NewGuid().ToString()
        );

        Directory.CreateDirectory(dirPath);

        return new TempDir(dirPath);
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/TempFile.cs
================================================
﻿using System;
using System.IO;
using System.Reflection;
using PathEx = System.IO.Path;

namespace YoutubeExplode.Converter.Tests.Utils;

internal partial class TempFile(string path) : IDisposable
{
    public string Path { get; } = path;

    public void Dispose()
    {
        try
        {
            File.Delete(Path);
        }
        catch (FileNotFoundException) { }
    }
}

internal partial class TempFile
{
    public static TempFile Create()
    {
        var dirPath = PathEx.Combine(
            PathEx.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
                ?? Directory.GetCurrentDirectory(),
            "Temp"
        );

        Directory.CreateDirectory(dirPath);

        var filePath = PathEx.Combine(dirPath, Guid.NewGuid() + ".tmp");

        return new TempFile(filePath);
    }
}



================================================
FILE: YoutubeExplode.Converter.Tests/Utils/Extensions/HttpExtensions.cs
================================================
﻿using System.IO;
using System.Net.Http;
using System.Threading.Tasks;

namespace YoutubeExplode.Converter.Tests.Utils.Extensions;

internal static class HttpExtensions
{
    public static async Task DownloadAsync(this HttpClient http, string url, string filePath)
    {
        using var response = await http.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
        response.EnsureSuccessStatusCode();

        await using var source = await response.Content.ReadAsStreamAsync();
        await using var destination = File.Create(filePath);

        await source.CopyToAsync(destination);
    }
}



================================================
FILE: YoutubeExplode.Demo.Cli/Program.cs
================================================
﻿using System;
using System.Threading.Tasks;
using YoutubeExplode.Demo.Cli.Utils;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Demo.Cli;

// This demo prompts for video ID and downloads one media stream.
// It's intended to be very simple and straight to the point.
// For a more involved example - check out the WPF demo.
public static class Program
{
    public static async Task Main()
    {
        Console.Title = "YoutubeExplode Demo";

        var youtube = new YoutubeClient();

        // Get the video ID
        Console.Write("Enter YouTube video ID or URL: ");
        var videoId = VideoId.Parse(Console.ReadLine() ?? "");

        // Get available streams and choose the best muxed (audio + video) stream
        var streamManifest = await youtube.Videos.Streams.GetManifestAsync(videoId);
        var streamInfo = streamManifest.GetMuxedStreams().TryGetWithHighestVideoQuality();
        if (streamInfo is null)
        {
            // Available streams vary depending on the video and it's possible
            // there may not be any muxed streams at all.
            // See the readme to learn how to handle adaptive streams.
            Console.Error.WriteLine("This video has no muxed streams.");
            return;
        }

        // Download the stream
        var fileName = $"{videoId}.{streamInfo.Container.Name}";

        Console.Write(
            $"Downloading stream: {streamInfo.VideoQuality.Label} / {streamInfo.Container.Name}... "
        );

        using (var progress = new ConsoleProgress())
            await youtube.Videos.Streams.DownloadAsync(streamInfo, fileName, progress);

        Console.WriteLine("Done");
        Console.WriteLine($"Video saved to '{fileName}'");
    }
}



================================================
FILE: YoutubeExplode.Demo.Cli/YoutubeExplode.Demo.Cli.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ApplicationIcon>../favicon.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\YoutubeExplode\YoutubeExplode.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode.Demo.Cli/Utils/ConsoleProgress.cs
================================================
﻿using System;
using System.IO;

namespace YoutubeExplode.Demo.Cli.Utils;

internal class ConsoleProgress(TextWriter writer) : IProgress<double>, IDisposable
{
    private readonly int _posX = Console.CursorLeft;
    private readonly int _posY = Console.CursorTop;

    private int _lastLength;

    public ConsoleProgress()
        : this(Console.Out) { }

    private void EraseLast()
    {
        if (_lastLength > 0)
        {
            Console.SetCursorPosition(_posX, _posY);
            writer.Write(new string(' ', _lastLength));
            Console.SetCursorPosition(_posX, _posY);
        }
    }

    private void Write(string text)
    {
        EraseLast();
        writer.Write(text);
        _lastLength = text.Length;
    }

    public void Report(double progress) => Write($"{progress:P1}");

    public void Dispose() => EraseLast();
}



================================================
FILE: YoutubeExplode.Demo.Gui/App.axaml
================================================
﻿<Application
    x:Class="YoutubeExplode.Demo.Gui.App"
    xmlns="https://github.com/avaloniaui"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:materialAssists="clr-namespace:Material.Styles.Assists;assembly=Material.Styles"
    xmlns:materialControls="clr-namespace:Material.Styles.Controls;assembly=Material.Styles"
    xmlns:materialIcons="clr-namespace:Material.Icons.Avalonia;assembly=Material.Icons.Avalonia"
    xmlns:materialStyles="clr-namespace:Material.Styles.Themes;assembly=Material.Styles"
    RequestedThemeVariant="Light">
    <Application.Styles>
        <materialStyles:MaterialTheme />
        <materialIcons:MaterialIconStyles />

        <!--  Card  -->
        <Style Selector="materialControls|Card">
            <Setter Property="materialAssists:ShadowAssist.ShadowDepth" Value="Depth1" />
        </Style>

        <!--  Expander  -->
        <Style Selector="Expander">
            <Setter Property="materialAssists:ShadowAssist.ShadowDepth" Value="Depth1" />

            <Style Selector="^ /template/ LayoutTransformControl#PART_ToggleTransform">
                <Setter Property="Cursor" Value="Hand" />
            </Style>
        </Style>

        <!--  ProgressBar  -->
        <Style Selector="ProgressBar">
            <Setter Property="Minimum" Value="0" />
            <Setter Property="Maximum" Value="1" />
            <Setter Property="Foreground" Value="{DynamicResource MaterialSecondaryMidBrush}" />
            <Setter Property="materialAssists:TransitionAssist.DisableTransitions" Value="True" />

            <Style Selector="^:horizontal">
                <Setter Property="MinHeight" Value="0" />
            </Style>
        </Style>
    </Application.Styles>
</Application>


================================================
FILE: YoutubeExplode.Demo.Gui/App.axaml.cs
================================================
﻿using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using Material.Styles.Themes;
using YoutubeExplode.Demo.Gui.Views;

namespace YoutubeExplode.Demo.Gui;

public class App : Application
{
    public override void Initialize()
    {
        base.Initialize();

        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktopLifetime)
            desktopLifetime.MainWindow = new MainWindow();

        base.OnFrameworkInitializationCompleted();

        // Set up custom theme colors
        this.LocateMaterialTheme<MaterialThemeBase>().CurrentTheme = Theme.Create(
            Theme.Light,
            Color.Parse("#343838"),
            Color.Parse("#F9A825")
        );
    }
}



================================================
FILE: YoutubeExplode.Demo.Gui/Program.cs
================================================
﻿using System;
using Avalonia;

namespace YoutubeExplode.Demo.Gui;

public static class Program
{
    public static AppBuilder BuildAvaloniaApp() =>
        AppBuilder.Configure<App>().UsePlatformDetect().LogToTrace();

    [STAThread]
    public static int Main(string[] args) =>
        BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
}



================================================
FILE: YoutubeExplode.Demo.Gui/YoutubeExplode.Demo.Gui.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ApplicationIcon>../favicon.ico</ApplicationIcon>
    <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
  </PropertyGroup>
  <ItemGroup>
    <AvaloniaResource Include="..\favicon.ico" Link="favicon.ico" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="AsyncImageLoader.Avalonia" Version="3.3.0" />
    <PackageReference Include="Avalonia" Version="11.3.0" />
    <PackageReference Include="Avalonia.Desktop" Version="11.3.0" />
    <PackageReference
      Include="Avalonia.Diagnostics"
      Version="11.3.0"
      Condition="'$(Configuration)' == 'Debug'"
    />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
    <PackageReference Include="Material.Avalonia" Version="3.9.2" />
    <PackageReference Include="Material.Icons.Avalonia" Version="2.2.0" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\YoutubeExplode\YoutubeExplode.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode.Demo.Gui/Converters/BoolToYesNoStringConverter.cs
================================================
﻿using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace YoutubeExplode.Demo.Gui.Converters;

public class BoolToYesNoStringConverter : IValueConverter
{
    public static BoolToYesNoStringConverter Instance { get; } = new();

    public object? Convert(
        object? value,
        Type targetType,
        object? parameter,
        CultureInfo culture
    ) =>
        value is bool boolValue
            ? boolValue
                ? "yes"
                : "no"
            : default;

    public object ConvertBack(
        object? value,
        Type targetType,
        object? parameter,
        CultureInfo culture
    ) => throw new NotSupportedException();
}



================================================
FILE: YoutubeExplode.Demo.Gui/Converters/EnumerableToJoinedStringConverter.cs
================================================
﻿using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using Avalonia.Data.Converters;

namespace YoutubeExplode.Demo.Gui.Converters;

public class EnumerableToJoinedStringConverter : IValueConverter
{
    public static EnumerableToJoinedStringConverter Instance { get; } = new();

    public object? Convert(
        object? value,
        Type targetType,
        object? parameter,
        CultureInfo culture
    ) =>
        value is IEnumerable enumerableValue
            ? string.Join(parameter as string ?? ", ", enumerableValue.Cast<object>())
            : default;

    public object ConvertBack(
        object? value,
        Type targetType,
        object? parameter,
        CultureInfo culture
    ) => throw new NotSupportedException();
}



================================================
FILE: YoutubeExplode.Demo.Gui/Utils/DelegateProgress.cs
================================================
﻿using System;

namespace YoutubeExplode.Demo.Gui.Utils;

// Straightforward implementation of IProgress<T> that simply invokes a delegate
// without using any synchronization (unlike the built-in Progress<T> class).
// This is required in Avalonia because the built-in Progress<T> class causes race conditions.
internal class DelegateProgress<T>(Action<T> report) : IProgress<T>
{
    public void Report(T value) => report(value);
}



================================================
FILE: YoutubeExplode.Demo.Gui/Utils/PathEx.cs
================================================
﻿using System.IO;

namespace YoutubeExplode.Demo.Gui.Utils;

internal static class PathEx
{
    public static string SanitizeFileName(string fileName, char replacement = '_')
    {
        foreach (var invalidChar in Path.GetInvalidFileNameChars())
            fileName = fileName.Replace(invalidChar, replacement);

        return fileName;
    }
}



================================================
FILE: YoutubeExplode.Demo.Gui/Utils/Extensions/AvaloniaExtensions.cs
================================================
﻿using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.VisualTree;

namespace YoutubeExplode.Demo.Gui.Utils.Extensions;

internal static class AvaloniaExtensions
{
    public static Window? TryGetMainWindow(this IApplicationLifetime lifetime) =>
        lifetime is IClassicDesktopStyleApplicationLifetime desktopLifetime
            ? desktopLifetime.MainWindow
            : null;

    public static TopLevel? TryGetTopLevel(this IApplicationLifetime lifetime) =>
        lifetime.TryGetMainWindow()
        ?? (lifetime as ISingleViewApplicationLifetime)?.MainView?.GetVisualRoot() as TopLevel;
}



================================================
FILE: YoutubeExplode.Demo.Gui/ViewModels/MainViewModel.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using YoutubeExplode.Channels;
using YoutubeExplode.Common;
using YoutubeExplode.Demo.Gui.Utils;
using YoutubeExplode.Demo.Gui.Utils.Extensions;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Demo.Gui.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly YoutubeClient _youtube = new();

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(PullMetadataCommand))]
    [NotifyCanExecuteChangedFor(nameof(DownloadStreamCommand))]
    [NotifyCanExecuteChangedFor(nameof(DownloadClosedCaptionTrackCommand))]
    public partial bool IsBusy { get; set; }

    [ObservableProperty]
    public partial double Progress { get; set; }

    [ObservableProperty]
    public partial bool IsProgressIndeterminate { get; set; }

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(PullMetadataCommand))]
    public partial string? Query { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    [NotifyCanExecuteChangedFor(nameof(DownloadStreamCommand))]
    [NotifyCanExecuteChangedFor(nameof(DownloadClosedCaptionTrackCommand))]
    public partial Video? Video { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial Thumbnail? VideoThumbnail { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial Channel? Channel { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial Thumbnail? ChannelThumbnail { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial IReadOnlyList<MuxedStreamInfo>? MuxedStreamInfos { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial IReadOnlyList<AudioOnlyStreamInfo>? AudioOnlyStreamInfos { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial IReadOnlyList<VideoOnlyStreamInfo>? VideoOnlyStreamInfos { get; set; }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDataAvailable))]
    public partial IReadOnlyList<ClosedCaptionTrackInfo>? ClosedCaptionTrackInfos { get; set; }

    public bool IsDataAvailable =>
        Video is not null
        && VideoThumbnail is not null
        && Channel is not null
        && ChannelThumbnail is not null
        && MuxedStreamInfos is not null
        && AudioOnlyStreamInfos is not null
        && VideoOnlyStreamInfos is not null
        && ClosedCaptionTrackInfos is not null;

    private async Task<string?> PromptSaveFilePathAsync(
        string defaultFileName,
        IReadOnlyList<string>? fileTypes
    )
    {
        var topLevel =
            Application.Current?.ApplicationLifetime?.TryGetTopLevel()
            ?? throw new ApplicationException("Could not find the top-level visual element.");

        var file = await topLevel.StorageProvider.SaveFilePickerAsync(
            new FilePickerSaveOptions
            {
                SuggestedFileName = defaultFileName,
                FileTypeChoices = fileTypes
                    ?.Select(t => new FilePickerFileType($"{t} file") { Patterns = [$"*.{t}"] })
                    .ToArray(),
                DefaultExtension = Path.GetExtension(defaultFileName),
            }
        );

        return file?.Path.LocalPath;
    }

    private bool CanPullMetadata() => !IsBusy && !string.IsNullOrWhiteSpace(Query);

    [RelayCommand(CanExecute = nameof(CanPullMetadata))]
    private async Task PullMetadataAsync()
    {
        if (IsBusy || string.IsNullOrWhiteSpace(Query))
            return;

        try
        {
            // Enter busy state
            IsBusy = true;
            IsProgressIndeterminate = true;

            // Reset data
            Video = null;
            VideoThumbnail = null;
            Channel = null;
            ChannelThumbnail = null;
            MuxedStreamInfos = null;
            AudioOnlyStreamInfos = null;
            VideoOnlyStreamInfos = null;
            ClosedCaptionTrackInfos = null;

            // Get data
            var videoIdOrUrl = Query.Trim();

            Video = await _youtube.Videos.GetAsync(videoIdOrUrl);
            VideoThumbnail = Video.Thumbnails.GetWithHighestResolution();

            Channel = await _youtube.Channels.GetAsync(Video.Author.ChannelId);
            ChannelThumbnail = Channel.Thumbnails.GetWithHighestResolution();

            var streamManifest = await _youtube.Videos.Streams.GetManifestAsync(videoIdOrUrl);

            MuxedStreamInfos = streamManifest
                .GetMuxedStreams()
                .OrderByDescending(s => s.VideoQuality)
                .ToArray();

            AudioOnlyStreamInfos = streamManifest
                .GetAudioOnlyStreams()
                .OrderByDescending(s => s.Bitrate)
                .ToArray();

            VideoOnlyStreamInfos = streamManifest
                .GetVideoOnlyStreams()
                .OrderByDescending(s => s.VideoQuality)
                .ToArray();

            var trackManifest = await _youtube.Videos.ClosedCaptions.GetManifestAsync(videoIdOrUrl);

            ClosedCaptionTrackInfos = trackManifest.Tracks.OrderBy(t => t.Language.Name).ToArray();
        }
        finally
        {
            // Exit busy state
            IsBusy = false;
            IsProgressIndeterminate = false;
        }
    }

    private bool CanDownloadStream(IStreamInfo? streamInfo) =>
        !IsBusy && Video is not null && streamInfo is not null;

    [RelayCommand(CanExecute = nameof(CanDownloadStream))]
    private async Task DownloadStreamAsync(IStreamInfo? streamInfo)
    {
        if (IsBusy || Video is null || streamInfo is null)
            return;

        try
        {
            // Enter busy state
            IsBusy = true;
            Progress = 0;

            // Generate a default file name
            var defaultFileName = PathEx.SanitizeFileName(
                $"{Video.Title}.{streamInfo.Container.Name}"
            );

            // Prompt for file path
            var filePath = await PromptSaveFilePathAsync(
                defaultFileName,
                [streamInfo.Container.Name]
            );

            if (string.IsNullOrWhiteSpace(filePath))
                return;

            // Set up progress reporting
            var progressHandler = new DelegateProgress<double>(p => Progress = p);

            // Download to the file
            await _youtube.Videos.Streams.DownloadAsync(streamInfo, filePath, progressHandler);
        }
        finally
        {
            // Exit busy state
            IsBusy = false;
            Progress = 0;
        }
    }

    private bool CanDownloadClosedCaptionTrack(ClosedCaptionTrackInfo? trackInfo) =>
        !IsBusy && Video is not null && trackInfo is not null;

    [RelayCommand(CanExecute = nameof(CanDownloadClosedCaptionTrack))]
    private async Task DownloadClosedCaptionTrackAsync(ClosedCaptionTrackInfo? trackInfo)
    {
        if (IsBusy || Video is null || trackInfo is null)
            return;

        try
        {
            // Enter busy state
            IsBusy = true;
            Progress = 0;

            // Generate a default file name
            var defaultFileName = PathEx.SanitizeFileName(
                $"{Video.Title}.{trackInfo.Language.Name}.srt"
            );

            // Prompt for file path
            var filePath = await PromptSaveFilePathAsync(defaultFileName, ["srt"]);
            if (string.IsNullOrWhiteSpace(filePath))
                return;

            // Set up progress reporting
            var progressHandler = new DelegateProgress<double>(p => Progress = p);

            // Download to the file
            await _youtube.Videos.ClosedCaptions.DownloadAsync(
                trackInfo,
                filePath,
                progressHandler
            );
        }
        finally
        {
            // Exit busy state
            IsBusy = false;
            Progress = 0;
        }
    }
}



================================================
FILE: YoutubeExplode.Demo.Gui/Views/MainWindow.axaml
================================================
﻿<Window
    x:Class="YoutubeExplode.Demo.Gui.Views.MainWindow"
    xmlns="https://github.com/avaloniaui"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:asyncImageLoader="clr-namespace:AsyncImageLoader;assembly=AsyncImageLoader.Avalonia"
    xmlns:converters="clr-namespace:YoutubeExplode.Demo.Gui.Converters"
    xmlns:materialControls="clr-namespace:Material.Styles.Controls;assembly=Material.Styles"
    xmlns:materialIcons="clr-namespace:Material.Icons.Avalonia;assembly=Material.Icons.Avalonia"
    xmlns:viewModels="clr-namespace:YoutubeExplode.Demo.Gui.ViewModels"
    Title="YoutubeExplode Demo"
    Width="720"
    Height="620"
    x:DataType="viewModels:MainViewModel"
    Icon="/favicon.ico"
    Loaded="Window_OnLoaded"
    WindowStartupLocation="CenterScreen">
    <Window.DataContext>
        <viewModels:MainViewModel />
    </Window.DataContext>

    <DockPanel>
        <!--  Header  -->
        <StackPanel
            Background="{DynamicResource MaterialDarkBackgroundBrush}"
            DockPanel.Dock="Top"
            Orientation="Vertical">
            <!--  Query  -->
            <materialControls:Card Margin="12">
                <TextBox
                    x:Name="QueryTextBox"
                    FontSize="16"
                    Text="{Binding Query}"
                    Theme="{DynamicResource SoloTextBox}"
                    Watermark="YouTube video URL or ID">
                    <TextBox.InnerRightContent>
                        <Button
                            Padding="4"
                            Command="{Binding PullMetadataCommand}"
                            IsDefault="True"
                            Theme="{DynamicResource MaterialFlatButton}">
                            <materialIcons:MaterialIcon
                                Width="24"
                                Height="24"
                                Kind="ArrowRight" />
                        </Button>
                    </TextBox.InnerRightContent>
                </TextBox>
            </materialControls:Card>

            <!--  Progress  -->
            <ProgressBar
                Height="2"
                Background="Transparent"
                IsIndeterminate="{Binding IsProgressIndeterminate}"
                Value="{Binding Progress}" />
        </StackPanel>

        <!--  Video info  -->
        <ScrollViewer
            DockPanel.Dock="Bottom"
            HorizontalScrollBarVisibility="Disabled"
            IsVisible="{Binding IsDataAvailable}"
            VerticalScrollBarVisibility="Auto">
            <StackPanel Orientation="Vertical">
                <Panel HorizontalAlignment="Stretch" Background="Black">
                    <!--  Thumbnail  -->
                    <Image Height="180" asyncImageLoader:ImageLoader.Source="{Binding VideoThumbnail.Url}" />

                    <!--  Duration  -->
                    <TextBlock
                        Margin="0,0,8,6"
                        Padding="2"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Bottom"
                        Background="Black"
                        Foreground="{DynamicResource MaterialDarkForegroundBrush}"
                        Text="{Binding Video.Duration, TargetNullValue=Live}" />
                </Panel>

                <!--  Basic metadata  -->
                <materialControls:Card Margin="8">
                    <StackPanel Orientation="Vertical">
                        <!--  Title  -->
                        <TextBlock
                            Margin="4"
                            FontSize="18"
                            FontWeight="SemiBold"
                            Text="{Binding Video.Title}"
                            TextTrimming="CharacterEllipsis" />

                        <Grid ColumnDefinitions="Auto,*,Auto" RowDefinitions="Auto,Auto,Auto">
                            <!--  Author image  -->
                            <Image
                                Grid.Row="0"
                                Grid.RowSpan="3"
                                Grid.Column="0"
                                Width="50"
                                Height="50"
                                Margin="6,6,0,6"
                                VerticalAlignment="Top"
                                asyncImageLoader:ImageLoader.Source="{Binding ChannelThumbnail.Url}"
                                DockPanel.Dock="Left" />

                            <!--  Author name  -->
                            <TextBlock
                                Grid.Row="0"
                                Grid.Column="1"
                                Margin="6,6,6,4"
                                VerticalAlignment="Bottom"
                                FontSize="14"
                                Text="{Binding Channel.Title}" />

                            <!--  Views  -->
                            <TextBlock
                                Grid.Row="0"
                                Grid.Column="2"
                                Margin="6,6,6,4"
                                HorizontalAlignment="Right"
                                FontSize="16"
                                FontWeight="SemiLight">
                                <Run Text="{Binding Video.Engagement.ViewCount, StringFormat={}{0:N0}, Mode=OneWay}" />
                                <Run Text="views" />
                            </TextBlock>

                            <!--  Divider  -->
                            <Border
                                Grid.Row="1"
                                Grid.Column="1"
                                Height="2"
                                Margin="6,0,0,1"
                                HorizontalAlignment="Stretch"
                                Background="{DynamicResource MaterialDividerBrush}" />

                            <!--  Rating bar  -->
                            <ProgressBar
                                Grid.Row="1"
                                Grid.Column="2"
                                Height="2"
                                MinWidth="150"
                                Margin="0,0,6,0"
                                HorizontalAlignment="Stretch"
                                Maximum="5"
                                Minimum="1"
                                Value="{Binding Video.Engagement.AverageRating}" />

                            <!--  Upload date  -->
                            <TextBlock
                                Grid.Row="2"
                                Grid.Column="1"
                                Margin="6,4,6,6"
                                FontWeight="SemiLight"
                                Text="{Binding Video.UploadDate, StringFormat={}{0:MMM d\, yyyy}}" />

                            <!--  Likes and dislikes  -->
                            <StackPanel
                                Grid.Row="2"
                                Grid.Column="2"
                                Margin="6"
                                HorizontalAlignment="Right"
                                Orientation="Horizontal">
                                <materialIcons:MaterialIcon VerticalAlignment="Center" Kind="ThumbUp" />
                                <TextBlock
                                    Margin="3,0,0,0"
                                    VerticalAlignment="Center"
                                    FontWeight="SemiLight"
                                    Text="{Binding Video.Engagement.LikeCount, StringFormat={}{0:N0}}" />
                                <materialIcons:MaterialIcon
                                    Margin="8,0,0,0"
                                    VerticalAlignment="Center"
                                    Kind="ThumbDown" />
                                <TextBlock
                                    Margin="3,0,0,0"
                                    VerticalAlignment="Center"
                                    FontWeight="SemiLight"
                                    Text="{Binding Video.Engagement.DislikeCount, StringFormat={}{0:N0}}" />
                            </StackPanel>
                        </Grid>
                    </StackPanel>
                </materialControls:Card>

                <!--  Description  -->
                <Expander Margin="8,0,8,8">
                    <Expander.Header>
                        <StackPanel Orientation="Horizontal">
                            <materialIcons:MaterialIcon
                                Width="18"
                                Height="18"
                                VerticalAlignment="Center"
                                Kind="CommentTextOutline" />
                            <TextBlock
                                Margin="6,0,0,0"
                                VerticalAlignment="Center"
                                FontSize="15"
                                Text="Description" />
                        </StackPanel>
                    </Expander.Header>
                    <TextBlock
                        Margin="16"
                        Text="{Binding Video.Description}"
                        TextWrapping="Wrap" />
                </Expander>

                <!--  Keywords  -->
                <Expander Margin="8,0,8,8">
                    <Expander.Header>
                        <StackPanel Orientation="Horizontal">
                            <materialIcons:MaterialIcon
                                Width="18"
                                Height="18"
                                VerticalAlignment="Center"
                                Kind="Magnify" />
                            <TextBlock
                                Margin="6,0,0,0"
                                VerticalAlignment="Center"
                                FontSize="15"
                                Text="Keywords" />
                        </StackPanel>
                    </Expander.Header>
                    <TextBlock
                        Margin="16"
                        Text="{Binding Video.Keywords, Converter={x:Static converters:EnumerableToJoinedStringConverter.Instance}}"
                        TextWrapping="Wrap" />
                </Expander>

                <!--  Media streams  -->
                <Expander Margin="8,0,8,8">
                    <Expander.Header>
                        <StackPanel Orientation="Horizontal">
                            <materialIcons:MaterialIcon
                                Width="18"
                                Height="18"
                                VerticalAlignment="Center"
                                Kind="PlayCircleOutline" />
                            <TextBlock
                                Margin="6,0,0,0"
                                VerticalAlignment="Center"
                                FontSize="15"
                                Text="Media streams" />
                        </StackPanel>
                    </Expander.Header>
                    <StackPanel Orientation="Vertical">
                        <!--  Muxed  -->
                        <TextBlock
                            Margin="16,16,16,8"
                            FontSize="14"
                            Text="Muxed streams:" />
                        <ItemsControl Margin="16,0,6,0" ItemsSource="{Binding MuxedStreamInfos}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <StackPanel Orientation="Horizontal">
                                        <!--  Download button  -->
                                        <Button
                                            Padding="4"
                                            VerticalAlignment="Center"
                                            Command="{Binding $parent[Window].((viewModels:MainViewModel)DataContext).DownloadStreamCommand}"
                                            CommandParameter="{Binding}"
                                            Theme="{DynamicResource MaterialFlatButton}">
                                            <materialIcons:MaterialIcon
                                                Width="24"
                                                Height="24"
                                                Kind="Download" />
                                        </Button>

                                        <!--  Stream info  -->
                                        <TextBlock Margin="6,0,0,0" VerticalAlignment="Center">
                                            <Run Text="Quality:" />
                                            <Run FontWeight="SemiBold" Text="{Binding VideoQuality.Label, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Container:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Container, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Codecs:" />
                                            <Run FontWeight="SemiBold" Text="{Binding VideoCodec, Mode=OneWay}" /><Run Text=", " /><Run FontWeight="SemiBold" Text="{Binding AudioCodec, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Size:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Size, Mode=OneWay}" />
                                        </TextBlock>
                                    </StackPanel>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>

                        <!--  Video-only  -->
                        <TextBlock
                            Margin="16,8,16,8"
                            FontSize="14"
                            Text="Video-only streams:" />
                        <ItemsControl Margin="16,0,6,0" ItemsSource="{Binding VideoOnlyStreamInfos}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <StackPanel Orientation="Horizontal">
                                        <!--  Download button  -->
                                        <Button
                                            Padding="4"
                                            VerticalAlignment="Center"
                                            Command="{Binding $parent[Window].((viewModels:MainViewModel)DataContext).DownloadStreamCommand}"
                                            CommandParameter="{Binding}"
                                            Theme="{DynamicResource MaterialFlatButton}">
                                            <materialIcons:MaterialIcon
                                                Width="24"
                                                Height="24"
                                                Kind="Download" />
                                        </Button>

                                        <!--  Stream info  -->
                                        <TextBlock Margin="6,0,0,0" VerticalAlignment="Center">
                                            <Run Text="Quality:" />
                                            <Run FontWeight="SemiBold" Text="{Binding VideoQuality.Label, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Container:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Container, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Codec:" />
                                            <Run FontWeight="SemiBold" Text="{Binding VideoCodec, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Size:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Size, Mode=OneWay}" />
                                        </TextBlock>
                                    </StackPanel>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>

                        <!--  Audio-only  -->
                        <TextBlock
                            Margin="16,8,16,8"
                            FontSize="14"
                            Text="Audio-only streams:" />
                        <ItemsControl Margin="16,0,6,16" ItemsSource="{Binding AudioOnlyStreamInfos}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <StackPanel Orientation="Horizontal">
                                        <!--  Download button  -->
                                        <Button
                                            Padding="4"
                                            VerticalAlignment="Center"
                                            Command="{Binding $parent[Window].((viewModels:MainViewModel)DataContext).DownloadStreamCommand}"
                                            CommandParameter="{Binding}"
                                            Theme="{DynamicResource MaterialFlatButton}">
                                            <materialIcons:MaterialIcon
                                                Width="24"
                                                Height="24"
                                                Kind="Download" />
                                        </Button>

                                        <!--  Stream info  -->
                                        <TextBlock Margin="6,0,0,0" VerticalAlignment="Center">
                                            <Run Text="Container:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Container, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Codec:" />
                                            <Run FontWeight="SemiBold" Text="{Binding AudioCodec, Mode=OneWay}" />
                                            <Run />
                                            <Run Text="Size:" />
                                            <Run FontWeight="SemiBold" Text="{Binding Size, Mode=OneWay}" />
                                        </TextBlock>
                                    </StackPanel>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </StackPanel>
                </Expander>

                <!--  Closed captions  -->
                <Expander Margin="8,0,8,8">
                    <Expander.Header>
                        <StackPanel Orientation="Horizontal">
                            <materialIcons:MaterialIcon
                                Width="18"
                                Height="18"
                                VerticalAlignment="Center"
                                Kind="ClosedCaption" />
                            <TextBlock
                                Margin="6,0,0,0"
                                VerticalAlignment="Center"
                                FontSize="15"
                                Text="Closed captions" />
                        </StackPanel>
                    </Expander.Header>
                    <ItemsControl Margin="16" ItemsSource="{Binding ClosedCaptionTrackInfos}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <!--  Download button  -->
                                    <Button
                                        Padding="4"
                                        VerticalAlignment="Center"
                                        Command="{Binding $parent[Window].((viewModels:MainViewModel)DataContext).DownloadClosedCaptionTrackCommand}"
                                        CommandParameter="{Binding}"
                                        Theme="{DynamicResource MaterialFlatButton}">
                                        <materialIcons:MaterialIcon
                                            Width="24"
                                            Height="24"
                                            Kind="Download" />
                                    </Button>

                                    <!--  Closed caption track info  -->
                                    <TextBlock Margin="6,0,0,0" VerticalAlignment="Center">
                                        <Run Text="Language:" />
                                        <Run FontWeight="SemiBold" Text="{Binding Language.Name, Mode=OneWay}" />
                                        <Run />
                                        <Run Text="Auto-generated:" />
                                        <Run FontWeight="SemiBold" Text="{Binding IsAutoGenerated, Converter={x:Static converters:BoolToYesNoStringConverter.Instance}, Mode=OneWay}" />
                                    </TextBlock>
                                </StackPanel>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </Expander>
            </StackPanel>
        </ScrollViewer>
    </DockPanel>
</Window>


================================================
FILE: YoutubeExplode.Demo.Gui/Views/MainWindow.axaml.cs
================================================
﻿using System;
using Avalonia.Controls;
using Avalonia.Interactivity;
using YoutubeExplode.Demo.Gui.ViewModels;

namespace YoutubeExplode.Demo.Gui.Views;

public partial class MainWindow : Window
{
    public MainWindow() => InitializeComponent();

    public new MainViewModel DataContext
    {
        get =>
            (MainViewModel)(
                base.DataContext ?? throw new InvalidOperationException("DataContext is not set.")
            );
        set => base.DataContext = value;
    }

    private void Window_OnLoaded(object? sender, RoutedEventArgs args) => QueryTextBox.Focus();
}



================================================
FILE: YoutubeExplode.Tests/ChannelHandleSpecs.cs
================================================
﻿using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Channels;

namespace YoutubeExplode.Tests;

public class ChannelHandleSpecs
{
    [Theory]
    [InlineData("BeauMiles")]
    [InlineData("a-z.0_9")]
    public void I_can_parse_a_channel_handle_from_a_handle_string(string channelHandle)
    {
        // Act
        var parsed = ChannelHandle.Parse(channelHandle);

        // Assert
        parsed.Value.Should().Be(channelHandle);
    }

    [Theory]
    [InlineData("youtube.com/@BeauMiles", "BeauMiles")]
    [InlineData("youtube.com/@a-z.0_9", "a-z.0_9")]
    public void I_can_parse_a_channel_handle_from_a_URL_string(
        string channelUrl,
        string expectedChannelHandle
    )
    {
        // Act
        var parsed = ChannelHandle.Parse(channelUrl);

        // Assert
        parsed.Value.Should().Be(expectedChannelHandle);
    }

    [Theory]
    [InlineData("")]
    [InlineData("foo bar")]
    [InlineData("youtube.com/")]
    [InlineData("youtube.com@BeauMiles")]
    [InlineData("youtube.com/@=BeauMiles")]
    [InlineData("youtube.com/@BeauMile$")]
    [InlineData("youtube.com/@Beau+Miles")]
    [InlineData("youtube.com/?@BeauMiles")]
    public void I_can_try_to_parse_a_channel_handle_and_get_an_error_if_the_input_string_is_invalid(
        string channelHandleOrUrl
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => ChannelHandle.Parse(channelHandleOrUrl));
    }
}



================================================
FILE: YoutubeExplode.Tests/ChannelIdSpecs.cs
================================================
using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Channels;

namespace YoutubeExplode.Tests;

public class ChannelIdSpecs
{
    [Theory]
    [InlineData("UCEnBXANsKmyj2r9xVyKoDiQ")]
    [InlineData("UC46807r_RiRjH8IU-h_DrDQ")]
    public void I_can_parse_a_channel_ID_from_an_ID_string(string channelId)
    {
        // Act
        var parsed = ChannelId.Parse(channelId);

        // Assert
        parsed.Value.Should().Be(channelId);
    }

    [Theory]
    [InlineData("youtube.com/channel/UC3xnGqlcL3y-GXz5N3wiTJQ", "UC3xnGqlcL3y-GXz5N3wiTJQ")]
    [InlineData("youtube.com/channel/UCkQO3QsgTpNTsOw6ujimT5Q", "UCkQO3QsgTpNTsOw6ujimT5Q")]
    [InlineData("youtube.com/channel/UCQtjJDOYluum87LA4sI6xcg", "UCQtjJDOYluum87LA4sI6xcg")]
    public void I_can_parse_a_channel_ID_from_a_URL_string(
        string channelUrl,
        string expectedChannelId
    )
    {
        // Act
        var parsed = ChannelId.Parse(channelUrl);

        // Assert
        parsed.Value.Should().Be(expectedChannelId);
    }

    [Theory]
    [InlineData("")]
    [InlineData("UC3xnGqlcL3y-GXz5N3wiTJ")]
    [InlineData("UC3xnGqlcL y-GXz5N3wiTJQ")]
    [InlineData("youtube.com/?channel=UCUC3xnGqlcL3y-GXz5N3wiTJQ")]
    [InlineData("youtube.com/channel/asd")]
    [InlineData("youtube.com/")]
    public void I_can_try_to_parse_a_channel_ID_and_get_an_error_if_the_input_string_is_invalid(
        string channelIdOrUrl
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => ChannelId.Parse(channelIdOrUrl));
    }
}



================================================
FILE: YoutubeExplode.Tests/ChannelSlugSpecs.cs
================================================
﻿using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Channels;

namespace YoutubeExplode.Tests;

public class ChannelSlugSpecs
{
    [Theory]
    [InlineData("Tyrrrz")]
    [InlineData("BlenderFoundation")]
    public void I_can_parse_a_channel_slug_from_a_slug_string(string channelSlug)
    {
        // Act
        var parsed = ChannelSlug.Parse(channelSlug);

        // Assert
        parsed.Value.Should().Be(channelSlug);
    }

    [Theory]
    [InlineData("youtube.com/c/Tyrrrz", "Tyrrrz")]
    [InlineData("youtube.com/c/BlenderFoundation", "BlenderFoundation")]
    [InlineData(
        "youtube.com/c/%D0%9C%D0%B5%D0%BB%D0%B0%D0%BD%D1%96%D1%8F%D0%9F%D0%BE%D0%B4%D0%BE%D0%BB%D1%8F%D0%BA",
        "МеланіяПодоляк"
    )]
    public void I_can_parse_a_channel_slug_from_a_URL_string(
        string channelUrl,
        string expectedChannelSlug
    )
    {
        // Act
        var parsed = ChannelSlug.Parse(channelUrl);

        // Assert
        parsed.Value.Should().Be(expectedChannelSlug);
    }

    [Theory]
    [InlineData("")]
    [InlineData("foo bar")]
    [InlineData("youtube.com/?c=Tyrrrz")]
    [InlineData("youtube.com/channel/Tyrrrz")]
    [InlineData("youtube.com/")]
    public void I_can_try_to_parse_a_channel_slug_and_get_an_error_if_the_input_string_is_invalid(
        string channelSlugOrUrl
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => ChannelSlug.Parse(channelSlugOrUrl));
    }
}



================================================
FILE: YoutubeExplode.Tests/ChannelSpecs.cs
================================================
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Common;
using YoutubeExplode.Tests.TestData;

namespace YoutubeExplode.Tests;

public class ChannelSpecs
{
    [Fact]
    public async Task I_can_get_the_metadata_of_a_channel()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channel = await youtube.Channels.GetAsync(ChannelIds.Normal);

        // Assert
        channel.Id.Value.Should().Be(ChannelIds.Normal);
        channel.Url.Should().NotBeNullOrWhiteSpace();
        channel.Title.Should().Be("MrBeast");
        channel.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_the_metadata_of_a_channel_by_user_name()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channel = await youtube.Channels.GetByUserAsync(UserNames.Normal);

        // Assert
        channel.Id.Value.Should().Be("UCX6OQ3DkcsbYNE6H8uQQuVA");
        channel.Url.Should().NotBeNullOrWhiteSpace();
        channel.Title.Should().Be("MrBeast");
        channel.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_the_metadata_of_a_channel_by_slug()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channel = await youtube.Channels.GetBySlugAsync(ChannelSlugs.Normal);

        // Assert
        channel.Id.Value.Should().Be("UCSli-_XJrdRwRoPw8DXRiyw");
        channel.Url.Should().NotBeNullOrWhiteSpace();
        channel.Title.Should().Be("Меланія Подоляк");
        channel.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_the_metadata_of_a_channel_by_handle()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channel = await youtube.Channels.GetByHandleAsync(ChannelHandles.Normal);

        // Assert
        channel.Id.Value.Should().Be("UCX6OQ3DkcsbYNE6H8uQQuVA");
        channel.Url.Should().NotBeNullOrWhiteSpace();
        channel.Title.Should().Be("MrBeast");
        channel.Thumbnails.Should().NotBeEmpty();
    }

    [Theory]
    [InlineData(ChannelIds.Normal)]
    [InlineData(ChannelIds.Movies)]
    public async Task I_can_get_the_metadata_of_any_available_channel(string channelId)
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channel = await youtube.Channels.GetAsync(channelId);

        // Assert
        channel.Id.Value.Should().Be(channelId);
        channel.Url.Should().NotBeNullOrWhiteSpace();
        channel.Title.Should().NotBeNullOrWhiteSpace();
        channel.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_videos_uploaded_by_a_channel()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Channels.GetUploadsAsync(ChannelIds.Normal);

        // Assert
        videos.Should().HaveCountGreaterThanOrEqualTo(730);
        videos.Select(v => v.Author.ChannelId).Should().OnlyContain(i => i == ChannelIds.Normal);
    }
}



================================================
FILE: YoutubeExplode.Tests/ClosedCaptionSpecs.cs
================================================
using System;
using System.IO;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Tests.TestData;
using YoutubeExplode.Tests.Utils;

namespace YoutubeExplode.Tests;

public class ClosedCaptionSpecs
{
    [Fact]
    public async Task I_can_get_the_list_of_available_closed_caption_tracks_on_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithClosedCaptions
        );

        // Assert
        manifest.Tracks.Should().HaveCountGreaterThanOrEqualTo(3);

        manifest
            .Tracks.Should()
            .Contain(t =>
                t.Language.Code == "en"
                && t.Language.Name == "English (auto-generated)"
                && t.IsAutoGenerated
            );

        manifest
            .Tracks.Should()
            .Contain(t =>
                t.Language.Code == "en-US"
                && t.Language.Name == "English (United States) - Captions"
                && !t.IsAutoGenerated
            );

        manifest
            .Tracks.Should()
            .Contain(t =>
                t.Language.Code == "es-419"
                && t.Language.Name == "Spanish (Latin America)"
                && !t.IsAutoGenerated
            );
    }

    [Fact]
    public async Task I_can_get_a_specific_closed_caption_track_from_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithClosedCaptions
        );

        var trackInfo = manifest.GetByLanguage("en-US");
        var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

        // Assert
        track.Captions.Should().HaveCountGreaterThanOrEqualTo(500);
    }

    [Fact]
    public async Task I_can_get_a_specific_closed_caption_track_from_a_video_that_has_broken_autogenerated_captions()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithBrokenClosedCaptions
        );

        var trackInfo = manifest.GetByLanguage("en");
        var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

        // Assert
        track.Captions.Should().HaveCountGreaterThanOrEqualTo(2000);
    }

    [Fact]
    public async Task I_can_get_an_individual_closed_caption_from_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithClosedCaptions
        );

        var trackInfo = manifest.GetByLanguage("en-US");
        var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

        var caption = track.GetByTime(TimeSpan.FromSeconds(641));

        // Assert
        caption.Text.Should().Be("as I said in that, and I've kind of");
    }

    [Fact]
    public async Task I_can_get_an_individual_closed_caption_part_from_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithClosedCaptions
        );

        var trackInfo = manifest.GetByLanguage("en");
        var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

        var captionPart = track
            .GetByTime(TimeSpan.FromSeconds(641))
            .GetPartByTime(TimeSpan.FromSeconds(0.15));

        // Assert
        captionPart.Text.Should().Be("know");
    }

    [Fact]
    public async Task I_can_download_a_specific_closed_caption_track_from_a_video()
    {
        // Arrange
        using var file = TempFile.Create();
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.ClosedCaptions.GetManifestAsync(
            VideoIds.WithClosedCaptions
        );

        var trackInfo = manifest.GetByLanguage("en-US");
        await youtube.Videos.ClosedCaptions.DownloadAsync(trackInfo, file.Path);

        // Assert
        var fileInfo = new FileInfo(file.Path);
        fileInfo.Exists.Should().BeTrue();
        fileInfo.Length.Should().BeGreaterThan(0);
    }
}



================================================
FILE: YoutubeExplode.Tests/PlaylistIdSpecs.cs
================================================
using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Playlists;

namespace YoutubeExplode.Tests;

public class PlaylistIdSpecs
{
    [Theory]
    [InlineData("WL")]
    [InlineData("LL")]
    [InlineData("RDMM")]
    [InlineData("PL601B2E69B03FAB9D")]
    [InlineData("PLI5YfMzCfRtZ8eV576YoY3vIYrHjyVm_e")]
    [InlineData("PLWwAypAcFRgKFlxtLbn_u14zddtDJj3mk")]
    [InlineData("OLAK5uy_mtOdjCW76nDvf5yOzgcAVMYpJ5gcW5uKU")]
    [InlineData("RD1hu8-y6fKg0")]
    [InlineData("RDMMU-ty-2B02VY")]
    [InlineData("RDCLAK5uy_lf8okgl2ygD075nhnJVjlfhwp8NsUgEbs")]
    [InlineData("ULl6WWX-BgIiE")]
    [InlineData("UUTMt7iMWa7jy0fNXIktwyLA")]
    [InlineData("OLAK5uy_lLeonUugocG5J0EUAEDmbskX4emejKwcM")]
    [InlineData("FLEnBXANsKmyj2r9xVyKoDiQ")]
    public void I_can_parse_a_playlist_ID_from_an_ID_string(string playlistId)
    {
        // Act
        var parsed = PlaylistId.Parse(playlistId);

        // Assert
        parsed.Value.Should().Be(playlistId);
    }

    [Theory]
    [InlineData(
        "youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H",
        "PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H"
    )]
    [InlineData(
        "youtube.com/watch?v=b8m9zhNAgKs&list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr",
        "PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr"
    )]
    [InlineData(
        "youtu.be/b8m9zhNAgKs/?list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr",
        "PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr"
    )]
    [InlineData(
        "youtube.com/embed/b8m9zhNAgKs/?list=PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr",
        "PL9tY0BWXOZFuFEG_GtOBZ8-8wbkH-NVAr"
    )]
    [InlineData(
        "youtube.com/watch?v=x2ZRoWQ0grU&list=RDEMNJhLy4rECJ_fG8NL-joqsg",
        "RDEMNJhLy4rECJ_fG8NL-joqsg"
    )]
    public void I_can_parse_a_playlist_ID_from_a_URL_string(
        string playlistUrl,
        string expectedPlaylistId
    )
    {
        // Act
        var parsed = PlaylistId.Parse(playlistUrl);

        // Assert
        parsed.Value.Should().Be(expectedPlaylistId);
    }

    [Theory]
    [InlineData("")]
    [InlineData("PLm_3vnTS-pvmZFuF L1Pyhqf8kTTYVKjW")]
    [InlineData("PLm_3vnTS-pvmZFuF3L=Pyhqf8kTTYVKjW")]
    [InlineData("youtube.com/playlist?lisp=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H")]
    [InlineData("youtube.com/")]
    public void I_can_try_to_parse_a_playlist_ID_and_get_an_error_if_the_input_string_is_invalid(
        string playlistIdOrUrl
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => PlaylistId.Parse(playlistIdOrUrl));
    }
}



================================================
FILE: YoutubeExplode.Tests/PlaylistSpecs.cs
================================================
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using Xunit.Abstractions;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Tests.TestData;

namespace YoutubeExplode.Tests;

public class PlaylistSpecs(ITestOutputHelper testOutput)
{
    [Fact]
    public async Task I_can_get_the_metadata_of_a_playlist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var playlist = await youtube.Playlists.GetAsync(PlaylistIds.Normal);

        // Assert
        playlist.Id.Value.Should().Be(PlaylistIds.Normal);
        playlist.Url.Should().NotBeNullOrWhiteSpace();
        playlist.Title.Should().Be("Analytics Academy - Digital Analytics Fundamentals");
        playlist.Author.Should().NotBeNull();
        playlist.Author?.ChannelId.Value.Should().Be("UCJ5UyIAa5nEGksjcdp43Ixw");
        playlist.Author?.ChannelUrl.Should().NotBeNullOrWhiteSpace();
        playlist.Author?.ChannelTitle.Should().Be("Google Analytics");
        playlist
            .Description.Should()
            .Contain("Digital Analytics Fundamentals course on Analytics Academy");
        playlist.Count.Should().Be(22);
        playlist.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_try_to_get_the_metadata_of_a_playlist_and_get_an_error_if_it_is_private()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<PlaylistUnavailableException>(async () =>
            await youtube.Playlists.GetAsync(PlaylistIds.Private)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Fact]
    public async Task I_can_try_to_get_the_metadata_of_a_playlist_and_get_an_error_if_it_does_not_exist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<PlaylistUnavailableException>(async () =>
            await youtube.Playlists.GetAsync(PlaylistIds.NonExisting)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Theory]
    [InlineData(PlaylistIds.Normal)]
    [InlineData(PlaylistIds.MusicMix)]
    [InlineData(PlaylistIds.VideoMix)]
    [InlineData(PlaylistIds.MusicAlbum)]
    [InlineData(PlaylistIds.ContainsLongVideos)]
    [InlineData(PlaylistIds.Weird)]
    public async Task I_can_get_the_metadata_of_any_available_playlist(string playlistId)
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var playlist = await youtube.Playlists.GetAsync(playlistId);

        // Assert
        playlist.Id.Value.Should().Be(playlistId);
        playlist.Url.Should().NotBeNullOrWhiteSpace();
        playlist.Title.Should().NotBeNullOrWhiteSpace();
        playlist.Description.Should().NotBeNull();
        playlist.Count.Should().NotBe(0);
        playlist.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_videos_included_in_a_playlist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Playlists.GetVideosAsync(PlaylistIds.Normal);

        // Assert
        videos.Should().HaveCountGreaterThanOrEqualTo(21);
        videos
            .Select(v => v.Id.Value)
            .Should()
            .Contain(
                [
                    "uPZSSdkGQhM",
                    "fi0w57kr_jY",
                    "xLJt5A-NeQI",
                    "EpDA3XaELqs",
                    "eyltEFyZ678",
                    "TW3gx4t4944",
                    "w9H_P2wAwSE",
                    "OyixJ7A9phg",
                    "dzwRzUEc_tA",
                    "vEpq3nYeZBc",
                    "4gYioQkIqKk",
                    "xyh8iG5mRIs",
                    "ORrYEEH_KPc",
                    "ii0T5JUO2BY",
                    "hgycbw6Beuc",
                    "Dz-zgq6OqTI",
                    "I1b4GT-GuEs",
                    "dN3gkBBffhs",
                    "8Kg-8ZjgLAQ",
                    "E9zfpKsw6f8",
                    "eBCw9sC5D40",
                ]
            );
    }

    [Fact]
    public async Task I_can_get_videos_included_in_a_large_playlist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Playlists.GetVideosAsync(PlaylistIds.Large);

        // Assert
        videos.Should().HaveCountGreaterThanOrEqualTo(1900);
        videos
            .Select(v => v.Id.Value)
            .Should()
            .Contain(
                [
                    "RBumgq5yVrA",
                    "kN0iD0pI3o0",
                    "YqB8Dm65X18",
                    "jlvY1o6XKwA",
                    "-0kcet4aPpQ",
                    "RnGJ3KJri1g",
                    "x-IR7PtA7RA",
                    "N-8E9mHxDy0",
                    "5ly88Ju1N6A",
                ]
            );
    }

    [Theory]
    [InlineData(PlaylistIds.Normal)]
    [InlineData(PlaylistIds.MusicMix)]
    [InlineData(PlaylistIds.VideoMix)]
    [InlineData(PlaylistIds.MusicAlbum)]
    [InlineData(PlaylistIds.UserUploads)]
    [InlineData(PlaylistIds.ContainsLongVideos)]
    [InlineData(PlaylistIds.Weird)]
    public async Task I_can_get_videos_included_in_any_available_playlist(string playlistId)
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Playlists.GetVideosAsync(playlistId);

        // Assert
        videos.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_a_subset_of_videos_included_in_a_playlist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Playlists.GetVideosAsync(PlaylistIds.Large).CollectAsync(10);

        // Assert
        videos.Should().HaveCount(10);
    }
}



================================================
FILE: YoutubeExplode.Tests/SearchSpecs.cs
================================================
using System;
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Common;

namespace YoutubeExplode.Tests;

public class SearchSpecs
{
    [Fact]
    public async Task I_can_get_results_from_a_search_query()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var results = await youtube.Search.GetResultsAsync("undead corporation");

        // Assert
        results.Should().HaveCountGreaterThanOrEqualTo(50);
        results
            .Should()
            .Contain(r =>
                r.Title.Contains("undead corporation", StringComparison.OrdinalIgnoreCase)
            );
    }

    [Fact]
    public async Task I_can_get_results_from_a_search_query_that_contains_special_characters()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var results = await youtube.Search.GetResultsAsync("\"dune 2\" ending");

        // Assert
        results.Should().HaveCountGreaterThanOrEqualTo(50);
        results.Should().Contain(r => r.Title.Contains("dune", StringComparison.OrdinalIgnoreCase));
    }

    [Fact]
    public async Task I_can_get_results_from_a_search_query_that_contains_non_ascii_characters()
    {
        // https://github.com/Tyrrrz/YoutubeExplode/issues/787

        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var results = await youtube.Search.GetResultsAsync("נועה קירל");

        // Assert
        results.Should().HaveCountGreaterThanOrEqualTo(50);
        results
            .Should()
            .Contain(r => r.Title.Contains("נועה קירל", StringComparison.OrdinalIgnoreCase));
    }

    [Fact]
    public async Task I_can_get_results_from_a_search_query_that_contains_non_ascii_characters_and_special_characters()
    {
        // https://github.com/Tyrrrz/YoutubeExplode/issues/787

        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var results = await youtube.Search.GetResultsAsync("\"נועה קירל\"");

        // Assert
        results.Should().HaveCountGreaterThanOrEqualTo(50);
        results
            .Should()
            .Contain(r => r.Title.Contains("נועה קירל", StringComparison.OrdinalIgnoreCase));
    }

    [Fact]
    public async Task I_can_get_video_results_from_a_search_query()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var videos = await youtube.Search.GetVideosAsync("undead corporation");

        // Assert
        videos.Should().HaveCountGreaterThanOrEqualTo(50);
    }

    [Fact]
    public async Task I_can_get_playlist_results_from_a_search_query()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var playlists = await youtube.Search.GetPlaylistsAsync("undead corporation");

        // Assert
        playlists.Should().NotBeEmpty();

        var last = playlists.Last();

        last.Title.Should().NotBeNullOrWhiteSpace();
        last.Author.Should().NotBeNull();
        last.Thumbnails.Should().NotBeEmpty();

        var lastThumb = last.Thumbnails.Last();
        lastThumb.Url.Should().NotBeNullOrWhiteSpace();
        lastThumb.Resolution.Should().NotBeSameAs(default(Resolution));
    }

    [Fact]
    public async Task I_can_get_channel_results_from_a_search_query()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var channels = await youtube.Search.GetChannelsAsync("undead corporation");

        // Assert
        channels.Should().NotBeEmpty();
    }
}



================================================
FILE: YoutubeExplode.Tests/StreamSpecs.cs
================================================
using System;
using System.Buffers;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using Xunit.Abstractions;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Tests.TestData;
using YoutubeExplode.Tests.Utils;
using YoutubeExplode.Videos.Streams;

namespace YoutubeExplode.Tests;

public class StreamSpecs(ITestOutputHelper testOutput)
{
    [Fact]
    public async Task I_can_get_the_list_of_available_streams_of_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(
            VideoIds.WithHighQualityStreams
        );

        // Assert
        manifest.Streams.Should().NotBeEmpty();

        manifest
            .GetVideoStreams()
            .Should()
            .Contain(s =>
                s.VideoQuality.MaxHeight == 2160
                && s.VideoQuality.Framerate == 60
                && s.VideoQuality.IsHighDefinition
            );

        manifest
            .GetVideoStreams()
            .Should()
            .Contain(s =>
                s.VideoQuality.MaxHeight == 1080
                && s.VideoQuality.Framerate == 60
                && s.VideoQuality.IsHighDefinition
            );

        manifest
            .GetVideoStreams()
            .Should()
            .Contain(s => s.VideoQuality.MaxHeight == 720 && !s.VideoQuality.IsHighDefinition);

        manifest
            .GetVideoStreams()
            .Should()
            .Contain(s => s.VideoQuality.MaxHeight == 144 && !s.VideoQuality.IsHighDefinition);
    }

    [Fact]
    public async Task I_can_get_the_list_of_available_streams_of_a_video_with_multiple_audio_languages()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(
            VideoIds.WithMultipleAudioLanguages
        );

        // Assert
        manifest.Streams.Should().NotBeEmpty();

        manifest
            .GetAudioStreams()
            .Should()
            .Contain(t =>
                t.AudioLanguage != null
                && t.AudioLanguage.Value.Code == "en-US"
                && t.AudioLanguage.Value.Name == "English (United States) original"
                && t.IsAudioLanguageDefault == true
            );

        manifest
            .GetAudioStreams()
            .Should()
            .Contain(t =>
                t.AudioLanguage != null
                && t.AudioLanguage.Value.Code == "fr-FR"
                && t.AudioLanguage.Value.Name == "French (France)"
                && t.IsAudioLanguageDefault == false
            );

        manifest
            .GetAudioStreams()
            .Should()
            .Contain(t =>
                t.AudioLanguage != null
                && t.AudioLanguage.Value.Code == "it"
                && t.AudioLanguage.Value.Name == "Italian"
                && t.IsAudioLanguageDefault == false
            );

        manifest
            .GetAudioStreams()
            .Should()
            .Contain(t =>
                t.AudioLanguage != null
                && t.AudioLanguage.Value.Code == "pt-BR"
                && t.AudioLanguage.Value.Name == "Portuguese (Brazil)"
                && t.IsAudioLanguageDefault == false
            );
    }

    [Theory]
    [InlineData(VideoIds.Normal)]
    [InlineData(VideoIds.Unlisted)]
    [InlineData(VideoIds.EmbedRestrictedByYouTube)]
    [InlineData(VideoIds.EmbedRestrictedByAuthor)]
    [InlineData(VideoIds.ContentCheckViolent, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.ContentCheckSexual, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.ContentCheckSuicide)]
    [InlineData(VideoIds.LiveStreamRecording)]
    [InlineData(VideoIds.WithOmnidirectionalStreams)]
    [InlineData(VideoIds.WithHighDynamicRangeStreams)]
    public async Task I_can_get_the_list_of_available_streams_of_any_playable_video(string videoId)
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(videoId);

        // Assert
        manifest.Streams.Should().NotBeEmpty();
    }

    [Fact(Skip = "Preview video ID is not always available")]
    public async Task I_can_try_to_get_the_list_of_available_streams_of_a_video_and_get_an_error_if_it_is_paid()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoRequiresPurchaseException>(async () =>
            await youtube.Videos.Streams.GetManifestAsync(VideoIds.RequiresPurchase)
        );

        ex.PreviewVideoId.Value.Should().NotBeNullOrWhiteSpace();

        testOutput.WriteLine(ex.ToString());
    }

    [Fact]
    public async Task I_can_try_to_get_the_list_of_available_streams_of_a_video_and_get_an_error_if_it_is_private()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoUnavailableException>(async () =>
            await youtube.Videos.Streams.GetManifestAsync(VideoIds.Private)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Fact]
    public async Task I_can_try_to_get_the_list_of_available_streams_of_a_video_and_get_an_error_if_it_does_not_exist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoUnavailableException>(async () =>
            await youtube.Videos.Streams.GetManifestAsync(VideoIds.Deleted)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Theory]
    [InlineData(VideoIds.Normal)]
    [InlineData(VideoIds.ContentCheckViolent, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.ContentCheckSexual, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.LiveStreamRecording)]
    [InlineData(VideoIds.WithOmnidirectionalStreams)]
    public async Task I_can_get_a_specific_stream_of_a_video(string videoId)
    {
        // Arrange
        using var buffer = MemoryPool<byte>.Shared.Rent(1024);
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(videoId);

        foreach (var streamInfo in manifest.Streams)
        {
            using var stream = await youtube.Videos.Streams.GetAsync(streamInfo);
            var bytesRead = await stream.ReadAsync(buffer.Memory);

            // Assert
            bytesRead.Should().BeGreaterThan(0);
        }
    }

    [Theory]
    [InlineData(VideoIds.Normal)]
    [InlineData(VideoIds.Unlisted)]
    [InlineData(VideoIds.EmbedRestrictedByYouTube)]
    [InlineData(VideoIds.EmbedRestrictedByAuthor)]
    [InlineData(VideoIds.ContentCheckViolent, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.ContentCheckSexual, Skip = "Needs n-signature deciphering to support")]
    [InlineData(VideoIds.ContentCheckSuicide)]
    [InlineData(VideoIds.LiveStreamRecording)]
    [InlineData(VideoIds.WithOmnidirectionalStreams)]
    public async Task I_can_download_a_specific_stream_of_a_video(string videoId)
    {
        // Arrange
        using var file = TempFile.Create();
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(videoId);
        var streamInfo = manifest.Streams.OrderBy(s => s.Size).First();

        await youtube.Videos.Streams.DownloadAsync(streamInfo, file.Path);

        // Assert
        var fileInfo = new FileInfo(file.Path);
        fileInfo.Exists.Should().BeTrue();
        fileInfo.Length.Should().Be(streamInfo.Size.Bytes);
    }

    [Fact]
    public async Task I_can_download_the_highest_bitrate_stream_of_a_video()
    {
        // Arrange
        using var file = TempFile.Create();
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(VideoIds.Normal);
        var streamInfo = manifest.Streams.GetWithHighestBitrate();

        await youtube.Videos.Streams.DownloadAsync(streamInfo, file.Path);

        // Assert
        var fileInfo = new FileInfo(file.Path);
        fileInfo.Exists.Should().BeTrue();
        fileInfo.Length.Should().Be(streamInfo.Size.Bytes);
    }

    [Fact]
    public async Task I_can_download_the_highest_quality_stream_of_a_video()
    {
        // Arrange
        using var file = TempFile.Create();
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(VideoIds.Normal);
        var streamInfo = manifest.GetVideoStreams().GetWithHighestVideoQuality();

        await youtube.Videos.Streams.DownloadAsync(streamInfo, file.Path);

        // Assert
        var fileInfo = new FileInfo(file.Path);
        fileInfo.Exists.Should().BeTrue();
        fileInfo.Length.Should().Be(streamInfo.Size.Bytes);
    }

    [Fact]
    public async Task I_can_seek_to_a_specific_position_of_a_stream_from_a_video()
    {
        // Arrange
        using var buffer = new MemoryStream();
        var youtube = new YoutubeClient();

        // Act
        var manifest = await youtube.Videos.Streams.GetManifestAsync(VideoIds.Normal);
        var streamInfo = manifest.GetAudioStreams().OrderBy(s => s.Size).First();

        using var stream = await youtube.Videos.Streams.GetAsync(streamInfo);
        stream.Seek(1000, SeekOrigin.Begin);
        await stream.CopyToAsync(buffer);

        // Assert
        buffer.Length.Should().Be(streamInfo.Size.Bytes - 1000);
    }

    [Fact]
    public async Task I_can_get_the_HTTP_live_stream_URL_for_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var url = await youtube.Videos.Streams.GetHttpLiveStreamUrlAsync(VideoIds.LiveStream);

        // Assert
        url.Should().NotBeNullOrWhiteSpace();
    }

    [Fact]
    public async Task I_can_try_to_get_the_HTTP_live_stream_URL_for_a_video_and_get_an_error_if_it_is_unplayable()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoUnplayableException>(async () =>
            await youtube.Videos.Streams.GetHttpLiveStreamUrlAsync(VideoIds.RequiresPurchase)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Fact(Skip = "The iOS client returns HLS URLs even for non-live videos")]
    public async Task I_can_try_to_get_the_HTTP_live_stream_URL_for_a_video_and_get_an_error_if_it_is_not_live()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<YoutubeExplodeException>(async () =>
            await youtube.Videos.Streams.GetHttpLiveStreamUrlAsync(VideoIds.Normal)
        );

        testOutput.WriteLine(ex.ToString());
    }
}



================================================
FILE: YoutubeExplode.Tests/UserNameSpecs.cs
================================================
using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Channels;

namespace YoutubeExplode.Tests;

public class UserNameSpecs
{
    [Theory]
    [InlineData("TheTyrrr")]
    [InlineData("KannibalenRecords")]
    [InlineData("JClayton1994")]
    public void I_can_parse_a_user_name_from_a_user_name_string(string userName)
    {
        // Act
        var parsed = UserName.Parse(userName);

        // Assert
        parsed.Value.Should().Be(userName);
    }

    [Theory]
    [InlineData("youtube.com/user/ProZD", "ProZD")]
    [InlineData("youtube.com/user/TheTyrrr", "TheTyrrr")]
    public void I_can_parse_a_user_name_from_a_URL_string(string userUrl, string expectedUserName)
    {
        // Act
        var parsed = UserName.Parse(userUrl);

        // Assert
        parsed.Value.Should().Be(expectedUserName);
    }

    [Theory]
    [InlineData("")]
    [InlineData("The_Tyrrr")]
    [InlineData("0123456789ABCDEFGHIJK")]
    [InlineData("A1B2C3-")]
    [InlineData("=0123456789ABCDEF")]
    [InlineData("youtube.com/user/P_roZD")]
    [InlineData("example.com/user/ProZD")]
    public void I_can_try_to_parse_a_user_name_and_get_an_error_if_the_input_string_is_invalid(
        string userName
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => UserName.Parse(userName));
    }
}



================================================
FILE: YoutubeExplode.Tests/VideoIdSpecs.cs
================================================
using System;
using FluentAssertions;
using Xunit;
using YoutubeExplode.Videos;

namespace YoutubeExplode.Tests;

public class VideoIdSpecs
{
    [Theory]
    [InlineData("9bZkp7q19f0")]
    [InlineData("_kmeFXjjGfk")]
    [InlineData("AI7ULzgf8RU")]
    public void I_can_parse_a_video_ID_from_an_ID_string(string videoId)
    {
        // Act
        var parsed = VideoId.Parse(videoId);

        // Assert
        parsed.Value.Should().Be(videoId);
    }

    [Theory]
    [InlineData("youtube.com/watch?v=yIVRs6YSbOM", "yIVRs6YSbOM")]
    [InlineData("youtu.be/watch?v=Fcds0_MrgNU", "Fcds0_MrgNU")]
    [InlineData("youtu.be/yIVRs6YSbOM", "yIVRs6YSbOM")]
    [InlineData("youtube.com/embed/yIVRs6YSbOM", "yIVRs6YSbOM")]
    [InlineData("youtube.com/shorts/sKL1vjP0tIo", "sKL1vjP0tIo")]
    [InlineData("youtube.com/live/jfKfPfyJRdk", "jfKfPfyJRdk")]
    public void I_can_parse_a_video_ID_from_a_URL_string(string videoUrl, string expectedVideoId)
    {
        // Act
        var parsed = VideoId.Parse(videoUrl);

        // Assert
        parsed.Value.Should().Be(expectedVideoId);
    }

    [Theory]
    [InlineData("")]
    [InlineData("pI2I2zqzeK")]
    [InlineData("pI2I2z zeKg")]
    [InlineData("youtube.com/xxx?v=pI2I2zqzeKg")]
    [InlineData("youtu.be/watch?v=xxx")]
    [InlineData("youtube.com/embed/")]
    [InlineData("youtube.com/live/")]
    public void I_can_try_to_parse_a_video_ID_and_get_an_error_if_the_input_string_is_invalid(
        string videoId
    )
    {
        // Act & assert
        Assert.Throws<ArgumentException>(() => VideoId.Parse(videoId));
    }
}



================================================
FILE: YoutubeExplode.Tests/VideoSpecs.cs
================================================
using System;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;
using Xunit.Abstractions;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Tests.TestData;

namespace YoutubeExplode.Tests;

public class VideoSpecs(ITestOutputHelper testOutput)
{
    [Fact]
    public async Task I_can_get_the_metadata_of_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var video = await youtube.Videos.GetAsync(VideoIds.Normal);

        // Assert
        video.Id.Value.Should().Be(VideoIds.Normal);
        video.Url.Should().NotBeNullOrWhiteSpace();
        video.Title.Should().Be("PSY - GANGNAM STYLE(강남스타일) M/V");
        video.Author.ChannelId.Value.Should().Be("UCrDkAvwZum-UTjHmzDI2iIw");
        video.Author.ChannelUrl.Should().NotBeNullOrWhiteSpace();
        video.Author.ChannelTitle.Should().Be("officialpsy");
        video.UploadDate.Date.Should().Be(new DateTime(2012, 07, 15));
        video.Description.Should().Contain("More about PSY@");
        video.Duration.Should().BeCloseTo(TimeSpan.FromSeconds(252), TimeSpan.FromSeconds(1));
        video.Thumbnails.Should().NotBeEmpty();
        video
            .Keywords.Should()
            .BeEquivalentTo(
                "PSY",
                "싸이",
                "강남스타일",
                "뮤직비디오",
                "Music Video",
                "Gangnam Style",
                "KOREAN SINGER",
                "KPOP",
                "KOERAN WAVE",
                "PSY 6甲",
                "6th Studio Album",
                "싸이6집",
                "육갑",
                "Psy Gangnam Style"
            );
        video.Engagement.ViewCount.Should().BeGreaterThanOrEqualTo(4_650_000_000);
        video.Engagement.LikeCount.Should().BeGreaterThanOrEqualTo(24_000_000);
        video.Engagement.DislikeCount.Should().BeGreaterThanOrEqualTo(0);
        video.Engagement.AverageRating.Should().BeGreaterThanOrEqualTo(0);
    }

    [Fact]
    public async Task I_can_try_to_get_the_metadata_of_a_video_and_get_an_error_if_it_is_private()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoUnavailableException>(async () =>
            await youtube.Videos.GetAsync(VideoIds.Private)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Fact]
    public async Task I_can_try_to_get_the_metadata_of_a_video_and_get_an_error_if_it_does_not_exist()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act & assert
        var ex = await Assert.ThrowsAsync<VideoUnavailableException>(async () =>
            await youtube.Videos.GetAsync(VideoIds.Deleted)
        );

        testOutput.WriteLine(ex.ToString());
    }

    [Theory]
    [InlineData(VideoIds.Normal)]
    [InlineData(VideoIds.Unlisted)]
    [InlineData(VideoIds.RequiresPurchaseDistributed)]
    [InlineData(VideoIds.EmbedRestrictedByYouTube)]
    [InlineData(VideoIds.EmbedRestrictedByAuthor)]
    [InlineData(VideoIds.ContentCheckViolent)]
    [InlineData(VideoIds.WithBrokenTitle)]
    public async Task I_can_get_the_metadata_of_any_available_video(string videoId)
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var video = await youtube.Videos.GetAsync(videoId);

        // Assert
        video.Id.Value.Should().Be(videoId);
        video.Url.Should().NotBeNullOrWhiteSpace();
        video.Title.Should().NotBeNull(); // empty titles are allowed
        video.Author.ChannelId.Value.Should().NotBeNullOrWhiteSpace();
        video.Author.ChannelUrl.Should().NotBeNullOrWhiteSpace();
        video.Author.ChannelTitle.Should().NotBeNullOrWhiteSpace();
        video.UploadDate.Date.Should().NotBe(default);
        video.Description.Should().NotBeNull();
        video.Duration.Should().NotBe(default);
        video.Thumbnails.Should().NotBeEmpty();
    }

    [Fact]
    public async Task I_can_get_the_highest_resolution_thumbnail_from_a_video()
    {
        // Arrange
        var youtube = new YoutubeClient();

        // Act
        var video = await youtube.Videos.GetAsync(VideoIds.Normal);
        var thumbnail = video.Thumbnails.GetWithHighestResolution();

        // Assert
        thumbnail.Url.Should().NotBeNullOrWhiteSpace();
    }
}



================================================
FILE: YoutubeExplode.Tests/xunit.runner.json
================================================
﻿{
  "$schema": "https://xunit.net/schema/current/xunit.runner.schema.json",
  "methodDisplayOptions": "all",
  "methodDisplay": "method"
}


================================================
FILE: YoutubeExplode.Tests/YoutubeExplode.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>net9.0</TargetFrameworks>
    <TargetFrameworks Condition="$([MSBuild]::IsOsPlatform('Windows'))"
      >$(TargetFrameworks);net48</TargetFrameworks
    >
  </PropertyGroup>
  <ItemGroup>
    <Content Include="xunit.runner.json" CopyToOutputDirectory="PreserveNewest" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="coverlet.collector" Version="6.0.4" PrivateAssets="all" />
    <PackageReference Include="CSharpier.MsBuild" Version="1.0.2" PrivateAssets="all" />
    <PackageReference Include="FluentAssertions" Version="8.3.0" />
    <PackageReference Include="GitHubActionsTestLogger" Version="2.4.1" PrivateAssets="all" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.0" />
    <PackageReference Include="PolyShim" Version="1.15.0" PrivateAssets="all" />
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.0" PrivateAssets="all" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\YoutubeExplode\YoutubeExplode.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: YoutubeExplode.Tests/TestData/ChannelHandles.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class ChannelHandles
{
    public const string Normal = "MrBeast";
}



================================================
FILE: YoutubeExplode.Tests/TestData/ChannelIds.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class ChannelIds
{
    public const string Normal = "UCX6OQ3DkcsbYNE6H8uQQuVA";
    public const string Movies = "UCuVPpxrm2VAgpH3Ktln4HXg";
}



================================================
FILE: YoutubeExplode.Tests/TestData/ChannelSlugs.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class ChannelSlugs
{
    public const string Normal = "МеланіяПодоляк";
}



================================================
FILE: YoutubeExplode.Tests/TestData/PlaylistIds.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class PlaylistIds
{
    public const string Normal = "PLI5YfMzCfRtZ8eV576YoY3vIYrHjyVm_e";
    public const string Private = "PLYjTMWc3sa4ZKheRwyA1q56xxQrfQEUBr";
    public const string NonExisting = "PLYjTMWc3sa4ZKheRwyA1q56xxQrfQEUBx";
    public const string Large = "PLWwAypAcFRgKFlxtLbn_u14zddtDJj3mk";
    public const string VideoMix = "RDTsYhxMnGYCw";
    public const string MusicMix = "RDCLAK5uy_lf8okgl2ygD075nhnJVjlfhwp8NsUgEbs";
    public const string MusicAlbum = "OLAK5uy_lLeonUugocG5J0EUAEDmbskX4emejKwcM";
    public const string UserUploads = "UUTMt7iMWa7jy0fNXIktwyLA";
    public const string Weird = "PL601B2E69B03FAB9D";
    public const string ContainsLongVideos = "PLkk2FsMngwGi9FNkWIoNZlfqglcldj_Zs";
}



================================================
FILE: YoutubeExplode.Tests/TestData/UserNames.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class UserNames
{
    public const string Normal = "mrbeast6000";
}



================================================
FILE: YoutubeExplode.Tests/TestData/VideoIds.cs
================================================
﻿namespace YoutubeExplode.Tests.TestData;

internal static class VideoIds
{
    public const string Normal = "9bZkp7q19f0";
    public const string Unlisted = "UGh4_HsibAE";
    public const string Private = "pb_hHv3fByo";
    public const string Deleted = "qld9w0b-1ao";
    public const string EmbedRestrictedByYouTube = "_kmeFXjjGfk";
    public const string EmbedRestrictedByAuthor = "MeJVWBSsPAY";
    public const string ContentCheckViolent = "rXMX4YJ7Lks";
    public const string ContentCheckSexual = "SkRSXFQerZs";
    public const string ContentCheckSuicide = "4QXCPuwBz2E";
    public const string RequiresPurchase = "p3dDcKOFXQg";
    public const string RequiresPurchaseDistributed = "qs3NZHVM_Ik";
    public const string LiveStream = "jfKfPfyJRdk";
    public const string LiveStreamRecording = "rsAAeyAr-9Y";
    public const string WithBrokenTitle = "4ZJWv6t-PfY";
    public const string WithHighQualityStreams = "V5Fsj_sCKdg";
    public const string WithOmnidirectionalStreams = "-xNN-bJQ4vI";
    public const string WithHighDynamicRangeStreams = "vX2vsvdq8nw";
    public const string WithClosedCaptions = "YltHGKX80Y8";
    public const string WithBrokenClosedCaptions = "1VKIIw05JnE";
    public const string WithMultipleAudioLanguages = "ngqcjXfggHQ";
}



================================================
FILE: YoutubeExplode.Tests/Utils/TempFile.cs
================================================
﻿using System;
using System.IO;
using System.Reflection;
using PathEx = System.IO.Path;

namespace YoutubeExplode.Tests.Utils;

internal partial class TempFile(string path) : IDisposable
{
    public string Path { get; } = path;

    public void Dispose()
    {
        try
        {
            File.Delete(Path);
        }
        catch (FileNotFoundException) { }
    }
}

internal partial class TempFile
{
    public static TempFile Create()
    {
        var dirPath = PathEx.Combine(
            PathEx.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
                ?? Directory.GetCurrentDirectory(),
            "Temp"
        );

        Directory.CreateDirectory(dirPath);

        var filePath = PathEx.Combine(dirPath, Guid.NewGuid() + ".tmp");

        return new TempFile(filePath);
    }
}



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: github-actions
    directory: "/"
    schedule:
      interval: monthly
    labels:
      - enhancement
    groups:
      actions:
        patterns:
          - "*"
  - package-ecosystem: nuget
    directory: "/"
    schedule:
      interval: monthly
    labels:
      - enhancement
    groups:
      nuget:
        patterns:
          - "*"



================================================
FILE: .github/ISSUE_TEMPLATE/bug-report.yml
================================================
name: 🐛 Bug report
description: Report broken functionality.
labels: [bug]

body:
  - type: markdown
    attributes:
      value: |
        - Avoid generic or vague titles such as "Something's not working" or "A couple of problems" — be as descriptive as possible.
        - Keep your issue focused on one single problem. If you have multiple bug reports, please create a separate issue for each of them.
        - Issues should represent **complete and actionable** work items. If you are unsure about something or have a question, please start a [discussion](https://github.com/Tyrrrz/YoutubeExplode/discussions/new) instead.
        - Remember that **YoutubeExplode** is an open-source project funded by the community. If you find it useful, **please consider [donating](https://tyrrrz.me/donate) to support its development**.

        ___

  - type: input
    attributes:
      label: Version
      description: Which version of the package does this bug affect? Make sure you're not using an outdated version.
      placeholder: v1.0.0
    validations:
      required: true

  - type: input
    attributes:
      label: Platform
      description: Which platform do you experience this bug on?
      placeholder: .NET 7.0 / Windows 11
    validations:
      required: true

  - type: textarea
    attributes:
      label: Steps to reproduce
      description: >
        Minimum steps required to reproduce the bug, including prerequisites, code snippets, or other relevant items.
        The information provided in this field must be readily actionable, meaning that anyone should be able to reproduce the bug by following these steps.
        If the reproduction steps are too complex to fit in this field, please provide a link to a repository instead.
      placeholder: |
        - Step 1
        - Step 2
        - Step 3
    validations:
      required: true

  - type: textarea
    attributes:
      label: Details
      description: Clear and thorough explanation of the bug, including any additional information you may find relevant.
      placeholder: |
        - Expected behavior: ...
        - Actual behavior: ...
    validations:
      required: true

  - type: checkboxes
    attributes:
      label: Checklist
      description: Quick list of checks to ensure that everything is in order.
      options:
        - label: I have looked through existing issues to make sure that this bug has not been reported before
          required: true
        - label: I have provided a descriptive title for this issue
          required: true
        - label: I have made sure that this bug is reproducible on the latest version of the package
          required: true
        - label: I have provided all the information needed to reproduce this bug as efficiently as possible
          required: true
        - label: I have sponsored this project
          required: false
        - label: I have not read any of the above and just checked all the boxes to submit the issue
          required: false

  - type: markdown
    attributes:
      value: |
        If you are struggling to provide actionable reproduction steps, or if something else is preventing you from creating a complete bug report, please start a [discussion](https://github.com/Tyrrrz/YoutubeExplode/discussions/new) instead.



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false
contact_links:
  - name: ⚠ Feature request
    url: https://github.com/Tyrrrz/.github/blob/master/docs/project-status.md
    about: Sorry, but this project is in maintenance mode and no longer accepts new feature requests.
  - name: 🗨 Discussions
    url: https://github.com/Tyrrrz/YoutubeExplode/discussions/new
    about: Ask and answer questions.
  - name: 💬 Discord server
    url: https://discord.gg/2SUWKFnHSm
    about: Chat with the project community.



================================================
FILE: .github/workflows/main.yml
================================================
name: main

on:
  workflow_dispatch:
    inputs:
      package-version:
        type: string
        description: Package version
        required: false
      deploy:
        type: boolean
        description: Deploy package
        required: false
        default: false
  schedule:
    - cron: "0 0 * * *"
  push:
    branches:
      - master
    tags:
      - "*"
  pull_request:
    branches:
      - master

jobs:
  main:
    uses: Tyrrrz/.github/.github/workflows/nuget.yml@master
    with:
      # CI tests currently don't work due to YouTube's anti-bot measures
      # https://github.com/Tyrrrz/YoutubeExplode/issues/794
      skip-tests: true
      deploy: ${{ inputs.deploy || github.ref_type == 'tag' }}
      package-version: ${{ inputs.package-version || (github.ref_type == 'tag' && github.ref_name) || format('0.0.0-ci-{0}', github.sha) }}
      dotnet-version: 9.0.x
    secrets:
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      NUGET_TOKEN: ${{ secrets.NUGET_TOKEN }}
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}


